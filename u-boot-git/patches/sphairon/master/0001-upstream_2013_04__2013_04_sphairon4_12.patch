diff --git a/.gitignore b/.gitignore
index ed212032b4dd7ef53eac57f5b208fc6153c73fbe..db8cf1fed400b968c499cc941c872a6e0860c41b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,6 +47,13 @@
 /u-boot.dtb
 /u-boot.sb
 /u-boot.geany
+/u-boot.bin.lzma
+/u-boot.bin.lzo
+/u-boot.ltq.lzma.norspl
+/u-boot.ltq.lzo.norspl
+/u-boot.ltq.norspl
+/u-boot.lzma.img
+/u-boot.lzo.img
 
 #
 # Generated files
diff --git a/Makefile b/Makefile
index 3fd6d156c2b51b498aca3b8622b3bcd843b12a04..27b85ab35a29da0278dd68cb8978b56ca5445325 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 2013
 PATCHLEVEL = 04
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -sphairon4.12
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 else
@@ -284,6 +284,7 @@ LIBS-y += drivers/mtd/ubi/libubi.o
 LIBS-y += drivers/mtd/spi/libspi_flash.o
 LIBS-y += drivers/net/libnet.o
 LIBS-y += drivers/net/phy/libphy.o
+LIBS-y += drivers/net/switch/libswitch.o
 LIBS-y += drivers/pci/libpci.o
 LIBS-y += drivers/pcmcia/libpcmcia.o
 LIBS-y += drivers/power/libpower.o \
@@ -326,6 +327,7 @@ LIBS-y += lib/libfdt/libfdt.o
 LIBS-y += api/libapi.o
 LIBS-y += post/libpost.o
 LIBS-y += test/libtest.o
+LIBS-$(CONFIG_LIB_SPHAIRON) += lib/sphairon/libsphairon.o
 
 ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX)$(CONFIG_TI814X),)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
@@ -435,6 +437,12 @@ $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 		$(BOARD_SIZE_CHECK)
 
+$(obj)u-boot.bin.lzma:	$(obj)u-boot.bin
+		cat $< | lzma -9 -f - > $@
+
+$(obj)u-boot.bin.lzo:	$(obj)u-boot.bin
+		cat $< | lzop -9 -f - > $@
+
 $(obj)u-boot.ldr:	$(obj)u-boot
 		$(CREATE_LDR_ENV)
 		$(LDR) -T $(CONFIG_BFIN_CPU) -c $@ $< $(LDR_FLAGS)
@@ -454,13 +462,23 @@ ifndef CONFIG_SYS_UBOOT_START
 CONFIG_SYS_UBOOT_START := 0
 endif
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
-		$(obj)tools/mkimage -A $(ARCH) -T firmware -C none \
+define GEN_UBOOT_IMAGE
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C $(1) \
 		-O u-boot -a $(CONFIG_SYS_TEXT_BASE) \
 		-e $(CONFIG_SYS_UBOOT_START) \
 		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
 			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
 		-d $< $@
+endef
+
+$(obj)u-boot.img:	$(obj)u-boot.bin
+		$(call GEN_UBOOT_IMAGE,none)
+
+$(obj)u-boot.lzma.img:	$(obj)u-boot.bin.lzma
+		$(call GEN_UBOOT_IMAGE,lzma)
+
+$(obj)u-boot.lzo.img:	$(obj)u-boot.bin.lzo
+		$(call GEN_UBOOT_IMAGE,lzo)
 
 $(obj)u-boot.imx: $(obj)u-boot.bin depend
 		$(MAKE) -C $(SRCTREE)/arch/arm/imx-common $(OBJTREE)/u-boot.imx
@@ -554,6 +572,27 @@ endif
 $(obj)u-boot-img.bin: $(obj)spl/u-boot-spl.bin $(obj)u-boot.img
 		cat $(obj)spl/u-boot-spl.bin $(obj)u-boot.img > $@
 
+$(obj)u-boot.ltq.sfspl:	$(obj)u-boot.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
+$(obj)u-boot.ltq.lzo.sfspl: $(obj)u-boot.lzo.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
+$(obj)u-boot.ltq.lzma.sfspl: $(obj)u-boot.lzma.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
+$(obj)u-boot.ltq.norspl: $(obj)u-boot.img $(obj)spl/u-boot-spl.bin
+	cat $(obj)spl/u-boot-spl.bin $< > $@
+
+$(obj)u-boot.ltq.lzo.norspl: $(obj)u-boot.lzo.img $(obj)spl/u-boot-spl.bin
+	cat $(obj)spl/u-boot-spl.bin $< > $@
+
+$(obj)u-boot.ltq.lzma.norspl: $(obj)u-boot.lzma.img $(obj)spl/u-boot-spl.bin
+	cat $(obj)spl/u-boot-spl.bin $< > $@
+
 ifeq ($(CONFIG_SANDBOX),y)
 GEN_UBOOT = \
 		cd $(LNDIR) && $(CC) $(SYMS) -T $(obj)u-boot.lds \
diff --git a/README b/README
index 0bc0af570062451f195a7e01dbb387048d1c134b..cac3e33cb708035bfe9cd50a7dee41c70b70b6f1 100644
--- a/README
+++ b/README
@@ -460,6 +460,11 @@ The following options need to be configured:
 			CONF_CM_CACHABLE_CUW
 			CONF_CM_CACHABLE_ACCELERATED
 
+		CONFIG_SYS_MIPS_CACHE_EXT_INIT
+
+		Enable this to use extended cache initialization for recent
+		MIPS CPU cores.
+
 		CONFIG_SYS_XWAY_EBU_BOOTCFG
 
 		Special option for Lantiq XWAY SoCs for booting from NOR flash.
@@ -523,6 +528,12 @@ The following options need to be configured:
 		expect it to be in bytes, others in MB.
 		Define CONFIG_MEMSIZE_IN_BYTES to make it in bytes.
 
+		CONFIG_DISABLE_ENV_INIT		[relevant for MIPS only]
+
+		Disable initialization of traditional environment variables
+		passed to Linux. Modern kernels only use variables from command
+		line.
+
 		CONFIG_OF_LIBFDT
 
 		New kernel versions are expecting firmware settings to be
diff --git a/arch/mips/config.mk b/arch/mips/config.mk
index aaa94e8be203f7e1c0a1da17a240f0b7decc20cd..874b1bb825f8d241d6bfa14e493b029756c5fc92 100644
--- a/arch/mips/config.mk
+++ b/arch/mips/config.mk
@@ -61,9 +61,13 @@ PLATFORM_CPPFLAGS += -DCONFIG_MIPS -D__MIPS__
 # On the other hand, we want PIC in the U-Boot code to relocate it from ROM
 # to RAM. $28 is always used as gp.
 #
-PLATFORM_CPPFLAGS		+= -G 0 -mabicalls -fpic $(ENDIANNESS)
+PF_ABICALLS			?= -mabicalls
+PF_PIC				?= -fpic
+PF_PIE				?= -pie
+
+PLATFORM_CPPFLAGS		+= -G 0 $(PF_ABICALLS) $(PF_PIC) $(ENDIANNESS)
 PLATFORM_CPPFLAGS		+= -msoft-float
 PLATFORM_LDFLAGS		+= -G 0 -static -n -nostdlib $(ENDIANNESS)
 PLATFORM_RELFLAGS		+= -ffunction-sections -fdata-sections
-LDFLAGS_FINAL			+= --gc-sections -pie
+LDFLAGS_FINAL			+= --gc-sections $(PF_PIE)
 OBJCFLAGS			+= --remove-section=.dynsym
diff --git a/arch/mips/cpu/mips32/cache.S b/arch/mips/cpu/mips32/cache.S
index 64dfad026324fc573d0b4a17965792826acec3e6..16ade802cc61cf1d8659efa69ddd490bcc20f725 100644
--- a/arch/mips/cpu/mips32/cache.S
+++ b/arch/mips/cpu/mips32/cache.S
@@ -45,7 +45,11 @@
  */
 #define MIPS_MAX_CACHE_SIZE	0x10000
 
+#ifdef CONFIG_SYS_MIPS_CACHE_EXT_INIT
+#define INDEX_BASE	0x9fc00000
+#else
 #define INDEX_BASE	CKSEG0
+#endif
 
 	.macro	cache_op op addr
 	.set	push
@@ -81,7 +85,11 @@
  */
 LEAF(mips_init_icache)
 	blez		a1, 9f
+#ifdef CONFIG_SYS_MIPS_CACHE_EXT_INIT
+	mtc0		zero, CP0_ITAGLO
+#else
 	mtc0		zero, CP0_TAGLO
+#endif
 	/* clear tag to invalidate */
 	PTR_LI		t0, INDEX_BASE
 	PTR_ADDU	t1, t0, a1
@@ -106,7 +114,11 @@ LEAF(mips_init_icache)
  */
 LEAF(mips_init_dcache)
 	blez		a1, 9f
+#ifdef CONFIG_SYS_MIPS_CACHE_EXT_INIT
+	mtc0		zero, CP0_DTAGLO
+#else
 	mtc0		zero, CP0_TAGLO
+#endif
 	/* clear all tags */
 	PTR_LI		t0, INDEX_BASE
 	PTR_ADDU	t1, t0, a1
diff --git a/arch/mips/cpu/mips32/danube/Makefile b/arch/mips/cpu/mips32/danube/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..f66094580f6b481dc31ff59f10c5b6072611d0d2
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/Makefile
@@ -0,0 +1,33 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y	+= cgu.o chipid.o ebu.o mem.o pmu.o rcu.o
+SOBJS-y	+= cgu_init.o mem_init.o
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/danube/cgu.c b/arch/mips/cpu/mips32/danube/cgu.c
new file mode 100644
index 0000000000000000000000000000000000000000..6e7b46dd42e3bb99580609dcb4fe720e68954974
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/cgu.c
@@ -0,0 +1,118 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CGU_SYS_DDR_MASK		0x0003
+#define LTQ_CGU_SYS_DDR_SHIFT		0
+#define LTQ_CGU_SYS_CPU0_MASK		0x000C
+#define LTQ_CGU_SYS_CPU0_SHIFT		2
+#define LTQ_CGU_SYS_FPI_MASK		0x0040
+#define LTQ_CGU_SYS_FPI_SHIFT		6
+
+struct ltq_cgu_regs {
+	u32	rsvd0;
+	u32	pll0_cfg;	/* PLL0 config */
+	u32	pll1_cfg;	/* PLL1 config */
+	u32	pll2_cfg;	/* PLL2 config */
+	u32	sys;		/* System clock */
+	u32	update;		/* CGU update control */
+	u32	if_clk;		/* Interface clock */
+	u32	osc_con;	/* Update OSC Control */
+	u32	smd;		/* SDRAM Memory Control */
+	u32	rsvd1[3];
+	u32	pcm_cr;		/* PCM control */
+	u32	pci_cr;		/* PCI clock control */
+};
+
+static struct ltq_cgu_regs *ltq_cgu_regs =
+	(struct ltq_cgu_regs *) CKSEG1ADDR(LTQ_CGU_BASE);
+
+static inline u32 ltq_cgu_sys_readl(u32 mask, u32 shift)
+{
+	return (ltq_readl(&ltq_cgu_regs->sys) & mask) >> shift;
+}
+
+unsigned long ltq_get_io_region_clock(void)
+{
+	u32 ddr_sel;
+	unsigned long clk;
+
+	ddr_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_DDR_MASK,
+					LTQ_CGU_SYS_DDR_SHIFT);
+
+	switch (ddr_sel) {
+	case 0:
+		clk = CLOCK_166_MHZ;
+		break;
+	case 1:
+		clk = CLOCK_133_MHZ;
+		break;
+	case 2:
+		clk = CLOCK_111_MHZ;
+		break;
+	case 3:
+		clk = CLOCK_83_MHZ;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_cpu_clock(void)
+{
+	u32 cpu0_sel;
+	unsigned long clk;
+
+	cpu0_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_CPU0_MASK,
+					LTQ_CGU_SYS_CPU0_SHIFT);
+
+	switch (cpu0_sel) {
+		/* Same as PLL0 output (333,33 MHz) */
+	case 0:
+		clk = CLOCK_333_MHZ;
+		break;
+		/* 1/1 fixed ratio to DDR clock */
+	case 1:
+		clk = ltq_get_io_region_clock();
+		break;
+		/* 1/2 fixed ratio to DDR clock */
+	case 2:
+		clk = ltq_get_io_region_clock() << 1;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_bus_clock(void)
+{
+	u32 fpi_sel;
+	unsigned long clk;
+
+	fpi_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_FPI_MASK,
+					LTQ_CGU_SYS_FPI_SHIFT);
+
+	if (fpi_sel)
+		/* Half the DDR clock */
+		clk = ltq_get_io_region_clock() >> 1;
+	else
+		/* Same as DDR clock */
+		clk = ltq_get_io_region_clock();
+
+	return clk;
+}
diff --git a/arch/mips/cpu/mips32/danube/cgu_init.S b/arch/mips/cpu/mips32/danube/cgu_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..be24989a12005de89076dd7106c6a5dab6e480ec
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/cgu_init.S
@@ -0,0 +1,143 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* RCU module register */
+#define LTQ_RCU_RST_REQ			0x0010
+#define LTQ_RCU_RST_STAT		0x0014
+#define LTQ_RCU_RST_REQ_VALUE		0x40000008
+#define LTQ_RCU_RST_STAT_XTAL_F	0x20000
+
+/* CGU module register */
+#define LTQ_CGU_PLL0_CFG		0x0004	/* PLL0 config */
+#define LTQ_CGU_PLL1_CFG		0x0008	/* PLL1 config */
+#define LTQ_CGU_PLL2_CFG		0x000C	/* PLL2 config */
+#define LTQ_CGU_SYS			0x0010	/* System clock */
+
+/* Valid SYS.CPU0/1 values */
+#define LTQ_CGU_SYS_CPU0_SHIFT		2
+#define LTQ_CGU_SYS_CPU1_SHIFT		4
+#define LTQ_CGU_SYS_CPU_PLL0		0x0
+#define LTQ_CGU_SYS_CPU_DDR_EQUAL	0x1
+#define LTQ_CGU_SYS_CPU_DDR_TWICE	0x2
+
+/* Valid SYS.DDR values */
+#define LTQ_CGU_SYS_DDR_SHIFT		0
+#define LTQ_CGU_SYS_DDR_167_MHZ	0x0
+#define LTQ_CGU_SYS_DDR_133_MHZ	0x1
+#define LTQ_CGU_SYS_DDR_111_MHZ	0x2
+#define LTQ_CGU_SYS_DDR_83_MHZ		0x3
+
+/* Valid SYS.FPI values */
+#define LTQ_CGU_SYS_FPI_SHIFT		6
+#define LTQ_CGU_SYS_FPI_DDR_EQUAL	0x0
+#define LTQ_CGU_SYS_FPI_DDR_HALF	0x1
+
+/* Valid SYS.PPE values */
+#define LTQ_CGU_SYS_PPE_SHIFT		7
+#define LTQ_CGU_SYS_PPE_266_MHZ	0x0
+#define LTQ_CGU_SYS_PPE_240_MHZ	0x1
+#define LTQ_CGU_SYS_PPE_222_MHZ	0x2
+#define LTQ_CGU_SYS_PPE_133_MHZ	0x3
+
+#if (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_333_DDR_167)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_DDR_TWICE
+#define LTQ_CGU_SYS_DDR_CONFIG		LTQ_CGU_SYS_DDR_167_MHZ
+#define LTQ_CGU_SYS_FPI_CONFIG		LTQ_CGU_SYS_FPI_DDR_HALF
+#define LTQ_CGU_SYS_PPE_CONFIG		LTQ_CGU_SYS_PPE_266_MHZ
+#elif (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_111_DDR_111)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_DDR_EQUAL
+#define LTQ_CGU_SYS_DDR_CONFIG		LTQ_CGU_SYS_DDR_111_MHZ
+#define LTQ_CGU_SYS_FPI_CONFIG		LTQ_CGU_SYS_FPI_DDR_HALF
+#define LTQ_CGU_SYS_PPE_CONFIG		LTQ_CGU_SYS_PPE_133_MHZ
+#else
+#error "Invalid system clock configuration!"
+#endif
+
+/* Build register values */
+#define LTQ_CGU_SYS_VALUE	((LTQ_CGU_SYS_PPE_CONFIG << \
+					LTQ_CGU_SYS_PPE_SHIFT) | \
+				(LTQ_CGU_SYS_FPI_CONFIG << \
+					LTQ_CGU_SYS_FPI_SHIFT) | \
+				(LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU1_SHIFT) | \
+				(LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU0_SHIFT) | \
+				LTQ_CGU_SYS_DDR_CONFIG)
+
+/* Reset values for PLL registers for usage with 35.328 MHz crystal */
+#define PLL0_35MHZ_CONFIG	0x9D861059
+#define PLL1_35MHZ_CONFIG	0x1A260CD9
+#define PLL2_35MHZ_CONFIG	0x8000f1e5
+
+/* Reset values for PLL registers for usage with 36 MHz crystal */
+#define PLL0_36MHZ_CONFIG	0x1000125D
+#define PLL1_36MHZ_CONFIG	0x1B1E0C99
+#define PLL2_36MHZ_CONFIG	0x8002f2a1
+
+LEAF(ltq_cgu_init)
+	/* Load current CGU register value */
+	li	t0, (LTQ_CGU_BASE | KSEG1)
+	lw	t1, LTQ_CGU_SYS(t0)
+
+	/* Load target CGU register values */
+	li	t3, LTQ_CGU_SYS_VALUE
+
+	/* Only update registers if values differ */
+	beq	t1, t3, finished
+
+	/*
+	 * Check whether the XTAL_F bit in RST_STAT register is set or not.
+	 * This bit is latched in via pin strapping. If bit is set then
+	 * clock source is a 36 MHz crystal. Otherwise a 35.328 MHz crystal.
+	 */
+	 li	t1, (LTQ_RCU_BASE | KSEG1)
+	 lw	t2, LTQ_RCU_RST_STAT(t1)
+	 and	t2, t2, LTQ_RCU_RST_STAT_XTAL_F
+	 beq	t2, LTQ_RCU_RST_STAT_XTAL_F, boot_36mhz
+
+boot_35mhz:
+	/* Configure PLL for 35.328 MHz */
+	li	t2, PLL0_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL0_CFG(t0)
+	li	t2, PLL1_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL1_CFG(t0)
+	li	t2, PLL2_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL2_CFG(t0)
+
+	b	do_reset
+
+boot_36mhz:
+	/* Configure PLL for 36 MHz */
+	li	t2, PLL0_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL0_CFG(t0)
+	li	t2, PLL1_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL1_CFG(t0)
+	li	t2, PLL2_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL2_CFG(t0)
+
+do_reset:
+	/* Store new clock config */
+	sw	t3, LTQ_CGU_SYS(t0)
+
+	/* Perform software reset to activate new clock config */
+	li	t2, LTQ_RCU_RST_REQ_VALUE
+	sw	t2, LTQ_RCU_RST_REQ(t1)
+
+wait_reset:
+	b	wait_reset
+
+finished:
+	jr	ra
+
+	END(ltq_cgu_init)
diff --git a/arch/mips/cpu/mips32/danube/chipid.c b/arch/mips/cpu/mips32/danube/chipid.c
new file mode 100644
index 0000000000000000000000000000000000000000..ae2d95dd95022d418a1f886b8fa4f8073c811e59
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/chipid.c
@@ -0,0 +1,60 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_CHIPID_VERSION_SHIFT	28
+#define LTQ_CHIPID_VERSION_MASK		(0xF << LTQ_CHIPID_VERSION_SHIFT)
+#define LTQ_CHIPID_PNUM_SHIFT		12
+#define LTQ_CHIPID_PNUM_MASK		(0xFFFF << LTQ_CHIPID_PNUM_SHIFT)
+
+struct ltq_chipid_regs {
+	u32	manid;		/* Manufacturer identification */
+	u32	chipid;		/* Chip identification */
+};
+
+static struct ltq_chipid_regs *ltq_chipid_regs =
+	(struct ltq_chipid_regs *) CKSEG1ADDR(LTQ_CHIPID_BASE);
+
+unsigned int ltq_chip_version_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_VERSION_MASK) >> LTQ_CHIPID_VERSION_SHIFT;
+}
+
+unsigned int ltq_chip_partnum_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_PNUM_MASK) >> LTQ_CHIPID_PNUM_SHIFT;
+}
+
+const char *ltq_chip_partnum_str(void)
+{
+	enum ltq_chip_partnum partnum = ltq_chip_partnum_get();
+
+	switch (partnum) {
+	case LTQ_SOC_DANUBE:
+		return "Danube";
+	case LTQ_SOC_DANUBE_S:
+		return "Danube-S";
+	case LTQ_SOC_TWINPASS:
+		return "Twinpass";
+	default:
+		printf("Unknown partnum: %x\n", partnum);
+	}
+
+	return "";
+}
diff --git a/arch/mips/cpu/mips32/danube/config.mk b/arch/mips/cpu/mips32/danube/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..bbde3098c037390450a9a0a68735b50499224705
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/config.mk
@@ -0,0 +1,26 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PF_CPPFLAGS_DANUBE := $(call cc-option,-mtune=24kec,)
+PLATFORM_CPPFLAGS += $(PF_CPPFLAGS_DANUBE)
+
+ifdef CONFIG_SPL_BUILD
+PF_ABICALLS		:= -mno-abicalls
+PF_PIC			:= -fno-pic
+PF_PIE			:=
+USE_PRIVATE_LIBGCC	:= yes
+endif
+
+LIBS-y += $(CPUDIR)/lantiq-common/liblantiq-common.o
+
+ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_SYS_BOOT_NORSPL
+ALL-y += $(obj)u-boot.ltq.norspl
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += $(obj)u-boot.ltq.lzo.norspl
+ALL-$(CONFIG_SPL_LZMA_SUPPORT) += $(obj)u-boot.ltq.lzma.norspl
+endif
+endif
diff --git a/arch/mips/cpu/mips32/danube/ebu.c b/arch/mips/cpu/mips32/danube/ebu.c
new file mode 100644
index 0000000000000000000000000000000000000000..cbebeff408e229e8493a78dbc0a2a5a15b5f6738
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/ebu.c
@@ -0,0 +1,106 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define EBU_ADDRSEL_MASK(mask)		((mask & 0xf) << 4)
+#define EBU_ADDRSEL_REGEN		(1 << 0)
+
+#define EBU_CON_WRDIS			(1 << 31)
+#define EBU_CON_AGEN_DEMUX		(0x0 << 24)
+#define EBU_CON_AGEN_MUX		(0x2 << 24)
+#define EBU_CON_SETUP			(1 << 22)
+#define EBU_CON_WAIT_DIS		(0x0 << 20)
+#define EBU_CON_WAIT_ASYNC		(0x1 << 20)
+#define EBU_CON_WAIT_SYNC		(0x2 << 20)
+#define EBU_CON_WINV			(1 << 19)
+#define EBU_CON_PW_8BIT			(0x0 << 16)
+#define EBU_CON_PW_16BIT		(0x1 << 16)
+#define EBU_CON_ALEC(cycles)		((cycles & 0x3) << 14)
+#define EBU_CON_BCGEN_CS		(0x0 << 12)
+#define EBU_CON_BCGEN_INTEL		(0x1 << 12)
+#define EBU_CON_BCGEN_MOTOROLA		(0x2 << 12)
+#define EBU_CON_WAITWRC(cycles)		((cycles & 0x7) << 8)
+#define EBU_CON_WAITRDC(cycles)		((cycles & 0x3) << 6)
+#define EBU_CON_HOLDC(cycles)		((cycles & 0x3) << 4)
+#define EBU_CON_RECOVC(cycles)		((cycles & 0x3) << 2)
+#define EBU_CON_CMULT_1			0x0
+#define EBU_CON_CMULT_4			0x1
+#define EBU_CON_CMULT_8			0x2
+#define EBU_CON_CMULT_16		0x3
+
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define ebu_region0_enable		1
+#else
+#define ebu_region0_enable		0
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#define ebu_region1_enable		1
+#else
+#define ebu_region1_enable		0
+#endif
+
+struct ltq_ebu_regs {
+	u32	clc;
+	u32	rsvd0[3];
+	u32	con;
+	u32	rsvd1[3];
+	u32	addr_sel_0;
+	u32	addr_sel_1;
+	u32	rsvd2[14];
+	u32	con_0;
+	u32	con_1;
+};
+
+static struct ltq_ebu_regs *ltq_ebu_regs =
+	(struct ltq_ebu_regs *) CKSEG1ADDR(LTQ_EBU_BASE);
+
+void ltq_ebu_init(void)
+{
+	if (ebu_region0_enable) {
+		/*
+		 * Map EBU region 0 to range 0x10000000-0x13ffffff and enable
+		 * region control. This supports up to 32 MiB NOR flash in
+		 * bank 0.
+		 */
+		ltq_writel(&ltq_ebu_regs->addr_sel_0, LTQ_EBU_REGION0_BASE |
+			EBU_ADDRSEL_MASK(1) | EBU_ADDRSEL_REGEN);
+
+		ltq_writel(&ltq_ebu_regs->con_0, EBU_CON_AGEN_DEMUX |
+			EBU_CON_WAIT_DIS | EBU_CON_PW_16BIT |
+			EBU_CON_ALEC(3) | EBU_CON_BCGEN_INTEL |
+			EBU_CON_WAITWRC(7) | EBU_CON_WAITRDC(3) |
+			EBU_CON_HOLDC(3) | EBU_CON_RECOVC(3) |
+			EBU_CON_CMULT_16);
+	} else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_0, EBU_ADDRSEL_REGEN);
+
+	if (ebu_region1_enable) {
+		/*
+		 * Map EBU region 1 to range 0x14000000-0x13ffffff and enable
+		 * region control. This supports NAND flash in bank 1.
+		 */
+		ltq_writel(&ltq_ebu_regs->addr_sel_1, LTQ_EBU_REGION1_BASE |
+			EBU_ADDRSEL_MASK(3) | EBU_ADDRSEL_REGEN);
+
+		ltq_writel(&ltq_ebu_regs->con_1, EBU_CON_AGEN_DEMUX |
+			EBU_CON_SETUP | EBU_CON_WAIT_DIS | EBU_CON_PW_8BIT |
+			EBU_CON_ALEC(3) | EBU_CON_BCGEN_INTEL |
+			EBU_CON_WAITWRC(2) | EBU_CON_WAITRDC(2) |
+			EBU_CON_HOLDC(1) | EBU_CON_RECOVC(1) |
+			EBU_CON_CMULT_4);
+	} else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_1, EBU_ADDRSEL_REGEN);
+}
+
+void *flash_swap_addr(unsigned long addr)
+{
+	return (void *)(addr ^ 2);
+}
diff --git a/arch/mips/cpu/mips32/danube/mem.c b/arch/mips/cpu/mips32/danube/mem.c
new file mode 100644
index 0000000000000000000000000000000000000000..34ff4836d38f3b4e9aeb37647554050a7d930e6d
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/mem.c
@@ -0,0 +1,31 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+static void *ltq_mc_ddr_base = (void *) CKSEG1ADDR(LTQ_MC_DDR_BASE);
+
+static inline u32 ltq_mc_dc_read(u32 index)
+{
+	return ltq_readl(ltq_mc_ddr_base + LTQ_MC_DDR_DC_OFFSET(index));
+}
+
+phys_size_t initdram(int board_type)
+{
+	u32 col, row, dc04, dc19, dc20;
+
+	dc04 = ltq_mc_dc_read(4);
+	dc19 = ltq_mc_dc_read(19);
+	dc20 = ltq_mc_dc_read(20);
+
+	row = (dc04 & 0xF) - ((dc19 & 0x700) >> 8);
+	col = ((dc04 & 0xF00) >> 8) - (dc20 & 0x7);
+
+	return (1 << (row + col)) * 4 * 2;
+}
diff --git a/arch/mips/cpu/mips32/danube/mem_init.S b/arch/mips/cpu/mips32/danube/mem_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..2296c9826f7e5d24fb5eb8b8c771ffe7e3fa798c
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/mem_init.S
@@ -0,0 +1,115 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* Must be configured in BOARDDIR */
+#include <ddr_settings.h>
+
+#define LTQ_MC_GEN_ERRCAUSE		0x0010
+#define LTQ_MC_GEN_ERRADDR		0x0020
+#define LTQ_MC_GEN_CON			0x0060
+#define LTQ_MC_GEN_STAT			0x0070
+#define LTQ_MC_GEN_CON_SRAM_DDR_ENABLE	0x5
+#define LTQ_MC_GEN_STAT_DLCK_PWRON	0xC
+
+#define LTQ_MC_DDR_DC03_MC_START	0x100
+
+	/* Store given value in MC DDR CCRx register */
+	.macro dc_sw num, val
+	li	t2, \val
+	sw	t2, LTQ_MC_DDR_DC_OFFSET(\num)(t1)
+	.endm
+
+LEAF(ltq_mem_init)
+	/* Load MC General and MC DDR module base */
+	li	t0, (LTQ_MC_GEN_BASE | KSEG1)
+	li	t1, (LTQ_MC_DDR_BASE | KSEG1)
+
+	/* Clear access error log registers */
+	sw	zero, LTQ_MC_GEN_ERRCAUSE(t0)
+	sw	zero, LTQ_MC_GEN_ERRADDR(t0)
+
+	/* Enable DDR and SRAM module in memory controller */
+	li	t2, LTQ_MC_GEN_CON_SRAM_DDR_ENABLE
+	sw	t2, LTQ_MC_GEN_CON(t0)
+
+	/* Clear start bit of DDR memory controller */
+	sw	zero, LTQ_MC_DDR_DC_OFFSET(3)(t1)
+
+	/* Init memory controller registers with values ddr_settings.h */
+	dc_sw	0, MC_DC00_VALUE
+	dc_sw	1, MC_DC01_VALUE
+	dc_sw	2, MC_DC02_VALUE
+	dc_sw	4, MC_DC04_VALUE
+	dc_sw	5, MC_DC05_VALUE
+	dc_sw	6, MC_DC06_VALUE
+	dc_sw	7, MC_DC07_VALUE
+	dc_sw	8, MC_DC08_VALUE
+	dc_sw	9, MC_DC09_VALUE
+
+	dc_sw	10, MC_DC10_VALUE
+	dc_sw	11, MC_DC11_VALUE
+	dc_sw	12, MC_DC12_VALUE
+	dc_sw	13, MC_DC13_VALUE
+	dc_sw	14, MC_DC14_VALUE
+	dc_sw	15, MC_DC15_VALUE
+	dc_sw	16, MC_DC16_VALUE
+	dc_sw	17, MC_DC17_VALUE
+	dc_sw	18, MC_DC18_VALUE
+	dc_sw	19, MC_DC19_VALUE
+
+	dc_sw	20, MC_DC20_VALUE
+	dc_sw	21, MC_DC21_VALUE
+	dc_sw	22, MC_DC22_VALUE
+	dc_sw	23, MC_DC23_VALUE
+	dc_sw	24, MC_DC24_VALUE
+	dc_sw	25, MC_DC25_VALUE
+	dc_sw	26, MC_DC26_VALUE
+	dc_sw	27, MC_DC27_VALUE
+	dc_sw	28, MC_DC28_VALUE
+	dc_sw	29, MC_DC29_VALUE
+
+	dc_sw	30, MC_DC30_VALUE
+	dc_sw	31, MC_DC31_VALUE
+	dc_sw	32, MC_DC32_VALUE
+	dc_sw	33, MC_DC33_VALUE
+	dc_sw	34, MC_DC34_VALUE
+	dc_sw	35, MC_DC35_VALUE
+	dc_sw	36, MC_DC36_VALUE
+	dc_sw	37, MC_DC37_VALUE
+	dc_sw	38, MC_DC38_VALUE
+	dc_sw	39, MC_DC39_VALUE
+
+	dc_sw	40, MC_DC40_VALUE
+	dc_sw	41, MC_DC41_VALUE
+	dc_sw	42, MC_DC42_VALUE
+	dc_sw	43, MC_DC43_VALUE
+	dc_sw	44, MC_DC44_VALUE
+	dc_sw	45, MC_DC45_VALUE
+	dc_sw	46, MC_DC46_VALUE
+
+	/* Set start bit of DDR memory controller */
+	li	t2, LTQ_MC_DDR_DC03_MC_START
+	sw	t2, LTQ_MC_DDR_DC_OFFSET(3)(t1)
+
+	/* Wait until DLL has locked and core is ready for data transfers */
+wait_ready:
+	lw	t2, LTQ_MC_GEN_STAT(t0)
+	li	t3, LTQ_MC_GEN_STAT_DLCK_PWRON
+	and	t2, t3
+	bne	t2, t3, wait_ready
+
+finished:
+	jr	ra
+
+	END(ltq_mem_init)
diff --git a/arch/mips/cpu/mips32/danube/pmu.c b/arch/mips/cpu/mips32/danube/pmu.c
new file mode 100644
index 0000000000000000000000000000000000000000..21f27e59fb5e0bc2fe11ef4d6af7e693bf8d4bfe
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/pmu.c
@@ -0,0 +1,118 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PMU_PWDCR_RESERVED		0xFD0C001C
+
+#define LTQ_PMU_PWDCR_TDM		(1 << 25)
+#define LTQ_PMU_PWDCR_PPE_ENET0		(1 << 23)
+#define LTQ_PMU_PWDCR_PPE_ENET1		(1 << 22)
+#define LTQ_PMU_PWDCR_PPE_TC		(1 << 21)
+#define LTQ_PMU_PWDCR_DEU		(1 << 20)
+#define LTQ_PMU_PWDCR_UART1		(1 << 17)
+#define LTQ_PMU_PWDCR_SDIO		(1 << 16)
+#define LTQ_PMU_PWDCR_AHB		(1 << 15)
+#define LTQ_PMU_PWDCR_FPI0		(1 << 14)
+#define LTQ_PMU_PWDCR_PPE		(1 << 13)
+#define LTQ_PMU_PWDCR_GPTC		(1 << 12)
+#define LTQ_PMU_PWDCR_LEDC		(1 << 11)
+#define LTQ_PMU_PWDCR_EBU		(1 << 10)
+#define LTQ_PMU_PWDCR_DSL		(1 << 9)
+#define LTQ_PMU_PWDCR_SPI		(1 << 8)
+#define LTQ_PMU_PWDCR_UART0		(1 << 7)
+#define LTQ_PMU_PWDCR_USB		(1 << 6)
+#define LTQ_PMU_PWDCR_DMA		(1 << 5)
+#define LTQ_PMU_PWDCR_FPI1		(1 << 1)
+#define LTQ_PMU_PWDCR_USB_PHY		(1 << 0)
+
+struct ltq_pmu_regs {
+	u32	rsvd0[7];
+	u32	pwdcr;
+	u32	sr;
+	u32	pwdcr1;
+	u32	sr1;
+};
+
+static struct ltq_pmu_regs *ltq_pmu_regs =
+	(struct ltq_pmu_regs *) CKSEG1ADDR(LTQ_PMU_BASE);
+
+u32 ltq_pm_map(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_PM_CORE:
+		val = LTQ_PMU_PWDCR_UART1 | LTQ_PMU_PWDCR_FPI0 |
+			LTQ_PMU_PWDCR_LEDC | LTQ_PMU_PWDCR_EBU;
+		break;
+	case LTQ_PM_DMA:
+		val = LTQ_PMU_PWDCR_DMA;
+		break;
+	case LTQ_PM_ETH:
+		val = LTQ_PMU_PWDCR_PPE_ENET0 | LTQ_PMU_PWDCR_PPE_TC |
+			LTQ_PMU_PWDCR_PPE;
+		break;
+	case LTQ_PM_SPI:
+		val = LTQ_PMU_PWDCR_SPI;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_pm_enable(enum ltq_pm_modules module)
+{
+	const unsigned long timeout = 1000;
+	unsigned long timebase;
+	u32 sr, val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_pmu_regs->pwdcr, val);
+
+	timebase = get_timer(0);
+
+	do {
+		sr = ltq_readl(&ltq_pmu_regs->sr);
+		if (~sr & val)
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int ltq_pm_disable(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_pmu_regs->pwdcr, val);
+
+	return 0;
+}
+
+void ltq_pmu_init(void)
+{
+	u32 set, clr;
+
+	clr = ltq_pm_map(LTQ_PM_CORE);
+	set = ~(LTQ_PMU_PWDCR_RESERVED | clr);
+
+	ltq_clrsetbits(&ltq_pmu_regs->pwdcr, clr, set);
+}
diff --git a/arch/mips/cpu/mips32/danube/rcu.c b/arch/mips/cpu/mips32/danube/rcu.c
new file mode 100644
index 0000000000000000000000000000000000000000..10d3a06a984af1eef4a67dd02a2b72c116b9bf8e
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/rcu.c
@@ -0,0 +1,126 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_RCU_RD_SRST		(1 << 30)	/* Global SW Reset */
+#define LTQ_RCU_RD_MC		(1 << 14)	/* Memory Controller */
+#define LTQ_RCU_RD_PCI		(1 << 13)	/* PCI core */
+#define LTQ_RCU_RD_DFE_AFE	(1 << 12)	/* Voice DFE/AFE */
+#define LTQ_RCU_RD_DSL_AFE	(1 << 11)	/* DSL AFE */
+#define LTQ_RCU_RD_SDIO		(1 << 10)	/* SDIO core */
+#define LTQ_RCU_RD_DMA		(1 << 9)	/* DMA core */
+#define LTQ_RCU_RD_PPE		(1 << 8)	/* PPE core */
+#define LTQ_RCU_RD_ARC_DFE	(1 << 7)	/* ARC/DFE core */
+#define LTQ_RCU_RD_AHB		(1 << 6)	/* AHB bus */
+#define LTQ_RCU_RD_ENET_MAC1	(1 << 5)	/* Ethernet MAC1 */
+#define LTQ_RCU_RD_USB		(1 << 4)	/* USB and Phy core */
+#define LTQ_RCU_RD_CPU1		(1 << 3)	/* CPU1 subsystem */
+#define LTQ_RCU_RD_FPI		(1 << 2)	/* FPI bus */
+#define LTQ_RCU_RD_CPU0		(1 << 1)	/* CPU0 subsystem */
+#define LTQ_RCU_RD_HRST		(1 << 0)	/* HW reset via HRST pin */
+
+#define LTQ_RCU_STAT_BOOT_SHIFT		18
+#define LTQ_RCU_STAT_BOOT_MASK		(0x7 << LTQ_RCU_STAT_BOOT_SHIFT)
+
+struct ltq_rcu_regs {
+	u32	rsvd0[4];
+	u32	req;		/* Reset request */
+	u32	stat;		/* Reset status */
+	u32	usb_cfg;	/* USB configure */
+	u32	rsvd1[2];
+	u32	pci_rdy;	/* PCI boot ready */
+};
+
+static struct ltq_rcu_regs *ltq_rcu_regs =
+	(struct ltq_rcu_regs *) CKSEG1ADDR(LTQ_RCU_BASE);
+
+u32 ltq_reset_map(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_RESET_CORE:
+	case LTQ_RESET_SOFT:
+		val = LTQ_RCU_RD_SRST | LTQ_RCU_RD_CPU1;
+		break;
+	case LTQ_RESET_DMA:
+		val = LTQ_RCU_RD_DMA;
+		break;
+	case LTQ_RESET_ETH:
+		val = LTQ_RCU_RD_PPE;
+		break;
+	case LTQ_RESET_HARD:
+		val = LTQ_RCU_RD_HRST;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_reset_activate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+int ltq_reset_deactivate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+enum ltq_boot_select ltq_boot_select(void)
+{
+	u32 stat;
+	unsigned int bootstrap;
+
+	stat = ltq_readl(&ltq_rcu_regs->stat);
+	bootstrap = (stat & LTQ_RCU_STAT_BOOT_MASK) >> LTQ_RCU_STAT_BOOT_SHIFT;
+
+	switch (bootstrap) {
+	case 0:
+		return BOOT_NOR_NO_BOOTROM;
+	case 1:
+		return BOOT_NOR;
+	case 2:
+		return BOOT_MII0;
+	case 3:
+		return BOOT_PCI;
+	case 4:
+		return BOOT_UART;
+	case 5:
+		return BOOT_SPI;
+	case 6:
+		return BOOT_NAND;
+	case 7:
+		return BOOT_RMII0;
+	default:
+		return BOOT_UNKNOWN;
+	}
+}
diff --git a/arch/mips/cpu/mips32/lantiq-common/Makefile b/arch/mips/cpu/mips32/lantiq-common/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..7514a27ddff50fe05710f9f8263cd403c0969f0f
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/Makefile
@@ -0,0 +1,36 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)liblantiq-common.o
+
+START	= start.o
+COBJS-y	= cpu.o pmu.o
+COBJS-$(CONFIG_SPL_BUILD) += spl.o
+SOBJS-y	= lowlevel_init.o
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/lantiq-common/cpu.c b/arch/mips/cpu/mips32/lantiq-common/cpu.c
new file mode 100644
index 0000000000000000000000000000000000000000..f5ba6619c816745828678d3474061605e0777563
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/cpu.c
@@ -0,0 +1,60 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/cpu.h>
+
+static const char ltq_bootsel_strings[][16] = {
+	"NOR",
+	"NOR w/o BootROM",
+	"UART",
+	"UART w/o EEPROM",
+	"SPI",
+	"NAND",
+	"PCI",
+	"MII0",
+	"RMII0",
+	"RGMII1",
+	"unknown",
+};
+
+const char *ltq_boot_select_str(void)
+{	enum ltq_boot_select bootsel = ltq_boot_select();
+
+	if (bootsel > BOOT_UNKNOWN)
+		bootsel = BOOT_UNKNOWN;
+
+	return ltq_bootsel_strings[bootsel];
+}
+
+void ltq_chip_print_info(void)
+{
+	char buf[32];
+
+	printf("SoC:   Lantiq %s v1.%u\n", ltq_chip_partnum_str(),
+		ltq_chip_version_get());
+	printf("CPU:   %s MHz\n", strmhz(buf, ltq_get_cpu_clock()));
+	printf("IO:    %s MHz\n", strmhz(buf, ltq_get_io_region_clock()));
+	printf("BUS:   %s MHz\n", strmhz(buf, ltq_get_bus_clock()));
+	printf("BOOT:  %s\n", ltq_boot_select_str());
+}
+
+int arch_cpu_init(void)
+{
+	ltq_pmu_init();
+	ltq_ebu_init();
+
+	return 0;
+}
+
+void _machine_restart(void)
+{
+	ltq_reset_activate(LTQ_RESET_CORE);
+}
diff --git a/arch/mips/cpu/mips32/lantiq-common/lowlevel_init.S b/arch/mips/cpu/mips32/lantiq-common/lowlevel_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..d57ba44ca2a7c7cb740aa475f9f6fb8c4dbcbb26
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/lowlevel_init.S
@@ -0,0 +1,21 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+NESTED(lowlevel_init, 0, ra)
+	move	t8, ra
+
+	la	t7, ltq_cgu_init
+	jalr	t7
+
+	la	t7, ltq_mem_init
+	jalr	t7
+
+	jr	t8
+	END(lowlevel_init)
diff --git a/arch/mips/cpu/mips32/lantiq-common/pmu.c b/arch/mips/cpu/mips32/lantiq-common/pmu.c
new file mode 100644
index 0000000000000000000000000000000000000000..bb8ac29cbc8758e8ef0309e9439dc7394156e8b0
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/pmu.c
@@ -0,0 +1,10 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/pm.h>
+
diff --git a/arch/mips/cpu/mips32/lantiq-common/spl.c b/arch/mips/cpu/mips32/lantiq-common/spl.c
new file mode 100644
index 0000000000000000000000000000000000000000..05f66a9343d0fb7748e9ca0333ce9466e1569c98
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/spl.c
@@ -0,0 +1,405 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <image.h>
+#include <version.h>
+#include <spi_flash.h>
+#include <linux/compiler.h>
+#include <lzma/LzmaDec.h>
+#include <linux/lzo.h>
+#include <asm/mipsregs.h>
+
+#if defined(CONFIG_LTQ_SPL_CONSOLE)
+#define spl_has_console		1
+
+#if defined(CONFIG_LTQ_SPL_DEBUG)
+#define spl_has_debug		1
+#else
+#define spl_has_debug		0
+#endif
+
+#else
+#define spl_has_console		0
+#define spl_has_debug		0
+#endif
+
+#define spl_debug(fmt, args...)			\
+	do {					\
+		if (spl_has_debug)		\
+			printf(fmt, ##args);	\
+	} while (0)
+
+#define spl_puts(msg)				\
+	do {					\
+		if (spl_has_console)		\
+			puts(msg);		\
+	} while (0)
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH) && defined(CONFIG_SYS_BOOT_SFSPL)
+#define spl_boot_spi_flash	1
+#else
+#define spl_boot_spi_flash	0
+#ifndef CONFIG_SPL_SPI_BUS
+#define CONFIG_SPL_SPI_BUS	0
+#endif
+#ifndef CONFIG_SPL_SPI_CS
+#define CONFIG_SPL_SPI_CS	0
+#endif
+#ifndef CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_SPL_SPI_MAX_HZ	0
+#endif
+#ifndef CONFIG_SPL_SPI_MODE
+#define CONFIG_SPL_SPI_MODE	0
+#endif
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_NOR_FLASH) && defined(CONFIG_SYS_BOOT_NORSPL)
+#define spl_boot_nor_flash	1
+#else
+#define spl_boot_nor_flash	0
+#endif
+
+#define spl_sync()	__asm__ __volatile__("sync");
+
+struct spl_image {
+	ulong data_addr;
+	ulong entry_addr;
+	ulong data_size;
+	ulong entry_size;
+	ulong data_crc;
+	u8 comp;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Emulated malloc area needed for LZMA allocator in BSS */
+static u8 *spl_mem_ptr __maybe_unused;
+static size_t spl_mem_size __maybe_unused;
+
+static int spl_is_comp_lzma(const struct spl_image *spl)
+{
+#if defined(CONFIG_LTQ_SPL_COMP_LZMA)
+	return spl->comp == IH_COMP_LZMA;
+#else
+	return 0;
+#endif
+}
+
+static int spl_is_comp_lzo(const struct spl_image *spl)
+{
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+	return spl->comp == IH_COMP_LZO;
+#else
+	return 0;
+#endif
+}
+
+static int spl_is_compressed(const struct spl_image *spl)
+{
+	if (spl_is_comp_lzma(spl))
+		return 1;
+
+	if (spl_is_comp_lzo(spl))
+		return 1;
+
+	return 0;
+}
+
+static void spl_console_init(void)
+{
+	if (!spl_has_console)
+		return;
+
+	gd->flags |= GD_FLG_RELOC;
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	serial_init();
+
+	gd->have_console = 1;
+
+	spl_puts("\nU-Boot SPL " PLAIN_VERSION " (" U_BOOT_DATE " - " \
+		U_BOOT_TIME ")\n");
+}
+
+static int spl_parse_image(const image_header_t *hdr, struct spl_image *spl)
+{
+	spl_puts("SPL: checking U-Boot image\n");
+
+	if (!image_check_magic(hdr)) {
+		spl_puts("SPL: invalid magic\n");
+		return -1;
+	}
+
+        if (!image_check_hcrc(hdr)) {
+		spl_puts("SPL: invalid header CRC\n");
+		return -1;
+	}
+
+	spl->data_addr += image_get_header_size();
+	spl->entry_addr = image_get_load(hdr);
+	spl->data_size = image_get_data_size(hdr);
+	spl->data_crc = image_get_dcrc(hdr);
+	spl->comp = image_get_comp(hdr);
+
+	spl_debug("SPL: data %08lx, size %lu, entry %08lx, comp %u\n",
+		spl->data_addr, spl->data_size, spl->entry_addr, spl->comp);
+
+	return 0;
+}
+
+static int spl_check_data(const struct spl_image *spl, ulong loadaddr)
+{
+	ulong dcrc = crc32(0, (unsigned char *)loadaddr, spl->data_size);
+
+	if (dcrc != spl->data_crc) {
+		spl_puts("SPL: invalid data CRC\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static void *spl_lzma_alloc(void *p, size_t size)
+{
+	u8 *ret;
+
+	if (size > spl_mem_size)
+		return NULL;
+
+	ret = spl_mem_ptr;
+	spl_mem_ptr += size;
+	spl_mem_size -= size;
+
+	return ret;
+}
+
+static void spl_lzma_free(void *p, void *addr)
+{
+}
+
+static int spl_copy_image(struct spl_image *spl)
+{
+	spl_puts("SPL: copying U-Boot to RAM\n");
+
+	memcpy((void *) spl->entry_addr, (const void *) spl->data_addr,
+		spl->data_size);
+
+	spl->entry_size = spl->data_size;
+
+	return 0;
+}
+
+static int spl_uncompress_lzma(struct spl_image *spl, unsigned long loadaddr)
+{
+	SRes res;
+	const Byte *prop = (const Byte *) loadaddr;
+	const Byte *src = (const Byte *) loadaddr + LZMA_PROPS_SIZE +
+							sizeof(uint64_t);
+	Byte *dest = (Byte *) spl->entry_addr;
+	SizeT dest_len = 0xFFFFFFFF;
+	SizeT src_len = spl->data_size - LZMA_PROPS_SIZE;
+	ELzmaStatus status = 0;
+	ISzAlloc alloc;
+
+	spl_puts("SPL: decompressing U-Boot with LZMA\n");
+
+	alloc.Alloc = spl_lzma_alloc;
+	alloc.Free = spl_lzma_free;
+	spl_mem_ptr = (u8 *) CONFIG_SPL_MALLOC_BASE;
+	spl_mem_size = CONFIG_SPL_MALLOC_MAX_SIZE;
+
+	res = LzmaDecode(dest, &dest_len, src, &src_len, prop, LZMA_PROPS_SIZE,
+		LZMA_FINISH_ANY, &status, &alloc);
+	if (res != SZ_OK)
+		return 1;
+
+	spl->entry_size = dest_len;
+
+	return 0;
+}
+
+static int spl_uncompress_lzo(struct spl_image *spl, unsigned long loadaddr)
+{
+	size_t len;
+	int ret;
+
+	spl_puts("SPL: decompressing U-Boot with LZO\n");
+
+	ret = lzop_decompress(
+		(const unsigned char*) loadaddr, spl->data_size,
+		(unsigned char *) spl->entry_addr, &len);
+
+	spl->entry_size = len;
+
+	return ret;
+}
+
+static int spl_uncompress(struct spl_image *spl, unsigned long loadaddr)
+{
+	int ret;
+
+	if (spl_is_comp_lzma(spl))
+		ret = spl_uncompress_lzma(spl, loadaddr);
+	else if (spl_is_comp_lzo(spl))
+		ret = spl_uncompress_lzo(spl, loadaddr);
+	else
+		ret = 1;
+
+	return ret;
+}
+
+static int spl_load_spi_flash(struct spl_image *spl)
+{
+	struct spi_flash sf = { 0 };
+	image_header_t hdr;
+	int ret;
+	unsigned long loadaddr;
+
+	/*
+	 * Image format:
+	 *
+	 * - 12 byte non-volatile bootstrap header
+	 * - SPL binary
+	 * - 12 byte non-volatile bootstrap header
+	 * - 64 byte U-Boot mkimage header
+	 * - U-Boot binary
+	 */
+	spl->data_addr = image_copy_end() - CONFIG_SPL_TEXT_BASE + 24;
+
+	spl_puts("SPL: probing SPI flash\n");
+
+	spi_init();
+	ret = spi_flash_probe_spl(&sf, CONFIG_SPL_SPI_BUS, CONFIG_SPL_SPI_CS,
+				CONFIG_SPL_SPI_MAX_HZ, CONFIG_SPL_SPI_MODE);
+	if (ret)
+		return ret;
+
+	spl_debug("SPL: reading image header at offset %lx\n", spl->data_addr);
+
+	ret = spi_flash_read(&sf, spl->data_addr, sizeof(hdr), &hdr);
+	if (ret)
+		return ret;
+
+	spl_debug("SPL: checking image header at offset %lx\n", spl->data_addr);
+
+	ret = spl_parse_image(&hdr, spl);
+	if (ret)
+		return ret;
+
+	if (spl_is_compressed(spl))
+		loadaddr = CONFIG_LOADADDR;
+	else
+		loadaddr = spl->entry_addr;
+
+	spl_puts("SPL: loading U-Boot to RAM\n");
+
+	ret = spi_flash_read(&sf, spl->data_addr, spl->data_size,
+				(void *) loadaddr);
+
+	if (!spl_check_data(spl, loadaddr))
+		return -1;
+
+	if (spl_is_compressed(spl))
+		ret = spl_uncompress(spl, loadaddr);
+
+	return ret;
+}
+
+static int spl_load_nor_flash(struct spl_image *spl)
+{
+	const image_header_t *hdr;
+	int ret;
+
+	/*
+	 * Image format:
+	 *
+	 * - SPL binary
+	 * - 64 byte U-Boot mkimage header
+	 * - U-Boot binary
+	 */
+	spl->data_addr = image_copy_end();
+	hdr = (const image_header_t *) image_copy_end();
+
+	spl_debug("SPL: checking image header at address %p\n", hdr);
+
+	ret = spl_parse_image(hdr, spl);
+	if (ret)
+		return ret;
+
+	if (spl_is_compressed(spl))
+		ret = spl_uncompress(spl, spl->data_addr);
+	else
+		ret = spl_copy_image(spl);
+
+	return ret;
+}
+
+static int spl_load(struct spl_image *spl)
+{
+	int ret;
+
+	if (spl_boot_spi_flash)
+		ret = spl_load_spi_flash(spl);
+	else if (spl_boot_nor_flash)
+		ret = spl_load_nor_flash(spl);
+	else
+		ret = 1;
+
+	return ret;
+}
+
+void __noreturn spl_lantiq_init(void)
+{
+	void (*uboot)(void) __noreturn;
+	struct spl_image spl;
+	gd_t gd_data;
+	int ret;
+
+	gd = &gd_data;
+	barrier();
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	spl_console_init();
+
+	spl_debug("SPL: initializing\n");
+
+#if 0
+	spl_debug("CP0_CONFIG:   %08x\n", read_c0_config());
+	spl_debug("CP0_CONFIG1:  %08x\n", read_c0_config1());
+	spl_debug("CP0_CONFIG2:  %08x\n", read_c0_config2());
+	spl_debug("CP0_CONFIG3:  %08x\n", read_c0_config3());
+	spl_debug("CP0_CONFIG6:  %08x\n", read_c0_config6());
+	spl_debug("CP0_CONFIG7:  %08x\n", read_c0_config7());
+	spl_debug("CP0_STATUS:   %08x\n", read_c0_status());
+	spl_debug("CP0_PRID:     %08x\n", read_c0_prid());
+#endif
+
+	board_early_init_f();
+	timer_init();
+
+	memset(&spl, 0, sizeof(spl));
+
+	ret = spl_load(&spl);
+	if (ret)
+		goto hang;
+
+	spl_debug("SPL: U-Boot entry %08lx\n", spl.entry_addr);
+	spl_puts("SPL: jumping to U-Boot\n");
+
+	flush_cache(spl.entry_addr, spl.entry_size);
+	spl_sync();
+
+	uboot = (void *) spl.entry_addr;
+	uboot();
+
+hang:
+	spl_puts("SPL: cannot start U-Boot\n");
+
+	for (;;)
+		;
+}
diff --git a/arch/mips/cpu/mips32/lantiq-common/start.S b/arch/mips/cpu/mips32/lantiq-common/start.S
new file mode 100644
index 0000000000000000000000000000000000000000..33692ed77db8df57287dafb43aa0293c125068ac
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/start.S
@@ -0,0 +1,144 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2003 Wolfgang Denk, wd@denx.de
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <config.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+#define S_PRIdCoID	16		/* Company ID (R) */
+#define M_PRIdCoID	(0xff << S_PRIdCoID)
+#define S_PRIdImp	8		/* Implementation ID (R) */
+#define M_PRIdImp	(0xff << S_PRIdImp)
+
+#define K_CacheAttrCWTnWA	0	/* Cacheable, write-thru, no write allocate */
+#define K_CacheAttrCWTWA	1	/* Cacheable, write-thru, write allocate */
+#define K_CacheAttrU		2	/* Uncached */
+#define K_CacheAttrC		3	/* Cacheable */
+#define K_CacheAttrCN		3	/* Cacheable, non-coherent */
+#define K_CacheAttrCCE		4	/* Cacheable, coherent, exclusive */
+#define K_CacheAttrCCS		5	/* Cacheable, coherent, shared */
+#define K_CacheAttrCCU		6	/* Cacheable, coherent, update */
+#define K_CacheAttrUA		7	/* Uncached accelerated */
+
+#define S_ConfigK23		28	/* Kseg2/3 coherency algorithm (FM MMU only) (R/W) */
+#define M_ConfigK23		(0x7 << S_ConfigK23)
+#define W_ConfigK23		3
+#define S_ConfigKU		25	/* Kuseg coherency algorithm (FM MMU only) (R/W) */
+#define M_ConfigKU		(0x7 << S_ConfigKU)
+#define W_ConfigKU		3
+
+#define S_ConfigMM		18	/* Merge mode (implementation specific) */
+#define M_ConfigMM		(0x1 << S_ConfigMM)
+
+#define S_StatusBEV		22	/* Enable Boot Exception Vectors (R/W) */
+#define M_StatusBEV		(0x1 << S_StatusBEV)
+
+#define S_StatusFR		26	/* Enable 64-bit FPRs (R/W) */
+#define M_StatusFR		(0x1 << S_StatusFR)
+
+#define S_ConfigK0		0	/* Kseg0 coherency algorithm (R/W) */
+#define M_ConfigK0		(0x7 << S_ConfigK0)
+
+#define CONFIG0_MIPS32_64_MSK	0x8000ffff
+#define STATUS_MIPS32_64_MSK	0xfffcffff
+
+#define STATUS_MIPS24K		0
+#define CONFIG0_MIPS24K		((K_CacheAttrCN << S_ConfigK23) |\
+				(K_CacheAttrCN << S_ConfigKU)  |\
+				(M_ConfigMM))
+
+#define STATUS_MIPS34K		0
+#define CONFIG0_MIPS34K		((K_CacheAttrCN << S_ConfigK23) |\
+				(K_CacheAttrCN << S_ConfigKU) |\
+				(M_ConfigMM))
+
+#define STATUS_MIPS32_64	(M_StatusBEV | M_StatusFR)
+#define CONFIG0_MIPS32_64	(K_CacheAttrCN << S_ConfigK0)
+
+#ifdef CONFIG_SOC_XWAY_DANUBE
+#define CONFIG0_LANTIQ		(CONFIG0_MIPS24K | CONFIG0_MIPS32_64)
+#define STATUS_LANTIQ		(STATUS_MIPS24K | STATUS_MIPS32_64)
+#endif
+
+#ifdef CONFIG_SOC_XWAY_VRX200
+#define CONFIG0_LANTIQ		(CONFIG0_MIPS34K | CONFIG0_MIPS32_64)
+#define STATUS_LANTIQ		(STATUS_MIPS34K | STATUS_MIPS32_64)
+#endif
+
+
+	.set noreorder
+
+	.globl _start
+	.text
+_start:
+	/* Entry point */
+	b	main
+	 nop
+
+	/* Lantiq SoC Boot config word */
+	.org	0x10
+#ifdef CONFIG_SYS_XWAY_EBU_BOOTCFG
+	.word	CONFIG_SYS_XWAY_EBU_BOOTCFG
+#else
+	.word	0
+#endif
+	.word	0
+
+	.align	4
+main:
+
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+	/* Setup MIPS24K/MIPS34K specifics (implementation dependent fields) */
+	mfc0	t0, CP0_CONFIG
+	li	t1, CONFIG0_MIPS32_64_MSK
+	and	t0, t1
+	li	t1, CONFIG0_LANTIQ
+	or	t0, t1
+	mtc0	t0, CP0_CONFIG
+
+	mfc0	t0, CP0_STATUS
+	li	t1, STATUS_MIPS32_64_MSK
+	and	t0, t1
+	li	t1, STATUS_LANTIQ
+	or	t0, t1
+	mtc0	t0, CP0_STATUS
+
+	/* Initialize CGU */
+	la	t9, ltq_cgu_init
+	jalr	t9
+	 nop
+
+	/* Initialize memory controller */
+	la	t9, ltq_mem_init
+	jalr	t9
+	 nop
+
+	/* Initialize caches... */
+	la	t9, mips_cache_reset
+	jalr	t9
+	 nop
+
+	/* Clear BSS */
+	la	t1, __bss_start
+	la	t2, __bss_end
+	sub	t1, 4
+1:
+	addi	t1, 4
+	bltl	t1, t2, 1b
+	 sw	zero, 0(t1)
+
+	/* Setup stack pointer and force alignment on a 16 byte boundary */
+	li	t0, (CONFIG_SPL_STACK_BASE & ~0xF)
+	la	sp, 0(t0)
+
+	la	t9, spl_lantiq_init
+	jr	t9
+	 nop
diff --git a/arch/mips/cpu/mips32/lantiq-common/u-boot-spl.lds b/arch/mips/cpu/mips32/lantiq-common/u-boot-spl.lds
new file mode 100644
index 0000000000000000000000000000000000000000..3b715eb1215b603cf804010a3e33d596f7e601ff
--- /dev/null
+++ b/arch/mips/cpu/mips32/lantiq-common/u-boot-spl.lds
@@ -0,0 +1,49 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+MEMORY { .spl_mem : ORIGIN = CONFIG_SPL_TEXT_BASE, \
+		LENGTH = CONFIG_SPL_MAX_SIZE }
+MEMORY { .bss_mem : ORIGIN = CONFIG_SPL_BSS_BASE, \
+		LENGTH = CONFIG_SPL_BSS_MAX_SIZE }
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradlittlemips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = ALIGN(4);
+	.text : {
+		*(.text*)
+	} > .spl_mem
+
+	. = ALIGN(4);
+	.rodata : {
+		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
+	} > .spl_mem
+
+	. = ALIGN(4);
+	.data : {
+		*(SORT_BY_ALIGNMENT(.data*))
+		*(SORT_BY_ALIGNMENT(.sdata*))
+	} > .spl_mem
+
+	. = ALIGN(4);
+	__image_copy_end = .;
+	uboot_end_data = .;
+
+	.bss : {
+		__bss_start = .;
+		*(.bss*)
+		*(.sbss*)
+		. = ALIGN(4);
+		__bss_end = .;
+	} > .bss_mem
+
+	. = ALIGN(4);
+	__end = .;
+	uboot_end = .;
+}
diff --git a/arch/mips/cpu/mips32/start.S b/arch/mips/cpu/mips32/start.S
index 76abbaa27368d5b14ebea23aeccd00d63004de52..6292bdf816492d3a13291dc8a221dea6c062310a 100644
--- a/arch/mips/cpu/mips32/start.S
+++ b/arch/mips/cpu/mips32/start.S
@@ -115,7 +115,7 @@ reset:
 	mtc0	zero, CP0_COUNT
 	mtc0	zero, CP0_COMPARE
 
-#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) || defined(CONFIG_SYS_DISABLE_CACHE)
 	/* CONFIG0 register */
 	li	t0, CONF_CM_UNCACHED
 	mtc0	t0, CP0_CONFIG
diff --git a/arch/mips/cpu/mips32/vrx200/Makefile b/arch/mips/cpu/mips32/vrx200/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..a0e20b95b0517f3be74ab9cfe472dfae24967e37
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/Makefile
@@ -0,0 +1,34 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y	+= cgu.o chipid.o dcdc.o ebu.o gphy.o mem.o pmu.o rcu.o
+SOBJS-y	+= cgu_init.o mem_init.o
+SOBJS-y	+= gphy_fw.o
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/vrx200/cgu.c b/arch/mips/cpu/mips32/vrx200/cgu.c
new file mode 100644
index 0000000000000000000000000000000000000000..06ff4043f41a80e6643064d68c75a8b054bbee17
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu.c
@@ -0,0 +1,209 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CGU_PLL1_PLLN_SHIFT		6
+#define LTQ_CGU_PLL1_PLLN_MASK		(0x3F << LTQ_CGU_PLL1_PLLN_SHIFT)
+#define LTQ_CGU_PLL1_PLLM_SHIFT		2
+#define LTQ_CGU_PLL1_PLLM_MASK		(0xF << LTQ_CGU_PLL1_PLLM_SHIFT)
+#define LTQ_CGU_PLL1_PLLL		(1 << 1)
+#define LTQ_CGU_PLL1_PLL_EN		1
+
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_MASK		(0x3 << LTQ_CGU_SYS_OCP_SHIFT)
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_MASK		(0xF << LTQ_CGU_SYS_CPU_SHIFT)
+
+#define LTQ_CGU_UPDATE			1
+
+#define LTQ_CGU_IFCLK_GPHY_SEL_SHIFT	2
+#define LTQ_CGU_IFCLK_GPHY_SEL_MASK	(0x7 << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT)
+
+struct ltq_cgu_regs {
+	u32	rsvd0;
+	u32	pll0_cfg;	/* PLL0 config */
+	u32	pll1_cfg;	/* PLL1 config */
+	u32	sys;		/* System clock */
+	u32	clk_fsr;	/* Clock frequency select */
+	u32	clk_gsr;	/* Clock gating status */
+	u32	clk_gcr0;	/* Clock gating control 0 */
+	u32	clk_gcr1;	/* Clock gating control 1 */
+	u32	update;		/* CGU update control */
+	u32	if_clk;		/* Interface clock */
+	u32	ddr;		/* DDR memory control */
+	u32	ct1_sr;		/* CT status 1 */
+	u32	ct_kval;	/* CT K value */
+	u32	pcm_cr;		/* PCM control */
+	u32	pci_cr;		/* PCI clock control */
+	u32	rsvd1;
+	u32	gphy1_cfg;	/* GPHY1 config */
+	u32	gphy0_cfg;	/* GPHY0 config */
+	u32	rsvd2[6];
+	u32	pll2_cfg;	/* PLL2 config */
+};
+
+static struct ltq_cgu_regs *ltq_cgu_regs =
+	(struct ltq_cgu_regs *) CKSEG1ADDR(LTQ_CGU_BASE);
+
+static inline u32 ltq_cgu_sys_readl(u32 mask, u32 shift)
+{
+	return (ltq_readl(&ltq_cgu_regs->sys) & mask) >> shift;
+}
+
+unsigned long ltq_get_io_region_clock(void)
+{
+	unsigned int ocp_sel;
+	unsigned long clk, cpu_clk;
+
+	cpu_clk = ltq_get_cpu_clock();
+
+	ocp_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_OCP_MASK,
+			LTQ_CGU_SYS_OCP_SHIFT);
+
+	switch (ocp_sel) {
+	case 0:
+		/* OCP ratio 1 */
+		clk = cpu_clk;
+		break;
+	case 2:
+		/* OCP ratio 2 */
+		clk = cpu_clk / 2;
+		break;
+	case 3:
+		/* OCP ratio 2.5 */
+		clk = (cpu_clk * 2) / 5;
+		break;
+	case 4:
+		/* OCP ratio 3 */
+		clk = cpu_clk / 3;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_cpu_clock(void)
+{
+	unsigned int cpu_sel;
+	unsigned long clk;
+
+	cpu_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_CPU_MASK,
+			LTQ_CGU_SYS_CPU_SHIFT);
+
+	switch (cpu_sel) {
+	case 0:
+		clk = CLOCK_600_MHZ;
+		break;
+	case 1:
+		clk = CLOCK_500_MHZ;
+		break;
+	case 2:
+		clk = CLOCK_393_MHZ;
+		break;
+	case 3:
+		clk = CLOCK_333_MHZ;
+		break;
+	case 5:
+	case 6:
+		clk = CLOCK_197_MHZ;
+		break;
+	case 7:
+		clk = CLOCK_166_MHZ;
+		break;
+	case 4:
+	case 8:
+	case 9:
+		clk = CLOCK_125_MHZ;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_bus_clock(void)
+{
+	return ltq_get_io_region_clock();
+}
+
+void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk)
+{
+	ltq_clrbits(&ltq_cgu_regs->if_clk, LTQ_CGU_IFCLK_GPHY_SEL_MASK);
+	ltq_setbits(&ltq_cgu_regs->if_clk, clk << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT);
+}
+
+static inline int ltq_cgu_pll1_locked(void)
+{
+	u32 pll1_cfg = ltq_readl(&ltq_cgu_regs->pll1_cfg);
+
+	return pll1_cfg & LTQ_CGU_PLL1_PLLL;
+}
+
+static inline void ltq_cgu_pll1_restart(unsigned m, unsigned n)
+{
+	u32 pll1_cfg;
+
+	ltq_clrbits(&ltq_cgu_regs->pll1_cfg, LTQ_CGU_PLL1_PLL_EN);
+	ltq_setbits(&ltq_cgu_regs->update, LTQ_CGU_UPDATE);
+
+	pll1_cfg = ltq_readl(&ltq_cgu_regs->pll1_cfg);
+	pll1_cfg &= ~(LTQ_CGU_PLL1_PLLN_MASK | LTQ_CGU_PLL1_PLLM_MASK);
+	pll1_cfg |= n << LTQ_CGU_PLL1_PLLN_SHIFT;
+	pll1_cfg |= m << LTQ_CGU_PLL1_PLLM_SHIFT;
+	pll1_cfg |= LTQ_CGU_PLL1_PLL_EN;
+	ltq_writel(&ltq_cgu_regs->pll1_cfg, pll1_cfg);
+	ltq_setbits(&ltq_cgu_regs->update, LTQ_CGU_UPDATE);
+
+	__udelay(1000);
+}
+
+/*
+ * From chapter 9 in errata sheet:
+ *
+ * Under certain condition, the PLL1 may failed to enter into lock
+ * status by hardware default N, M setting.
+ *
+ * Since system always starts from PLL0, the system software can run
+ * and re-program the PLL1 settings.
+ */
+static void ltq_cgu_pll1_init(void)
+{
+	unsigned i;
+	const unsigned pll1_m[] = { 1, 2, 3, 4 };
+	const unsigned pll1_n[] = { 21, 32, 43, 54 };
+
+	/* Check if PLL1 has locked with hardware default settings */
+	if (ltq_cgu_pll1_locked())
+		return;
+
+	for (i = 0; i < 4; i++) {
+		ltq_cgu_pll1_restart(pll1_m[i], pll1_n[i]);
+
+		if (ltq_cgu_pll1_locked())
+			goto done;
+	}
+
+done:
+	/* Restart with hardware default values M=5, N=64 */
+	ltq_cgu_pll1_restart(5, 64);
+}
+
+void ltq_pll_init(void)
+{
+	ltq_cgu_pll1_init();
+}
diff --git a/arch/mips/cpu/mips32/vrx200/cgu_init.S b/arch/mips/cpu/mips32/vrx200/cgu_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..a4bd30f1f76249c7feaa6e864e765f4782dbe7b4
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu_init.S
@@ -0,0 +1,120 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* RCU module register */
+#define LTQ_RCU_RST_REQ			0x0010	/* Reset request */
+#define LTQ_RCU_RST_REQ_VALUE		((1 << 14) | (1 << 1))
+
+/* CGU module register */
+#define LTQ_CGU_PLL0_CFG		0x0004	/* PLL0 config */
+#define LTQ_CGU_PLL1_CFG		0x0008	/* PLL1 config */
+#define LTQ_CGU_PLL2_CFG		0x0060	/* PLL2 config */
+#define LTQ_CGU_SYS			0x000C	/* System clock */
+#define LTQ_CGU_CLK_FSR			0x0010	/* Clock frequency select */
+#define LTQ_CGU_UPDATE			0x0020	/* Clock update control */
+
+/* Valid SYS.CPU values */
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_600_MHZ		0x0
+#define LTQ_CGU_SYS_CPU_500_MHZ		0x1
+#define LTQ_CGU_SYS_CPU_393_MHZ		0x2
+#define LTQ_CGU_SYS_CPU_333_MHZ		0x3
+#define LTQ_CGU_SYS_CPU_197_MHZ		0x5
+#define LTQ_CGU_SYS_CPU_166_MHZ		0x7
+#define LTQ_CGU_SYS_CPU_125_MHZ		0x9
+
+/* Valid SYS.OCP values */
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_1		0x0
+#define LTQ_CGU_SYS_OCP_2		0x2
+#define LTQ_CGU_SYS_OCP_2_5		0x3
+#define LTQ_CGU_SYS_OCP_3		0x4
+
+/* Valid CLK_FSR.ETH values */
+#define LTQ_CGU_CLK_FSR_ETH_SHIFT	24
+#define LTQ_CGU_CLK_FSR_ETH_50_MHZ	0x0
+#define LTQ_CGU_CLK_FSR_ETH_25_MHZ	0x1
+#define LTQ_CGU_CLK_FSR_ETH_2_5_MHZ	0x2
+#define LTQ_CGU_CLK_FSR_ETH_125_MHZ	0x3
+
+/* Valid CLK_FSR.PPE values */
+#define LTQ_CGU_CLK_FSR_PPE_SHIFT	16
+#define LTQ_CGU_CLK_FSR_PPE_500_MHZ	0x0	/* Overclock frequency */
+#define LTQ_CGU_CLK_FSR_PPE_450_MHZ	0x1	/* High frequency */
+#define LTQ_CGU_CLK_FSR_PPE_400_MHZ	0x2	/* Low frequency */
+
+#if (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_500_DDR_250)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_500_MHZ
+#define LTQ_CGU_SYS_OCP_CONFIG		LTQ_CGU_SYS_OCP_2
+#define LTQ_CGU_CLK_FSR_ETH_CONFIG	LTQ_CGU_CLK_FSR_ETH_125_MHZ
+#define LTQ_CGU_CLK_FSR_PPE_CONFIG	LTQ_CGU_CLK_FSR_PPE_450_MHZ
+#else
+#error "Invalid system clock configuration!"
+#endif
+
+/* Build register values */
+#define LTQ_CGU_SYS_VALUE	((LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU_SHIFT) | \
+					LTQ_CGU_SYS_OCP_CONFIG)
+
+#define LTQ_CGU_CLK_FSR_VALUE	((LTQ_CGU_CLK_FSR_ETH_CONFIG << \
+					LTQ_CGU_CLK_FSR_ETH_SHIFT) | \
+				(LTQ_CGU_CLK_FSR_PPE_CONFIG << \
+					LTQ_CGU_CLK_FSR_PPE_SHIFT))
+
+	.set noreorder
+
+LEAF(ltq_cgu_init)
+	/* Load current CGU register values */
+	li	t0, (LTQ_CGU_BASE | KSEG1)
+	lw	t1, LTQ_CGU_SYS(t0)
+	lw	t2, LTQ_CGU_CLK_FSR(t0)
+
+	/* Load target CGU register values */
+	li	t3, LTQ_CGU_SYS_VALUE
+	li	t4, LTQ_CGU_CLK_FSR_VALUE
+
+	/* Only update registers if values differ */
+	bne	t1, t3, update
+	 nop
+	beq	t2, t4, finished
+	 nop
+
+update:
+	/* Store target register values */
+	sw	t3, LTQ_CGU_SYS(t0)
+	sw	t4, LTQ_CGU_CLK_FSR(t0)
+
+	/* Perform software reset to activate new clock config */
+#if 0
+	li	t0, (LTQ_RCU_BASE | KSEG1)
+	lw	t1, LTQ_RCU_RST_REQ(t0)
+	or	t1, LTQ_RCU_RST_REQ_VALUE
+	sw	t1, LTQ_RCU_RST_REQ(t0)
+#else
+	li	t1, 1
+	sw	t1, LTQ_CGU_UPDATE(t0)
+#endif
+
+#if 0
+wait_reset:
+	b	wait_reset
+	 nop
+#endif
+
+finished:
+	jr	ra
+	 nop
+
+	END(ltq_cgu_init)
diff --git a/arch/mips/cpu/mips32/vrx200/chipid.c b/arch/mips/cpu/mips32/vrx200/chipid.c
new file mode 100644
index 0000000000000000000000000000000000000000..522eda872154e435c775390ec3f859b726ab2c70
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/chipid.c
@@ -0,0 +1,63 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_CHIPID_VERSION_SHIFT	28
+#define LTQ_CHIPID_VERSION_MASK		(0x7 << LTQ_CHIPID_VERSION_SHIFT)
+#define LTQ_CHIPID_PNUM_SHIFT		12
+#define LTQ_CHIPID_PNUM_MASK		(0xFFFF << LTQ_CHIPID_PNUM_SHIFT)
+
+struct ltq_chipid_regs {
+	u32	manid;		/* Manufacturer identification */
+	u32	chipid;		/* Chip identification */
+};
+
+static struct ltq_chipid_regs *ltq_chipid_regs =
+	(struct ltq_chipid_regs *) CKSEG1ADDR(LTQ_CHIPID_BASE);
+
+unsigned int ltq_chip_version_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_VERSION_MASK) >> LTQ_CHIPID_VERSION_SHIFT;
+}
+
+unsigned int ltq_chip_partnum_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_PNUM_MASK) >> LTQ_CHIPID_PNUM_SHIFT;
+}
+
+const char *ltq_chip_partnum_str(void)
+{
+	enum ltq_chip_partnum partnum = ltq_chip_partnum_get();
+
+	switch (partnum) {
+	case LTQ_SOC_VRX268:
+	case LTQ_SOC_VRX268_2:
+		return "VRX268";
+	case LTQ_SOC_VRX288:
+	case LTQ_SOC_VRX288_2:
+		return "VRX288";
+	case LTQ_SOC_GRX288:
+	case LTQ_SOC_GRX288_2:
+		return "GRX288";
+	default:
+		printf("Unknown partnum: %x\n", partnum);
+	}
+
+	return "";
+}
diff --git a/arch/mips/cpu/mips32/vrx200/config.mk b/arch/mips/cpu/mips32/vrx200/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..6cae370809059de753d047fc6696f7a49ec65029
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/config.mk
@@ -0,0 +1,31 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PF_CPPFLAGS_XRX := $(call cc-option,-mtune=34kc,)
+PLATFORM_CPPFLAGS += $(PF_CPPFLAGS_XRX)
+
+ifdef CONFIG_SPL_BUILD
+PF_ABICALLS		:= -mno-abicalls
+PF_PIC			:= -fno-pic
+PF_PIE			:=
+USE_PRIVATE_LIBGCC	:= yes
+endif
+
+LIBS-y += $(CPUDIR)/lantiq-common/liblantiq-common.o
+
+ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_SYS_BOOT_SFSPL
+ALL-y += $(obj)u-boot.ltq.sfspl
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += $(obj)u-boot.ltq.lzo.sfspl
+ALL-$(CONFIG_SPL_LZMA_SUPPORT) += $(obj)u-boot.ltq.lzma.sfspl
+endif
+ifdef CONFIG_SYS_BOOT_NORSPL
+ALL-y += $(obj)u-boot.ltq.norspl
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += $(obj)u-boot.ltq.lzo.norspl
+ALL-$(CONFIG_SPL_LZMA_SUPPORT) += $(obj)u-boot.ltq.lzma.norspl
+endif
+endif
diff --git a/arch/mips/cpu/mips32/vrx200/dcdc.c b/arch/mips/cpu/mips32/vrx200/dcdc.c
new file mode 100644
index 0000000000000000000000000000000000000000..0be174f669d2c696dbd43be718fe2954677acde8
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/dcdc.c
@@ -0,0 +1,107 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_DCDC_CLK_SET0_CLK_SEL_P		(1 << 6)
+#define LTQ_DCDC_CLK_SET1_SEL_DIV25		(1 << 5)
+#define LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE	(1 << 5)
+
+struct ltq_dcdc_regs {
+	u8	b0_coeh;		/* Coefficient b0 */
+	u8	b0_coel;		/* Coefficient b0 */
+	u8	b1_coeh;		/* Coefficient b1 */
+	u8	b1_coel;		/* Coefficient b1 */
+	u8	b2_coeh;		/* Coefficient b2 */
+	u8	b2_coel;		/* Coefficient b2 */
+	u8	clk_set0;		/* Clock setup */
+	u8	clk_set1;		/* Clock setup */
+	u8	pwm_confh;		/* Configure PWM */
+	u8	pwm_confl;		/* Configure PWM */
+	u8	bias_vreg0;		/* Bias and regulator setup */
+	u8	bias_vreg1;		/* Bias and regulator setup */
+	u8	adc_gen0;		/* ADC and general control */
+	u8	adc_gen1;		/* ADC and general control */
+	u8	adc_con0;		/* ADC and general config */
+	u8	adc_con1;		/* ADC and general config */
+	u8	conf_test_ana;		/* not documented */
+	u8	conf_test_dig;		/* not documented */
+	u8	dcdc_status;		/* not documented */
+	u8	pid_status;		/* not documented */
+	u8	duty_cycle;		/* not documented */
+	u8	non_ov_delay;		/* not documented */
+	u8	analog_gain;		/* not documented */
+	u8	duty_cycle_max_sat;	/* not documented */
+	u8	duty_cycle_min_sat;	/* not documented */
+	u8	duty_cycle_max;		/* not documented */
+	u8	duty_cycle_min;		/* not documented */
+	u8	error_max;		/* not documented */
+	u8	error_read;		/* not documented */
+	u8	delay_deglitch;		/* not documented */
+	u8	latch_control;		/* not documented */
+	u8	rsvd[240];
+	u8	osc_conf;		/* OSC general config */
+	u8	osc_stat;		/* OSC general status */
+};
+
+static struct ltq_dcdc_regs *ltq_dcdc_regs =
+	(struct ltq_dcdc_regs *) CKSEG1ADDR(LTQ_DCDC_BASE);
+
+void ltq_dcdc_init(unsigned int dig_ref)
+{
+	u8 dig_ref_cur, val;
+
+	/* Set duty cycle max sat. to 70/90, enable PID freeze */
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_max_sat, 0x5A);
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_min_sat, 0x46);
+	val = ltq_readb(&ltq_dcdc_regs->conf_test_dig);
+	val |= LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE;
+	ltq_writeb(&ltq_dcdc_regs->conf_test_dig, val);
+
+	/* Program new coefficients */
+	ltq_writeb(&ltq_dcdc_regs->b0_coeh, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b0_coel, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b1_coeh, 0xFF);
+	ltq_writeb(&ltq_dcdc_regs->b1_coel, 0xE6);
+	ltq_writeb(&ltq_dcdc_regs->b2_coeh, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b2_coel, 0x1B);
+	ltq_writeb(&ltq_dcdc_regs->non_ov_delay, 0x8B);
+
+	/* Set duty cycle max sat. to 60/108, disable PID freeze */
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_max_sat, 0x6C);
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_min_sat, 0x3C);
+	val = ltq_readb(&ltq_dcdc_regs->conf_test_dig);
+	val &= ~LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE;
+	ltq_writeb(&ltq_dcdc_regs->conf_test_dig, val);
+
+	/* Init clock and DLL settings */
+	val = ltq_readb(&ltq_dcdc_regs->clk_set0);
+	val |= LTQ_DCDC_CLK_SET0_CLK_SEL_P;
+	ltq_writeb(&ltq_dcdc_regs->clk_set0, val);
+	val = ltq_readb(&ltq_dcdc_regs->clk_set1);
+	val |= LTQ_DCDC_CLK_SET1_SEL_DIV25;
+	ltq_writeb(&ltq_dcdc_regs->clk_set1, val);
+	ltq_writeb(&ltq_dcdc_regs->pwm_confh, 0xF9);
+
+	wmb();
+
+	/* Adapt value of digital reference of DCDC converter */
+	dig_ref_cur = ltq_readb(&ltq_dcdc_regs->bias_vreg1);
+
+	while (dig_ref_cur != dig_ref) {
+		if (dig_ref >= dig_ref_cur)
+			dig_ref_cur++;
+		else if (dig_ref < dig_ref_cur)
+			dig_ref_cur--;
+
+		ltq_writeb(&ltq_dcdc_regs->bias_vreg1, dig_ref_cur);
+		__udelay(1000);
+	}
+}
diff --git a/arch/mips/cpu/mips32/vrx200/ebu.c b/arch/mips/cpu/mips32/vrx200/ebu.c
new file mode 100644
index 0000000000000000000000000000000000000000..8af65c64c492b1e69745272ec53fd32128ff2eb2
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/ebu.c
@@ -0,0 +1,112 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define EBU_ADDRSEL_MASK(mask)		((mask & 0xf) << 4)
+#define EBU_ADDRSEL_REGEN		(1 << 0)
+
+#define EBU_CON_WRDIS			(1 << 31)
+#define EBU_CON_AGEN_DEMUX		(0x0 << 24)
+#define EBU_CON_AGEN_MUX		(0x2 << 24)
+#define EBU_CON_SETUP			(1 << 22)
+#define EBU_CON_WAIT_DIS		(0x0 << 20)
+#define EBU_CON_WAIT_ASYNC		(0x1 << 20)
+#define EBU_CON_WAIT_SYNC		(0x2 << 20)
+#define EBU_CON_WINV			(1 << 19)
+#define EBU_CON_PW_8BIT			(0x0 << 16)
+#define EBU_CON_PW_16BIT		(0x1 << 16)
+#define EBU_CON_ALEC(cycles)		((cycles & 0x3) << 14)
+#define EBU_CON_BCGEN_CS		(0x0 << 12)
+#define EBU_CON_BCGEN_INTEL		(0x1 << 12)
+#define EBU_CON_BCGEN_MOTOROLA		(0x2 << 12)
+#define EBU_CON_WAITWRC(cycles)		((cycles & 0x7) << 8)
+#define EBU_CON_WAITRDC(cycles)		((cycles & 0x3) << 6)
+#define EBU_CON_HOLDC(cycles)		((cycles & 0x3) << 4)
+#define EBU_CON_RECOVC(cycles)		((cycles & 0x3) << 2)
+#define EBU_CON_CMULT_1			0x0
+#define EBU_CON_CMULT_4			0x1
+#define EBU_CON_CMULT_8			0x2
+#define EBU_CON_CMULT_16		0x3
+
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define ebu_region0_enable		1
+#else
+#define ebu_region0_enable		0
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#define ebu_region1_enable		1
+#else
+#define ebu_region1_enable		0
+#endif
+
+struct ltq_ebu_regs {
+	u32	clc;
+	u32	rsvd0;
+	u32	id;
+	u32	rsvd1;
+	u32	con;
+	u32	rsvd2[3];
+	u32	addr_sel_0;
+	u32	addr_sel_1;
+	u32	addr_sel_2;
+	u32	addr_sel_3;
+	u32	rsvd3[12];
+	u32	con_0;
+	u32	con_1;
+	u32	con_2;
+	u32	con_3;
+};
+
+static struct ltq_ebu_regs *ltq_ebu_regs =
+	(struct ltq_ebu_regs *) CKSEG1ADDR(LTQ_EBU_BASE);
+
+void ltq_ebu_init(void)
+{
+	if (ebu_region0_enable) {
+		/*
+		 * Map EBU region 0 to range 0x10000000-0x13ffffff and enable
+		 * region control. This supports up to 32 MiB NOR flash in
+		 * bank 0.
+		 */
+		ltq_writel(&ltq_ebu_regs->addr_sel_0, LTQ_EBU_REGION0_BASE |
+			EBU_ADDRSEL_MASK(1) | EBU_ADDRSEL_REGEN);
+
+		ltq_writel(&ltq_ebu_regs->con_0, EBU_CON_AGEN_DEMUX |
+			EBU_CON_WAIT_DIS | EBU_CON_PW_16BIT |
+			EBU_CON_ALEC(3) | EBU_CON_BCGEN_INTEL |
+			EBU_CON_WAITWRC(7) | EBU_CON_WAITRDC(3) |
+			EBU_CON_HOLDC(3) | EBU_CON_RECOVC(3) |
+			EBU_CON_CMULT_16);
+	} else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_0, EBU_ADDRSEL_REGEN);
+
+	if (ebu_region1_enable) {
+		/*
+		 * Map EBU region 1 to range 0x14000000-0x13ffffff and enable
+		 * region control. This supports NAND flash in bank 1.
+		 */
+		ltq_writel(&ltq_ebu_regs->addr_sel_1, LTQ_EBU_REGION1_BASE |
+			EBU_ADDRSEL_MASK(3) | EBU_ADDRSEL_REGEN);
+
+		ltq_writel(&ltq_ebu_regs->con_1, EBU_CON_AGEN_DEMUX |
+			EBU_CON_SETUP | EBU_CON_WAIT_DIS | EBU_CON_PW_8BIT |
+			EBU_CON_ALEC(3) | EBU_CON_BCGEN_INTEL |
+			EBU_CON_WAITWRC(2) | EBU_CON_WAITRDC(2) |
+			EBU_CON_HOLDC(1) | EBU_CON_RECOVC(1) |
+			EBU_CON_CMULT_4);
+	} else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_1, EBU_ADDRSEL_REGEN);
+}
+
+void *flash_swap_addr(unsigned long addr)
+{
+	return (void *)(addr ^ 2);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.blob b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.blob
new file mode 100644
index 0000000000000000000000000000000000000000..cdf3d3063405c1239d15bae873e11f4ad8644e0f
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.blob
@@ -0,0 +1,224 @@
+222 222  2                              ]      `     [     
+          3     T         Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs   "   ?(  $  3. /+!'-0 !3!F!/!)  Y#l!!h!  ! !" "'"Mt#i- +"$$ !D ! !" 3 3!F!NY!v !    ! !E(. ") "u/33@" u/@3P""us|   ""S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""C`u1qqDCuu~~qq"A$4$T4$4 "uuu"tKtL"uc c#0
+0t ~/ 4
+cc2uc c TT0T1TTp$$mpp$$pp$p`$ T0D DD    TTT D (  %T OT   TT3T  OT TOOTTT OTT T ?T0=T   D D  T` TT OT T`pTdT
+`TpT*oT
+`+*TTOT$T$!`$4`$=`$_`$d`$g`qpTT ZTQTDTp#`T"T+4Tc c2$T$"``9`p$>b\pYpT"$Ep@pT"D,y"@t}peet	`etp`e"uc c te,@`p\e[e_` s`sY[_Z\\`[\[Q0|t
+4D?T&0u+V UVV%U5u`UVu U+V	 Uu?Vc c24^2_`ND" ucc te2@c c2ttTTdtT?Tdtx@x)@xxp%vxxxT[Qx`8AT`[Qx8AT[Qx`8AWX$ 4,t @,tAPt03xBTX_Tt`,X^T`QxH@tB39QW`x@t'3BTWQt`3Bdp!`TT6RcTB\D"S	T$`t3_S"0+@TT]Tt3T_"uc ceT0D D  tecc2uu2uu2uu2 G		`p" " tq~ #~}$/ t>#$"('dPd@u? %	3xt$@t ~33%5
+t%5} |(@'(' u"D D5D4"D &
+ " |$ 4pe
+"|T; =<>;<p %
+
+<;;<N`$b`$`$?u?dP=>?TdE@7$EEE%0tEEt??%d=P>=>-=>p=E0?`=E>=+} |>
+0$??.@t|>=
+} =>`?@t??%<p<; ~"0T\`$|`$p`$|`$`$%`$6p$H"T,VP$p`",,"@Dtt"WFUHPG_RV_YP 
+9:LOT
+D% } "9OfinI	 
+t 
+0D
+1D	2D	 E	 
+pecxnoitE	 
+
+tix C"\[ba^] su_u`u~ j1}Ja|}a|1*1)epGDDG""
+u Cu"TGTHOTJILKG"T%TTHONMPO"DT DTttT$t "T0c  |0| ~} (~?$~3.~~ /~+~'~~-0~/~)~~  #~h ~`s! ~u^u"]HI u"aububp^e]ea]`b^aab"' ~]u Y^u" ~",u"]u~"g^1 ]u^u"" ~6"]u"H^uB ~u`u_ ""        "    Iy@e               0                         ?  @ H  ?    8     "atKLt
+ 0T0Q  `"t " TT t`1DaD D@TTT t ~ t5t~t+~*TOT	DTt	jt?TV0'%0Tt$QX 'TX'|Tt$Qx 'Tx'T0%T$tQQ 'T&Q'T$tQa 'TQa     'Tt$Qp 'TQp 'Q 'TQ ' Q'TQ      T"t$tT&d@.t0/&T0"" } |##~  pd# ~@ | {L}~{ ~d# ``d#a0(at tttt@tttttttt(@tttTT0?T<{ zxTT~Kx 33ON0T< z{xTTKx ~33NO0T<{ zxTT~Kx 33ON0T<{ zxTT~Kx 33ONTTOT%T"O%$'&(,T$`$`ipt)([0y%U@L$ 4t,-$'&' 4&Ut*,-U%+$-,\](L*M+)$'&' 4&t(%)$$%$ 4()` d0>8d#pT3(OT33TT33,OT"!tAa TD 
+It*\t&Jt+tt,0t" t%tDDT\DD	Tt_^]
+tt`TDDTTDTTD     TT3D:DD;DDTD<DT=DDDT8DDTTDIDTTtJKPDTTDDRTTIuDvDTtDDDD"txxxxxvxvtgtptt t@t@t t6tD""aMA 
+nitinIcA 
+ 
+tON		TAM- 
+HC~0  T  !0 0_u"~`u 0T3T_u"B`uTu_u_uL`Q`u_u""G`u
+0  T T0/dT!` T!04xT% MT1mT`D5TT1OT 1T`oD5T T333T1OT/pd1)D?T@/TT1@D?DTDDu1TvOT1TTvOT/TTwO1TpdT_u"y`u@T1`,`2p_u"``uu_uu"=``u_"[u`u_]u"V^u" "Tu0`u_"~  ]u" ^u`s ~u^u"]p^ebea`]^a]bbac"cTu]u8^0	dTa`dTa`
+n^_o0 T0gT\0?1DT00T	D1T10?T0?TD1@qaDcac n
+0T1Do'0T1
+DT(o0TT1Do0T1TTcDc00T1Dn?T	0D1?0nT$00T1 D
+"10DTT1Dcc0c ~u]u3^D4~"&T	@D"0T$T	Tx
+0T$xT$p`jpd~pdaDV=plxxpfpfx7@Dvx,x@ t@ 	T33TT0O@D4"   "        		D!XR		
+x%:			 d%XTx% :T	 
+siDxA	 
+-lib	 
+DC-SL 
+khDP		uaF- 
+tlKCA	 
+D-A-C	 
+KCXR		=MSF 
+d%-PN	tiaW		 
+SFXTd%=MA	 
+
+seR-		 01 >x 0 - s - DF/ DHS/ MEE/ P- Ed%:S 
+]u3^uT T  TDtxT/T$34 u xEOKattL  /T!TTDD"D(`suuuu|xdTdddT  T #     ?T T .~p^e]e]`Iq^Tdd0 ~Dddtebp^`]eaa]b^abdTd10 ~#T | ~DddtT0Tx	
+Dccxxc	pTxcTx~x@`dccT&0x x@ ccD v~xvtTxt TT333cOTccTcOTcOTTTccO0d)20)T=T~T} | 
+x9$>}"|PD=Dx"TtT l ~"r.~40 txv4v#?TqtTT  t]uP^u$"?T'00 '^ ?TV3DTTT3O!TDT3T  DT tt,tt TT3D!TOT3TT3D  DT Ttt,tt >3%T%#NT333TOT " ~"xtxvv*vvzxvlkvxxulvgfhTTTTN33OT3(T  ~~Pp }}MT^MTTTTN33OT3TTcOTc
+TTT#cq c
+T'0?tx'PvxclvTTTcucO^u']xvt6vT
+`dxlkdM0E@TTkkOlkx]u@^u(klx 'v	@x@ d cwxxpF#40?T5DxqT%3x$4w*x!T#Tpo`D5xxxqvvxlvxvxlvv*v'q) hp7`cyx	0vz%vzP0dvzx v DD!hu cx0vzvT!Thz%P0dzxvvT!uTch0vzxvTT!hz"P0dzxvv  D!u D0"h ~,+D#T?qvtxxLvvzcvT0Tc333TT cOTTTcOTtcPcT !tt]uj^u#c TzP4 ~D]u^u$vzx"v#0"@ ~D@DDkk@xT`d]u3^udL0lkx@)]u2"^uxTkkpleke]u`3^uDk"k@A  ~sHvx$g$```p$gu3k0Tk(TldpNgukTl
+dupNggg=`$$}`!p`$	Ak
+lk TOT
+TTTOx\(lT  Pp ~~x6`NTOTT?TTOlkxT
+kldg`kl4 DP ~ |gDk3TT33cOTcc T T333TTccOfT0dx	@ x>p0?T-T$0T T0u*]uu"^^u#]"jT`du]u 3^~\ xkfld`$|`$app$aa`(T P p ~N~TT`_NfuO0 T)0fu`*T  Tfufu$ff?`)p`[p`$`$outu
+onnDounnTnnn DtonTToOTTo?ToOTTooOTTo%%oOTToTTooODnnxKyT	xno `TOT333noTTnnOf ~ |fpdf ET[0ncoTTTnnOno Tfu&0!cTTnOTnnodu0TplekexMpvU@Tc`oTf; 0T(]u+^u fT  D4"klx~"y xT1xP ~x1T ~1T ~1T0 ~ ~1dTpT~0  ~1?T~0  ~T1 |u^u.]"TTu_u""`            001	esab 1T- 
+SN  ~"        PSA		d%:CGA 	d%:%:M H 	d
+d%:bA	 
+tsiaW	  
+tiixE		 
+t01CDD	 
+001C	 
+0
+NCIHT	 	 
+D
+CGA:P	 
+d% XE	 	 
+C CDA
+REB 	
+	 b      b    K K    G(%0+V<6GA3Q?LZUb^mjfpmAvs}zx})|b~0  8(4$<,2":*
+6&>.1!9)	5%=-3#;+7'?/QPSR,,,%8-,59.<-5"<"333"30d ~2|g  	 ~ |h~  |i ~j |0 0"QjT"Du-]u0"^1
+ vtx"vtuP^u.]1"}33jT33iEOT h~ TgT0"OQz { ~QQjD0k
+]uh^u'0"Q1z { ~QQ?cuDj0k`chc
+Dju"^u']"$ 4 Ld{"p z$#&%+'(u )u'fP&Tpd#pk< 3n%~$ 4t$)) 4(())$4(( $% k"~ 3 k0>.ti: ~>k0@tQiuz{|} Q +juD^u-]"YTj~~Q |  }$#&%&$%'#)( 0u*u@1u3u 232@@ +.,,1@0--23@3%../<=/<==</?>*.)98*/);:+t7@ %+@$ 4t67$%+^ 4t54+/$%4 t67 t$%+ 44t:53;63RS7PQ 1?>3345RSPQ 1 C+B:A9@8?>336S7QRP 1:3;43S5QR1P  GFEDKJ=H<KIIJw1HJKHIC%K5JKJBA5I5HIH@HI(.O'KJH<KI=IJw1HJKHIKKCBJIJIA@HIH/H'(JO8KI9HJKHIKw1IJKHKG%F5JIJIE5D5HIH.HKKJ9H8KIIJw1HJKHIGKJKJFEIHIHDHIK/1.++%-/+.a,0101%3323a2."'(u%5"('*)-u0+- -%,%@t
+++,+,+H@.,/+'(/O,.'(+O)*.,/)*+/K,.0K-@-"@)*u%5"Tj $%433$% 4>/%$ 4q")gu@^u-]]u"/^u"q"g@u+]uu"B^^u"]i"]lp$m$#>%(tgmmll5iuj$pml$>$ju#$$#>ji 1/0#$,+p,,+,+,+p,,p++/,p+,+0,,p++1+"$% 433SQRP!/ -.%+, $433RSPQ !///>.=-.,-,<./0u-423E11324BpB4u	2311 4023!134121 ~%0000 ~x0SuRuPQ4 !23%144432535211$u"2%'&#u#((P$$(%((@%(%''&&5##@@hpml)	hu*$*)>ghm%(t5mll'0x&/1%$)* ~_cuhji"p:d`u:y@{	zxv'v	 txx		tt	t8pq+`"9	jD08D ~ 	t		ut^u/]"TjTDtlmtnto ~"Oguhujui lu mumlf$e>ktp>tt6tt@tCtBDq"u!]u"^mnmnTjm"n`s ~u^u,]+DdTp   0-]uk^up^ebea`]^a]badb"Tdd"kTtt\_^]`\~tEeGgtt`k"t5t51t=kp>Lt.t=	tt8tttt     ttt67tt6jTtlmntophgiu luj mu`$"p
+u#]uu"J^^u*]]u"i^u-0"% ~D~", T  Tu_u~"`C ]u/^u" ~"Iu lu miug]uh]^u""g]u@f^u.0d"0 u!]u"^F0d# ~#U |fpefe#pk%u$$u%u phhu%(tgmmll5ml$>f0e>h ~} |t%$%%@$5%%$x$$%%> ~"] lu mu]ug^u!l"m$>Mtlm $>Mtlm!$>Mtlm"$>Mtlm#$>Mtg $ % ]u&Y^u-tg"m%(l5m"l`	wxhA`vxA`vx	`vx	p	`x	vxpyP&yx6txx{x @ pxx"'  ]uOY^u-  ""    seT		 
+tteS	 
+puBL				 
+LOC	
+d%=G		  
+EBixE	 
+tOMA	SN NC	 
+DI D 
+ELWDC	
+TIADC	 
+AEM
+D% DDC 
+enoIDC e-GA
+tixDC	 
+TESPDC x%-KR	 
+ d%:%:O S  d d%:%:D P  d
+D%:am	 ehct  
+d! ~ xT% TTM1OTuDT1TvODDDTTDDTDTDyD1TOTDDTDTDDDTTDDTzoT ~`TTzOT  T+ ?T#T yTTT]u^u$`s" ~ u"]u^ D   9  1x$  T T ?T]up^u$^ebap`]ea]b^ba0" ~ T T ?Tu0^u ]]u"^u"0"! ~T@@TQ`oTup^u$]"TTDuDTDTTDDDTTvDTOTDTDTDTT DDT T DD  @ `Yt,LlDDDTT!AatDDTT@DTDDT	@D
+	 	
+T		DDT   T  	TTD	DD	DTTD	D	DD >  	 m	 ~"(TT u `u_ ~"0vx`sDwx3T   u0^u*]x0vp']u^u']u^up^ebea`]^a]bbavx~"m utvt5t~tttttD 
+					t					5t	t			t	t	
+					tt		   	  	t			tt		t	ttt		tt		tt	tttt	*t							tt	t]]>	d]` P  Ct					StBt					Rtt t	"		"	~0: 0" ~ Dvtxv vwxx04vttvP)]u"^uu%5%" &5 9%6~:&u 9:%u4&3%'*%&*3'3*/u)0u  &u21	1@28)%&*1(3'(3,3+@)708:$/59977*d) @,3+ d6&Pdd'@D858dd'P ~;~d)P+>d65@dd''P8D58dd'@ ~~TT88N1f`&_1%.-3%487H'3%4-.'@ ~H8~~ 8 ~8 ~|7  ~-. 3'(,)+1*1?1~@@ ~0%50//'1"p3 ~87D883%478"H'		u$e40" ~0Mvtxv&ut  A@ Lt@LA&u"##'"0a#MQ"vx0?T;~$$|#  } }ddP"#_1$~U  $##"@"x@Tvtx ~Y%"&u'$5
+u-<)( | ~}} dd1P%x_1%''&&5	()&' ~"aTT _u `u	"	eu$4 ""        B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t`s  ~T "      T
+  0?T&~epb`aebet&tp`ae^]^ebap`]ea]b^ba{xTtT l ~"C `q	T/T$34 u zxEO#;1ttxvvu"]u"^T?'00 '&UxB t! T  DTT"$t,tt @t!T  D TtT"$,tt >T3%%T#NT333T"O~#0& xxvv$DDDT 0wx 	@ p&]u^uT`d	00txvvv	v%]us^u 0T# 'x;1
+vx"$vyx @ px"vx$vT{xDpT#Tpo`D5{x ~D12#T0?8 ~~: "!tAaT D It
+*t\&tt,0t"t %tDDTTD	DDTt 
+		
+tt
+DUDTVT0DWDTXt\Dt_^
+t]t`TDDTTDD T    TTD34T:DD;DD<=DD8DDDDTtTDDDTtT&$T`"ptyDTDTtyyDDDTDTDIDTTtJKLDTMDTTNDTO&DPDT<DRDTITD0" ~TTxvT0Dt`DtTDTTTTNT3OTTT3TNT33OTTTTNTObtT#TSTO#ToTTTOT>`ddT7`ux @ pu"^u"] ~TTD5"Ttxv"vv	v"DDu&]u0"^ ~<tTTTT_u"`u   "            001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tixM		 =LLD 
+d%`s ~* u!]uX^vx~xv|xvtxvv71T 0?T t]uP^u,  T "     T 
+?Tu0^u,]ebp^`]eaa]b^abx"T tTl"	 ~1$]uh"^u!AtaT DD` t0t" t%t&t
+*.tDDTDT
+	 	
+D	DT	DDTUDDTVDTTWDTtX\DDT_^]`TDDTTDDT T    TTD3:DD;DDD<DD=DDT8DDTT6DDT7TD6TTDDDDDDTTT0DDDTDtTDDTDtTtTT`dP    ~tCt  dpLBttDDttD"#?T0'0'= &x *t!tt6t,t( t!tt,6tt >T3%%#NT33T3OT "~] T  Tvx$vT/T$34 u EO}xD DD@DD TD DDCDpT@ T0. ' T#T`o'vx1$v[PvxT$vGPx$T#Tpo`D5x ~:#?T~0  ~!@&]u"^uGd@}xP
+"dP}x0" ~ # vvxx
+vvD D wxPpF
+vx#@ G@
+TT TOT ~"Ox) | 3 ~G |]u^u( ~"wTTxxDT X    R  JT0?>T # T0x Pu$]ux"^`|@(]u"^uu,]u~"^h ~xG#T$DT(DTT'VDTD0TWDXtuP^u&]]u">^u,\0"W ~x vvdvD!CDBDT#D$DT(DTTVD0DTWDXtPu&]ux"^Fw]upo^u+90"Q ~x vvvT$'T+TTVD0DWDT@%zuP^u&]wx"pFF.]uP^u']u^u*.T@Dp1(]u"^u!}DT.TTTO12"#3"##"."D/"#0.
+!T " ~A;vvxv DDD!DTTT"DD!DT#DD'DTDT(DD)DT*DD)TT$DDt%D$+Dt-@D&TDTT!'T+T.TDDTt/t0.TDTt/0T.DTD3xT33t%%/0.DTD@@t/0.$T@DDDTDDCDTDBDTT@%]uP^u&wx"3pF.DT ~@A12]u^u*vzx"v~z0K vxv v!
+DD#DT$DTDT'(DTD)+TDT,tTVD0DWDTXt%z@P&]u"^uwxpFFPu']u0"^ ~>]vvxv )?TR0T0D"0DTDT T%" D)T0?q ~3ewxpF! ~u^u']
+"#}~|T@F6P.TTTMTTTTOT&
+*0" ~}p|x#T&$T`"ptyDTDTtyyD DDD DDTTTT%"uP^u&]_u"o`uu&]usu^ ~"~t?tDTTTt t>u_u""`AGIG		 
+-IFLemiT 
+!rteS	 
+pu
+PW	GA	 	 
+C =G	  d%E	 
+ 
+CX0KO	O	 
+ 
+1K2KO	O	 
+ 
+3KCDA	E	 
+S-CX # 
+COL	 
+1K:p		 	d%d%:t:m 	m 	x	d%:%:d 	 
+DKCOL	 
+2L>-	EKCO	 
+DKCOL		
+3NGISd% :NL	 
+PUKxE	  
+tiDM		%=LL 
+d	Fu		#t&dT	+t`t&T 3TT33	OT					t	0ttt___>	
+`d P ~ |Ct					Stt				 >p#t		@			Ptt				0	tt"	"Bt			t	0"R ~!{x`txvvv@v{xtt{xPu`^u(]]u"^u' ~"TtDt tTTTtu_u"`~c`s  ]u^u!0tKtLtxxDvxx\v&T@v{xT0 {x{xpDx P ~Y(`TxpT % P(T @"Du"]u 5^T"      T
+  0?T"]u5^up^ebea`]^a]bbaq" {{q3DT	O	"	 	jt		t		t	t	&T`d	tt		t		t	t t		tt	{qq{|xP%{q@{qq	8 ~x vtt}vP$]u"x^u  ~> vtxvv v{dq	t		t				tt		&dT`	tt{x`	tt		6tt	t4t	&T`d		ttt@@t	xF/.P1&@D+&dT`t)xD+Tt!D)T/P/'@D&T`dtlDxTtlDT	1P/)@D&dT`tDtx&TtDTu	1P/`	)@Z	D&T`dt6		DXtx&Z	Tt6		DPX	Tdxx	` vvdvvuP^u']	YD"u"	1$2%&'(`	)*a	#+%#$$ 
+x ##"	D$/0%&'(	)*^_	+	d""`
+	T/0"D ~xvt	vT{x33TT3	OT	T	@t1@@		@`uP^u#]t"P	Du*]u0"^ ~vtxvG@
+
+	@	@
+v	P
+tuP^u(]0" ~! vtx"
+vtx?P vtov4P&TT @D~ `{x)]u"2^uu#]u"^Gt""%| @@"%|t%et5""T|$TT OTtt/|TT O|$TT@OTTt|tT/T`0O ~&'~"t, "%| |""@0" ~2 vtx12vtSPu#]u"^t	&TP)0?T|x@	tt			0" ~QVDT	t					txvvS1  dx@xxTx e@(FQPHP(	?P(u	P( 6Q> /Q/ 	Q/ Q/m	~^ x >  	 m						]u^u+0 ~d@"dP 0" ~Jvtxv	DD	)0?TLTPTTTOT~TPTTTTO~tx2} |x(pLp{	PVTPTT0D	t{xPu`^u+]]u"^u)0"P ~x vt
+v)0?TqtuP^u,]"u"o
+#uu$u%``p$TtTTt$%4 t#"T@=%4P$TTTTL"#TTTLT t%%%$5% t$##""5da`0" ~W`ttDDtTTTxxvvxx"`xU30~~$xh ~x | ~xp |x	v ~ ~x{ | ~x$3xPxv.]uPX^uxH~P x dtxP%xxPxdPu^u#]xTdxpTOTt%T%OTx$pd$xTTTOTt33TO?Tx$xx0"xTpD333DTt"Tpx33
+DT3Dx333FT"  ~vxvx$xddx@x
+$xx$Tx$T333T$$O$T3$T33T$$Otxv vH
+p/]u~;^u tP#]u"^u  TTOT xx@D0" ~TT@Dx"p ~&x |xPBu/]u^x7)P3TTT.Ou#]ux^TTT"O~0 u `u_suju"]u	5^TDD	T"D   "    ART	 
+KCAB		IS_D	 
+G:d%	d%  d%   Bd  D%  mpp D% 		 
+----
+ 
+-1 
+Y`	#	s	p  ~D	`Q DDTPDDDD  D%TTOtKtLTCPDD		tunu%ud1e0?T)0`e)A pde);0eueGTtfHDRQTSGDt%t`QDTTTTNT3OTTTTNT333OTTTNTOTbt1T ?tPiukumuljuFnu `nQ  T @:  2   T (?Tt pe_e*tt`	%t@P"T5D~``_"\[t	 Tp1T`	"`	tx"vv ~P|i 	k3TTOT%i>$ 4t#"%uapkp$a```$H~a "#uml}|Pj~j|  m%et5mlliyF$%4 t"#xx-/pi $ ~3%u0$
+$#P%T$	OT, ~#"$ ~0k$ |3}kpdki3$T3 ~i2pijTTT!O ~n;	"@tGg@
+@
+	^
+	U@vL@
+FDP(;P(	P(u	2()P1!@@@`	@xxxd ~	@"""T $T T~ ~T{ {pT"	"TT#
+pTTT}}$CCdoT333$%dnT%OTTmO##$ThpT$"TO$T$JpT$" "tfh1 ?T@f eE	TN@DhdT=pTDDT		T@DT	D	 DT	`t{.~ht0/	TTG~.	g@t1@@	@`	P_*g	"h0TDD"DTT" D-h0DT""tfheEf	 T@DTh`(($Thph t(x
+/@x`
+d0{DTT	TDT	T0D@DDtT0`
+Tht*thp$T-dx
+`Xpd`{x	SD	DDD		DD	D	DD		@D	tT	thpxh h 0t	GDTuDu("<<hThp,pT}	|$Th i` hf"0eEhYh@TDh0D	th/ eQthtgp$Th 	`eEfq QqYQDAeEfq AqYhD 	VAD	tthDTxqXvh	 Ef eDAt 	e	 	e	h	 f eEDAt	g			g hf	 eEDAtb		,tt		tt	 hf	 eEDA#T0?t!t!tAa hf	 eE@t		t		 hf	 eE|$}h	 Ef eoaRthu*ufu" gtfghip`puu*	"_tt			"tfh f0eExoaphtI0xTThxh@xh@hxThFhh,Lhhl"DT	DT	Tt		tt		tf"eE0@DT""!Aat5,LlTDt		dd		d hhh
+TDDGT a~GDD		tthT,uuYq-ti x 0`{DT	tt	tTtu-uJt	t	fT`f=
+ g  	ttt
+T
+  g 		tt	DT<t	&gA0-u_Ju0hJG"TTTTHOZY\[thG"Dh0Tt	"t			tt	{x"L`0T>
+ g  g0<)&ThtT	0g0g_AthBtfeE0@DT&0h.'0@thGTf{0eE h"<	DT	`D	DT	DT	D	tth%u"uT DD	D DD	TDT"TG}	|{x`xvv~~Tuu&"fTGDHVUXWtg"TGH D^]`_ti"PtDTTfeE0@DT g0"!pdT`TTTOTTT	"TPTTxN	{t`	tT	pd	920	D	t		Tt		t		dd	""d    taD		 
+aDAB	GIS_	
+ 
+KOL	d% :		 
+:LVL
+d% P		  :RW
+ D%S		  :RNd d%	 
+BORF	D% :mpp 		 
+:QELD%  	 
+ EFD			 :CSoL	 
+RSoL	s 
+ ~;` xx}$uu>uu%u1?T0Td)0`d); pdd)50dudGTDHRQTSDG`DtTDTTTTNT3OTTTTNT333OTTTNTOTbtmQc3~`c  TD    >  6T,   ?Tpc"ettp`e'ettp`e%lA}PTGTtfhTT!T!TtUDTDTTDDT5D[~`_\[0"xpxda`FY[#Z$$x#$x#<-$%5$##F!|}$% %@%TTT!O.@DT1~&x xp~ &2 ~G) |~5  |% ~$C#&@x"dGpFR ~.T"T".OTY ~12""@
+xPdNpF_ ~.DT T""T. ~OY12""~@] F@<""@f ~GxP}~@
+o "}x"tf0dE!DDGDD$u"lutfE dGTtf+0ft">f|}GuDu%_"TTTGfutu$P}">|GT%T%THORQTStff"t dE>ff0t"tf dEft0epe_GDu$u"l#?T 6tt,t6t,!TtD"D!Dt,tTeu>P}f|$DGu.u%h"
+t@0hiu2)DGD@TGjDD0htTVGTE"jD@T@TDCDT`thuguu&"vth0(0h<h h2*0tgg@i$DD'tUpg" phpT"A)tUTVPTNTVT@T$T'gu")
+GDT@tAth	DtTVD^u@tu'h] g@ 0tg^`A("gkh&0tU)Tt
+tthu+u('u"uDDp`ptfhTD DDCpD@"0ht0kg'0ht	g"'0h	tu hg@ 0tgthhgA`gkh A1pg'$g	iE&PhPp"@Dt!)tt'tTtt't!tgu|$}`1GDt*thu(u}"	|GTTTTHOZY\[th"TTtUtE@@DDTD DCpDD@	thu%u""   "             ~	b001Xesa
+SN " |xvvvvT D DT@DTT`Dt5t~)T t~t
+
+~QDDT"p&T@Dtt2t			 
+			
+	t	t			t	&dT	t`t		tt		     		t		t		tt		t"`" >  	 m		t	tt		tt?t		tt		t3t	`"e&T@T"T
+`DDTttDDTTDDDTDtTTDDDTtTTt&T`$"ptyDTTDytyD"0'"x0' &x	 DD 0'"x0' &x	 DD "   "    rP4neveiL treknrrE 	 roewoPgnirwoD 	 
+newoPgnir
+pU   p `s" ]u{^uKt$tLebp^`]eaa]b^ab0" ~D    T]u^u  ~"+Tt_u"`u   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.blob b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.blob
new file mode 100644
index 0000000000000000000000000000000000000000..1559081fe5626bc93b54af66813a0c58a5d61435
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.blob
@@ -0,0 +1,307 @@
+222 222                                                 ?                    ?   Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs   -#   (  $  -   F0_+(.! !3!_:![:/.F Y!l! !b$! 9""!" i("M#,E ,"
+%% !D ! !!#3!3 3!F!Y! !    ! !(. ") "u/33@" u/@3P""0	00"(p"8BBddE"	sb8>- sti 
+d%9>-	stib
+d% >-	 tib7d% s-	 
+ib6>% stu 
+d`u q1CDuu~q -#~Aq$4$T4$ 4"tKtL   ""S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""C"uuu	" ucc0#
+0~/t 4 
+cc2 ucc TTT0T$Tpp$$pp$&E{pp$$r` 0TDD   DrT  TT   D(T %T  O  TT3 OT T OTTTOTT  OT?TT 0=r  TrD   r Dr T`TTT  OrTTOTOT`TOrTprdT	`TpOT*oTrpTOT+rTT`$`$!`$4`$=`$_`$dp$gqTTZ TQTDTpT#`"T+4Tc c2 ucc tf-@p\e`e_` [`ttY[Z\`[_[\M\t
+0D4T-0?*PuGV UVV%U5u`UVu U+V# UuV*0+PT?TTOc c24^2N_`D"c uc ft@231c c2ttTTdtTT?dtx@x)@xpx%xvxxT`QxAQT`xATQx`AWX$t 4,@ ,tAPtB3xTX`_T,tX^qT` xtH@3BW9` qx'@tB3TW qt`3B`d!TT6cR\TBT D"S	T`t$3_"S+0@TT]Tt3T_"uc cTf0 D  Dtfcc2uux vxMpM2uux vxMpM2uux vxMpM2uux vxMp2	 	`Gp""~
+$# t}>/$#'"(dPd?@u	 %3x@t$~t 33%5
+t%5 |}(@'('u" DD5T3%%4OT
+ " &"$ |4 ep"
+x; |=<><;p %
+
+;<<;`$`$N`$bu?d?P>?=TdE@$EE7%0tEEtE?%?d=P>>==-p=E>0?=E>=+` |>
+}0$?.@t?>=
+} |>=`?t??%@p<<; ~"0T`$p$nowp`$$`$4`$5`FpXT^"_,VP`$p",D,"@tt"T`$`$"G`Bkp$pepbT"p$NIpNT=pT"D,y"@t}peet	`etp`e"AFR LILAC_HP 
+G11Y9RV_22A_TP 
+ :LO 
+D%f}"9OtinID	 
+	 
+0 
+1D
+2D	xE	 tpec
+noixE	  
+tiC"TGTHOTJILKG"T%TTHONMPO"\[ba^]u tu_u+Q`!Qdtt|$}1tf f'tpdtp ~t ~1|}Ya|}fa111)tt
+
+		e
+
+		pGDDG"T0c(  |0| ~} DT DTttttT$t ""
+uu C(~"$~~- ~0~F_+~~(.~:~_[:~~/. ~ $~b ~~`t0 ]u^u" Xubu#aebp^`]eaa]b^aMb~"6 "]u "^u; ~u^u"] ~"@#]u"^u ~Eu"]u~"^Q _u`u  ""a    Iy@	e              0                       4?  @ H    ?              |##}~ Q	T0d# p@Q~L} |{Q~{~Q`d#d#!`(0!tt tt@tttttt`
+ttttttXttS"ttTTT<0?{ zxTT ~K3x3NO0T<{ zxTT~Kx 33ONT<0{ zxTT ~K3x3NOT<0{ zxTT ~K3x3NOTOT%TT"O%$'&(,T``$p$i(ty)[0@%UL$ 4t,'-$&'& 4,Ut*-U%+$-,\*](L)M+'$&'& 4(t%)%$4$$ ()` d0a8pd3#TT(OT333T3,OT""tKatL
+| T.0  `" t "TTt DTa D@DDTTT t ~ t~6t~LttT*OT	DTt	jtTV0?'0T%t$P _'TP|T't$l _'TlT'%0Tt$_P 'T&P'Tt$_h 'T_h     T'?%0Tt$_m 'T#mTt$k _'Tk _' R'T ['R 'T [     T"t$pT&d@.t/0T&0"" !AtaT D it
+*|t&tt,0t" t%tDDTgDD
+TTu$5u|x-<jTuTO-$<?iT-3
+$?htktRtQtR
+tQ9DD@DADDTBDDTtCt>DDTTTDDTTtUV[DTTD]DTTTD{|DTtDDDDt"xxxxxvxvtgtttp t@ttt@ t6"D   "aMA 
+nitinIcA 
+ 
+tON		TAM- 
+HC~0  T  !0 0_u"=`u 0T3T_u"B`uTu_u_uL`Q`u_u""G`u
+0  T T0/dT!` T!04xT% MT1mT`D5TT1OT 1T`oD5T T333T1OT/pd1)D?T@/TT1@D?DTDD{1T|OT1TT|OT/TT}O1TpdT_u"y`u@T1`,`2p_u"``uu_uu"~``u_"[u`u_]u"V^u" "Tu0`u_"~  ]u" ^u`t ~u^u"]p^ebea`]^a]bbaMc"cTu]u8^1	dTa`dTa`
+n^o_0 Tg0?T\0T1D00T1	DT10?T0?T1D@qcaDac 0n
+T1'DoT
+01DTo(0T1TDoT01TTccD00T1Dn0?T	0D1?n0T$01DT" 
+01TDT1Dccc0 ~u^u]43D~"&T	@D"T0$T	T0x
+$TxT`$pdjp~apdDVx=plfxppfx7@Dvx,x @t@	 TT33T0O4@D""            		D!XR		
+x%:			 d%XTx% :T	 
+siDxA	 
+-lib	 
+DC-SL 
+khDP		uaF- 
+tlKCA	 
+D-A-C	 
+KCXR		=MSF 
+d%-PN	tiaW		 
+SFXTd%=MA	 
+
+seR-		 01 >x 0 - s - DF/ DHS/ MEE/ P- Ed%:S 
+]u3^uT T  TDtxT/T$34 u xEOKattL  /T!TTDD"D(`tuuuu}xdTdddT  T #     ?T T -~p^e]e]`{q^Tdd0 ~Dddtebp^`]eaa]b^aMbdTdI0 ~#T | ~dff``df4DDddt_0Tx	
+Dccxxc	pTxct_xT TT333cOTcPrccTx0ccDvxtvc0?Txvxvc ?TcT xcTccTcTOcTOTcOTdc)0RTTCT| ~
+} $~x9>}"PrRDDCx"T tTl"r ~0. ~44vuxv#?TqtT Tu Pru%]u"^T?0'0'p ?Th T3DTOT3!TT3D TT  D)	0t,t	t,tt fT3D!TOT3TT3D  DT T)	0t,t	t,tt ET3%%T#3NT33T "O" ~xxvu*vxvv{kvyxlvvfulhgTTTTNT333O(T P ~}~}p MTT^MTTTNT333OTTTccO
+TTTq#c
+ c0?Tu'Prvyx'lvTcTcOT']ucd^uvux6vdTx
+`kMldE0Tk@OTklxk@u']u^kxl' wP@ry	@rdc cc0xxcpFTBD#T0?5DTTqTx%$3xx*4x!T#poT`5xDqvyx"lvvyxxlv*vwv"q'~%0+ D#?TqvuxLvcT
+0c3TT33T%%cOTucPrcT !tt]u^u#c T ~4uD^u%]0" ~#@D@Dkk@DxdT]u`3^udL0lkx]u2@}^u(x"kkTleepu`k^u]k3k@D " ~!Hvx$g$``$`gu3pkT(0lkTpNdgukTldpN
+gug`$gpN$j!y!p`$!k
+lkTTTNTTOT
+TOTx\l(T P ~~p `Nx6TTOT?TOTkTlx
+kl`dgklD4 ~ gP |DTk333TTccOcT  3TT33cOTfcTdx	0@ px>T-0?0T$ T0T]u@^u*#]u""^udT]u`3^ua  ~\xlk$f$d`p|`aap`$a(T P  ~~pNTNTu`_Of0T0 )`fu* TTu ffuf`$fp?`ap$a$`a`ou
+ounDnounTnn DnannoTTTooOT?TTooOTTooO%T%TooOTToOTnoDxKnTyx	no` TTO333noTnOT ~nff |dfEp 0T[noTcTnOTnnoTu& !f0TcTTnnOnod0nTeplFpkex@vNTcT4`of Tu$0^u']f T" kl"x ~yx1Tx~P x1T ~1T ~1T~0  ~1dTp0T ~ ~10?T ~ ~1T |]u^u-"TTT3T3T_uO`u  ""    rP4neveiL treknrrE 	 roewoPgnirwoD 	 
+newoPgnir
+pU   p `t" ]u/^uKt$tLa D@DDTTT^ebap`]ea]b^baM0" ~+DDc D    T]u^u  ~"+Tt_u"`u   "    PSA		d%:CGA 	d%:%:M H 	d
+d%:bA	 
+tsibA	 -tsiirTR	 
+gtiaWE	 
+
+tixCD	  
+011CD	
+000CI	 	 
+N
+DHTGA	 	 
+C% :P	 
+d
+CXEDA	 EB Ca 
+Rd%psd% :  
+{^ ^  o   oG %0+(<6GAVQ?LZU3b^jfpmmvszxA})|}~b  (0$8,4"<*
+2&:.6!>)	1%9-5#=+3';/7P?RQS,,,8-%,5.<9-5"<"33330d" ~2g  | ~|h	  ~ |i~  |j0 "j1T333iT3hEO~  gTOT0"1TpD]u"^u,0" {1zt ~QDpq
+0Cu)]u0"^1 {1oz ~cuQp?Dq0C
+`cpcD,]u""z^u$ 4 dpLp"T ~ ~Q|# }%$&%&#$('*)u 0u2u@13u 32@@ .,+,01@-3-@23%..//<=<==</?>*.)98*/);: +@t7@%+$ 4t6+7g$%4 t54%+/$ 4t67+ t$%4 t45;:3367RSPQ)1?>334S5QRP)1+ :C9B8A>@3?63S7QR1P):3;43RS5PQ)1 GFEJD<KI=HJKHIK1IJKHKC%B5JIJIA5@5HIH.H'(KJ=H<KIIJ1HJKHICKJKJBAIHIH@HI(/'JH8KI9JK1HIKIJ%KHKGF5J5IJIED5HIH.HJ8KI9HJKHIK1IJHGKJKJFEIHIHDHI/%1.++a-./+A,010313%32"A2(.'u%5")*u%5"('*)-u0+- -%,%@t
+++,+,+H@.,/+'(/,.'(+)*.,/)*+/,.0-@-{"@ z%$'&)()u *u(UP'T,$$% 4t$*)* 4)$** 4))%&  k" ~"A{k0 z}|Xt iH ~z{k0 |}iut)1p=Du.]u"f^pT% $433$%4 />$% 4"#N0d ~|#c ffpeeh#hu%ptgm%(l5mll$mfe>~Bk ~Bh$)%u&u ')(&'*+*3%R$SPQ)!/0-.0,u0/,/.00 ~+,%/5'*'$4&& *)+p)(("@ q ~iuhj!p:d`u:|y@	v{x v't	xy	t	t	t	tp8+`&=19k ~'Dp08 D~ t		txxx%x}$xx]uk^u/p"TDTtrstttu ~"]ugiuhjuu lul m$mfe>t<tGHtKtJLk& ~B1'"]u="^uststTpst""g1@.]u"^uu"]uu"^$&%#u'Q#((P$$((@%(%(''%&5#&@#h@ml)	phu**$)>h%(tgmmll5Q'0x&1/%$)*,+,,+p,,p++,,p++,/+,+p0,,p++"1%+$ 433RSPQ/)!-.+, $%433SQRP)!//>./-.-=,<,./u-4023112EB3B44u	p312 14023!14231 ~1%0000 ~x0SuRuPQ)!341244%435322115"2piml$$#>(tgmm%l5iulj$ml$p$u#>j$>$j#iQQQQ 1Q/0#$"Ag]u@e^u)"]u""K^u0ux!v vu"Pr.]u"^u'g]u@^u.0d"0 u"]u"^~`t ]uW^u-DdT p  0u.]ux^de ~`%-]uW^uTdp^ebea`]^a]badMb"Tdd"kTttgjihkg~tEeGgtt`k"t;t;1tCtt>ttRtQtR
+tQt<t=t<Tprtsttuvgiuhluj mu $"p
+`&]u"^uu(]uu"t^^u.]0" ~3"D: ~T T_u "`uQ ~u^u"] ~"W lu muiuguh^u"] ~"Kk lu mu]ug^u,l"m$>Mtlm $>Mtlm!$>Mtlm"$>Mtlm#$>Mtg $ % ]u&f^u.tg"m%(l5m"l|x r@ p	pE0xxI`~xpwxIx`xpw	x`pwx	x	`xpwxx	yx"xxxx$%}zx&60 ~{xx}$% ~xxyx@' uO ^u.] ""f        seT		 
+tteS	 
+puBL				 
+LOC	
+d%=G		  
+EBixE	 
+tOMA	SN NC	 
+DI D 
+ELWDC	
+TIADC	 
+AEM--- % 
+-C 
+DnoDDC 
+eGAIDixe-	 
+tESDCC 
+T-KPD 
+x%%:R	O  d d%:%:S D  d d%:%:P 	 
+Dctam
+deh   ~! x%T TMTT1OD{1T|OTDDTDTDDDTTDDT1TODDDTTDDTDTDDTT&`o ~T |TTTO  T+ ?T# TTTuT^u$]t" ~` "]u^u D   9 1 x  $ T ?TTup^u$]ebp^`]eaa]b^aMb0" ~  T ?TT0u ]uu"^^u"]0" ~!T@@T`oqpTu$]u"^TT{DDTTDDTDDT|DTTOTDDTTDTT DDT DTDtmYtttT`DDTDDTT@DDTT@DD
+
+
+
+	
+
+t		TTDD	D	DTT	DDt	  E 	 	dt`UtTpt		0	itpTTTxHuxwvvyxEuxxxxx/ux&et6yx"( ~T T ut`u_ ~"0wx`tDxxT   u0^u+]xC0wp%]u^u%]u^up^ebea`]^a]bbaMwx0" ~:0" ~ D vuxxvvx0uxv4vuPru)]u~"^s {t| tt6tttttDt
+
+
+	
+			t
+
+		
+5t	t
+	
+t	t	
+	
+	
+	tt		
+tt		t		tt		tt	ttt		tt		tttt*t	t			tt	y]]C	d]` P  Ct					StzBt					Rtt t	"		"	u%5%" &5 9%6~:&{ 9:%u4&3%')%&)3'3*/u)0u  &u21	1@2!%&11'(33(,+3!@[87$0/5:997*7) d3@ ,d+&Pd6d'@D88d5d'P ~~);d>Pd+5@d6'Pd'D858dd' ~~@TT88Nx`11%&-%4.837'3%4.@- ~'8T | ~8T | ~8T |~  |7~ -. 3+'(*,)?11@1~@ ~0%/501/3 ~"p788D%48837'	"	eu$4	"	eu$40" ~0Mvuxvz't{   A@u@rAz'{"wx#?T~B0U ~$$|#  } }ddP"#1$~[  $#'"0#Q"##@""@wxTux~_ "%'&u
+$5u-(<) ~ |} }dd1P1%x'%&5'	&)(&~"'g T  Tu_u""`B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t`t  ~T "      T
+  0?T'~epb`aebet'tp`ae^]^ebap`]ea]b^baM|xTtT l ~"C `Aq	T/T$34 u {xEO#;1tuxvvu"]u">^T?'00 '&lxY t! Tt!Ett-./T  Dt6t,tt Wt!T  DT !t-.Ett/t6t,tt ET3%%#NT33T3OT0" ~#&vyx$vDDD 0Tx x 	@pu^u']dT	`0uxv0vvuv^u&] 'T0#'1
+ vyx;$vzx" @ pvyx"$vDpTT|x#oT`p5D|xD12 ~#0?T ~8 ~:"!tAa TD t
+Y*lt&tt,t" t%tDDTDT
+DDTuT$5u-<
+TuTO+$:?
+
+T3+
+$	
+t
+`DDTabDTtcgDuT$5u-<jTuTO:+$?iT+3
+$?htktRtQ
+tRtQD9:T@DDADDBCD>DDDDTtTDDDTtT&$T`"ptDTDTtDDDTDTDTDTTtUVWDTXDTTYDTZ&D[DT<D]DTTTD0" ~lTTxwT0Dt`DtTDT1TOTTTN3TOTTTTTN333OTTTTTNOTbt^TOT#TooT
+`4D#TT^TO#oTTTTOT`dT>7`dvx @ "pu"]u ~>^TTD5"Tuxvvv""vDD']u"^u~0< tTTTT0Tu_u""`    001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tixM		 =LLD 
+d%`t ~* u!]uX^wxxv}xvuxvrw71T 0?T ru]uP^u-  T "     T 
+?Tu0^u-]ebp^`]eaa]b^aMbx"T tTl"	 ~q!]u3"h^u!  ~ TT xvv$TT3/ $4 uEOx~D DGDDHDTLDT pDKDGT 0TQ ' T#T`oQ'vx$v[TPrvx$vO$PTx#oT`p5DxQ ~#0?T ~ ~!@u(]u"&^#?T0'0'; &x( t!ttt8 ,&!tttt,8 ET3%%T#3NT33T"O!tAaT T DD t0t"t %t&t
+Q*tDDTDTtRtQ
+tRtQp
+p
+
+
+	tR/TT
+TTOT
+
+T	
+t
+
+DDT
+DDTD`DTtabDTctgDDTTTjTTOTiThtk9DD@DDADBDDCDD>DTTD<D=TDTT<TDDDDDDTTTDDDTtTDDDTtTtTd`P    ~Ct "	t  LdpBt "t	D$ttDO"d@~xP
+d"P~x~"w TTyxD  T d^  V  0?TJ  T/0T'x 1 ?T]uPh^u!}x"`u@^u(]]u"^u-U0"W ~x vwdvD'KDJDT)D*DT.DTtabDTctP&]u"?^uxxupF^u+]0"- ~2Q vwxvT*T-1TtaTbD@{Pru&]ux"?^Fx.pNuP^u&]u^u*]T4@D7]up^u('"D}4TTTOT7"#83"#"#"D45"#64
+T'0" ~ # vwxx
+vvD D xxPpF
+vx'@ O@TT TOT ~"Ox) 3 ~O |]u^u( " ~FA;vwxv %DDD'DTTT(DD'DT)DD-DTDT.DD/DT0DD/TT*DDt+D*1Dt3@D,TDT%T'-T1T4TDDTt5t64TDTt56T4DTD3xT33t%%564DTD@@t564*TGDDTHDLDTKDTDTJDTG&uP^u&]xx"?pF43T~@DA 78u^u*]v{xvs0"K ~x vw
+vD'D)DTT*DDT-T.DD/T1DT2ttaTbDct@&{uPr^u&]xx"?pFN]uPF^u'>0"] ~x vwv)0?TRDT0T"0DT D% DT")0?Tq3e ~xFx ~p!+]u"^u~
+|}T6@N.PTTTTMTTTTO&
+*"h ~xOT)*DTT.DT-T 1?T0tabDTtaDb3tctP&u&]uu"?^^u,]pTKOTTTJO0LT DTH0DTT"D " ~p}x#T&T`$"ptDTTDtD DDD DDTTTTT0OMHDTTJLDT pDKD&"uP^u&]_u"?o`uu&]utu?^ ~"~t?tDTTTt t0TE_u`u  ""            AGIG		 
+-IFLemiT 
+!rteS	 
+pu
+PW	GA	 	 
+C =G	  d%E	 
+ 
+CX0KO	O	 
+ 
+1K2KO	O	 
+ 
+3KCDA	E	 
+S-CXD% 
+::   D%  D% UMP	%  :%  x	 
+xKCOL	 
+1%:p	t 	d	d%:x:m :m 	 	d%D%:dL	 
+2KCO		 
+OL>-DEKCL	 
+3KCOS		
+:NGI d% KNL	 
+PUixE		  tLDM	d%=LXE 
+
+DPC:x% :d%  x% N 		1*#}QH@8|qf[3( xdP@      @
+
+
+	#t&T `d8x0	+ttt	&T 3TT33	OT			t0ty_	_d_C
+`P  ~ |	#t			t		Ct			 =p# t					@t					0"	t"tt		"			Bt ~"TtDt tTTT0T31t_u`uG0" ~x`|T~02~ux@uxvv|xt ru|xPu`^u$]]u"f^u$`t" ~W u"]u^tK0tLuxxyxvDv&\T|x@vT0 |xy~qPr (T`xTp  =4P(T @D" D5*
+	P]ui^u"  T "     T 
+?Tu0^u"]ebip^`]eaa]b^aMb"{OO {T3OD			0" ~#T~0~uxlO@	@	@~	PuuPr^u$]0" ~! vux"
+vux=Pr vu)v1P&TT @D|x"u`^u*]]u"c^u% "	t			tt		t	&dT	`tt			tt		tt		 tt	{{O}xCP%O{{OO@	 ~8 vux}vru]uP^u% " ~o>vuxv  v{dvC		t	t			t		t	&dT	t`t|x	t
+`	ttt		&dT		`ttru(@	@txN8P/70@~~6&pD1&dT`t/xD1Tt'D/T9P/1@~~6'pD&dT`tuxDTtuDT	P/	;@~3~6)pD&dT`tDtx&TtDT}	;P/f	3@	~L~6	)pD`&dT	`t?^	xD&tT`		t?V	DT^	x`dvwx	dv wPr)]u^uD	"u	"78$%&'		()f	g	*+}t##%x%/|uxxx-v@0Tx#
+v$$% x  #d#"p	D$56%&'( 		)*de	+	d""`
+	!T/0"D ~xvu	vT|x33TT3	OT	T	@t7@@			@fuP^u%]u"Pr	Du/]u"^~O""%}tx"@ `|@%}t"/et>""T}$T OTTt/}tT OT$TT}T@OTtt/}TT`0O ~"'", ~"%}t""@0" ~2vux2v 	 DTQru]uP^u%	"t&TP)?Tx0}@ t		t		 " ~VDT 	D		D	D	DT		T	T	T~t	vuxv	QT D dx@x  t  xT pp`xN|>P5P	,P}	P#/t	 ~  ^x   p   $ 4 vxxvFapp ~ bx@
+ `xD/t	      p ppdi ~   E  	 t		vx@ `p$0ppp$M0pz`$``OPxp}D*DT	T	 T}xT O@t47x?T&Pt45T*Pp~xDDmT	T ~x	TT O@txT&?PtTm	PxpDDTT	x	`T@OT@tx	&?TPtTl~	@xc^`DY		D7T	T@x	TT`O@tc	f	xT&?Ptc			dT7Y	Tu(Pr(T
+`d p]u`^u/]u^u6" /E  /	/ d@"dP "~*0J uxvv	D	xD	`|	 DT)TL0?TPTTTTO~TPTTTOT~ux|2} L|x&pp	PTaT
+PT	uxPr`|u6]uu"^^u*]0" ~P vux
+v
+xT)T0?1uPr)0?T]u1A^u1"u"u
+#u%u$``p$TtTT%t$ 4t#"T@Bp9P%6$TTTT#K"TTTTKxI@P@
+d7%2p$TTTTK"#TTTKT%% t5%t$$#% "5#"`dA10"l ~T	@D	DT	D	`DT	@D"	m@D		D	tT		u~	s rr ~rsrsr ~ssvrv	DT|	Tz	@DGTTMKDT Pp'`  xP p| pu%]uu"^^u2]0"6 ~W{ttDDtTTTxxvvx"xxvp30~~x$ ~x ~x~	 	 ~x ~x$3xPxdvu4]u\#^x ~P xdtxP9xxPx*dP]u^u%t				txTdxpTOTt%T%OTdxx$p$TTTtOTT33TxO?x$x"0xTDpT333Dt"T
+px333DTDxT333F " ~xxvxv$dxd
+@$xxxT$x3$T33T$$O$T33$T3T$$Ovux
+v \pu5]u ~^uPru%]u	^t		t	"  TTTOxx D0" ~TT@Dx"%p ~xP[]u^u5xKP)3TTOT.]u^u%t				tTxTOT0" ~	u `u_tuju"]u	i^TDD	T"Du#u"uT7$  4@t	$%T!#"%%5%t$$#%e"5#"?TuT $ 4 $@!"`|x<PP$}4D$4Tt>/"~0 ge- pg	3@tue7$e4$3x- g@	~8tg!	%g$ 4d!gd%	ue$e43-    g$% 4d! d	tgg*P$% 4x'tg/ 4gjut tx`dgMA(T"`$'p$}teu/t .-  - (T u- 9TA0- M} |- eMAeuN$4jN@HPuee%j!$!4t/5j-!Ntj/' 4
+tjut td%d$ 4 ddTP'td/ 4Ep%d$ 4 -ddPdjd$% 4 dd`djPj^@dj @pd*e8peuj$%!!4/t5!j-^j/'t 4tn ~dd-'t 4 | ~|d %d$ 4~ dd@- gjuet teu^u/]T0T""ART	 
+KCIPL
+x% :RT 
+		 :_DAB GISd%: 	 
+ :d%	d%  d%   Bd  D%  mpp D%  CGA D%  tiB D% --		
+---S		 d% :		 
+% :W	 
+d :A	 :d% 
+d%7f		t$Ap  ~lknmpo q x	D DGTQT%STGUattGTYTG]0Tu$4uT$k4_ittkmtothjlnDl&(D  D%TTOtKtL j vuxPvu)uu7mT1?T0TmTGTlMN  	 }	 1TL0? jFp`TpoP ?T%0th`t	 tThM7t)tDT1OTTTTTNOT3TTTN33TOT3TTTTNTObtp TTDDuPrguehuuNiujufvuxPv`jq   T =7  /   T %T ? Atppee8tc	`)@VP5Tu5DtTikm~o   |~_`[`"\' ~ |e	TgT3TO%e|$ 4tu#"g%pp`$C`p`$~?- "#
+te/ 4}|Pf~f|1  %e $ 4xx+:<-pe 8 ~p ~ae@-}tue
+$ 4TT | ~Hu0
+%$$#P%T$	OT ~#P"$$g3} |ggepppopoEp~q% g`de$T3~eT efzpTTT!O10?T ~n]m ~lfko ~ |q~x op ~Tkmljn- t7)tGDtj	" tT7pT	f	"	ft"pe7e)tt`pee+t`	$(@trsOPr's|@rs	@rjs~	X@NPP(GP(	P(}	>(5P7-@$@	@f	@x rsOr6@s$@rs	r@s	~P NP(P(	P(}		( @	7``		`pf
+ x@tx@OT0DT ~ ~ ! |~! 	  | ~
+ ! |~% ""T$ T% T T~ ~Tp"	TT"#
+pTTT}}$%CC#TmT
+`k4Dn%33dT3do$%%NTmTOT#$#hTpT$"TO$T$TJp$""0TTDxthBtlxTh1?TA  kAppkGTDmtlxxb>pTGDHYu[DGmTtll0GTDmtlvxx@D
+DTTxxT}8x6/pdlx(0Tx!` v` @ 
+vAtqq x`j waUjt- papNw  	 }	 |x>`d   .	 	 t`Dd  T`D T	D*.	 *	TD		 	T- "TxTDD t"Tx-pTDT` @t xAqv8u""AuthtlxThd'T` 0luDT0D	D	tD		
+tt	TGYHTt	tmvxuu2ux"+`7Tx.pD`@TT0Dux"@vTxx`"vxp|xT T0TT D0TDDT0T0pT	00jj0t X DT0TDTDt	tT	Dt			tt		D	Tt	T2ttmtlxhTlTx`@DD
+TT Txx`0jj+0THt T0DxTq@vpT	DGT@tlTG0htPptT0xT`pvxx}80 tD""T "0TDDT	DTTT Dt	`tD	 DDTGTthx GTtmltuu)|x"7U`D `,n00TDvxDTTTh0@DT,u"ut	UTD n00TDv	DTtnn
+ j  T0TD0j Wtt ppt 
+Z 
+DTD0TT T0DDDT 0jT0
+T.0T	p	0j TT0j $GDT0DxTv
++t t	6tDTT D,uu0TTtt		
+t	DT	t	t		tD		T.t	xtQv.mttl0TD"T DT"$TdxTh lxy:p'TpTSxt	|t`t	t		tT		T/x8`pTT#0Dx`@DTd`d7t7Apee)tupDTT0Txx&v	Dvnxt`.pTxvh
+ xxvl0v	T0TDTpxD[tx$t`h! vx n 0TDe+t2tp`exup/T0Tx	nv0T0DTx`DTDTTx ,Th0@DT lWn T0T0TDTt`DTDTTt, Th0D@Tt	@tmnjGu,Du6vx x"
+tt		t<	>t	TGDtmlpvuuu5vT&0T"Dt +0TDTx" nh0`x7v0n"T0?T0DT0TDx`TDTxD ,Th0@DT	@ttmnjG,Du6ux"vx`f0	<	>	Qt	2 t!&t0nvTatAnt~	) ( @( 0lnpntmx@ &tl"plkT~0 /~xx`0TTDTTTu`6dt&
+tt			tt		tt		DvTd   .	 	 TG	tt		
+T Dt			TDt		tt		xt|t`Cxt`|t6TDtuu/x"uthjlnp`p"T0TTDTT	Dt	`t0DuxT	TDTT Dp- p!N  	 }	x >`|d   	. 	 tD`d  `TD T*	D.	 	T*	D	 T	- GTQGTUGTYDH|x[t	``tttDGmtlGT]uu+l  x""v    taD		 
+aLoL	x% C	
+ 
+% :A	 
+d% :L	 
+d% :P 
+ D :S	d d%	 
+B% :Fpp D	 
+m  :L
+ D%:D	 WT	 d% :T	 
+% :Q	 
+d :WR 
+d%:QR	
+d% L		 RCSo 
+d%oL			 
+SDAB	GIS_t 
+ ~q` xxx~ulbu&u(uuxmDtl10?T-TGmtTtlx0x0xQLp ?Txz{+p7GTtiThtvxTM`DtTD1TOTTTTTNT3OTTT3TNT33OTTTTNTObt0x xNOqexttp`e(xAc3t4@7u*P ~c ~7 |8 $>0x10xt(t@t,tP`xcx~xx  T 4.  &   T T ?pcet,tp`eaT0DTGTTthlT!TTT!`t
+tRQtTTTDDt<T5D[~`_\[mi0"xxpd`F#de$$x#x#$-%<$$##5x!|}$% %@%TTT!O4@DT7~&x yp~ &8 ~x#3, ~ |%~7 #$&@"dxpF ~GC4T"T"4OT ~G78"
+"P@dxpF ~PM4T D""TT4~OG 78""@K ~xfFd]p0x0 ~JxQ~xZ  ~xc~xl x" ~W@xux@"DDD DDTTTTTvx vx!`FxpFpP0OxP~~
+@ ~xN<x@~@ "x"th0TDddh!0DGDDuDu&P}"|GT%T%THORQTSthE"e|}GDu'u"?0TTddht TGth,0ht"th Eeh0t"0TTddddS(TTGTthubu&#"T0?,tTRTPduE$}e|DG'u"uT0Dddddth xp^'0ht,xpdpd&SGDu&uxp"#0?T,8tRD"DT0Dddhlt hz!TDTz!T`db!xNOQguGJDDDDTGpTKOTTTJO0LT DTH0DTDTmTtl1TDTh0aTTG"DGT@tllufuu+`T
+T1"DTTt`DmG@DDHDTLDT TJKpDGD	tlTtJQ<GuDu(}"x	|GTTTTHOZY\[l"tGDt'/tt-%tTTOT%tt-'ut$}`f|PQDG*ttl-u"uT0Tddddxv laIQ`fiolgtt`i=DT/ttl$fgfPPp
+`TT11m"Dl0tfpf"0TTddtlx0vt;*D-Dt`#0?Tt,Q0lQ62TDTT
+`T10lfVtgf@D*-Dt`ft.ppee+t"p0l#0?Tt,A`"tTaPTNTaT@*TT-u"u,T0DTDDp`pthlHDTTL DTJpDKGD#"T0?,x8tupJQ
+fGDTGtItl	D'tTaDTTT=OtmTu*u"0TDddddvxltt	00(lt0fxppfl0Qif""   "             ~	b001Xesa
+SN " "t ~ ?T 10?Tft~v}xvvv D DD@D`t6t)xTT TTP)T0?xv%`=`$U`opt~t
+~SOt~t
+~4`t~
+yt~m|t~t
+iz~xqDDT"p&T@Dtt2t0.TT
+TTOT
+
+	T
+
+
+	
+
+	
+
+		
+		t
+t	
+	t
+t	
+&Td`	t	tt		tt		
+tt		t		tt	t"`" E  	 t		t	tt		ttt		tt		tt		t`"e&T@T"
+`TDDTtttDDTTDDDDTtTTDDDTtTTt&$T` ptDTDT"t""'0"x0 '&x 	DD '0"x0 '&x 	DD  ""            001	esab 1T- 
+SN  ~"        P~~1_YH1_5VI_G1RV_P2A_98R_2434  ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.blob b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.blob
new file mode 100644
index 0000000000000000000000000000000000000000..02b88a078b85fbf73a4e0540ada7d49ea6287cd3
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.blob
@@ -0,0 +1,215 @@
+N 222 222T"               .                       ;	   uNuu~Q"~!  "   Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs Q"#%%&&(!(!'|$ '3!F!Y!|$!''l&!! !#  "#$z.% !"#z$.%!X !"%!X !"%C & !C!&!%y  %3!F!Y!y !-'-'l ! !m`u1TQBQ4[DTD T qDC"   "    "S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""C(. ") "u/33@" u/@3P""suuu"$4$T4$ 4"c uc $00 ~/t 4 cc2uc c HH@TTuI $@4tI% pI
+HT0H$Tpp$$3pp$;a|pp$$p`$T%0$5DDD0TT*%TtNI%rp ~~3TTTNTT%rt vID TTMNTTTNTT?TNTrtI%` TDD$5~T~` TTTN{`$5
+p$5
+I$d`p
+pI{(Thh
+T(OTIpT/oOT.TnoT/OTnTT.OH$T$$`$G`$``rpT!$5TD $5T3p
+!`$I|4$5TpI
+c c2$5T" ucc Ju Ku te@@eSpQPeR` X`XSPRCQT0TKJPLQ@@[e]\p Ze`bb\`[]ZD0TTJKZL[|t
+0D4
+0tDt1c c24^2_pNt^r_`ND" ucc te21@c c2ttTTdtMT?Tdtx@Mx@NO$4t *@ t*PtA3BTA$%4TTOt`_*kTOQM`xtP@3BAQN`xt+@3BNT`Qt3
+B`d!TT6RTcTBZD"S0)%3t3/>ttT3_%33/t>tT^"uc ceT"0D D@D D! !tecc23hTTtHt/>	TMTM%3	%5	q"$5$T$(`F`$R`ap]p$5T	"p<d$>5T	,"@Dl"@D$5"
+$5q$5$T$`?`$K`\p$`$`$`Kp$	`	@p$5"@D,l@D"
+$5"BT0/t &   |$ 4pe"T |>=@?>=p W%
+M
+>K=K>=$$N`$b``AuHdAPM?@AGTd@7$GtGG%0GG%tAA?dP@@?-?E@p?0@A+`?E@?
+} |0$tAA.B? |@
+}?@`A%BtAA>p>"V=! ~L	 	`Gp"" $37T`"2YHPV_F2 
+9RLOTPD% : 
+9Of}""PZQT[^UV_`WXuaubucuYRuuSu]u\1$ ~\  Q1}1h|}1a|11` Gt"pDGGD"tt ttD$u$ut ~"#%~%~&~~&(~(~'~~|$'~$~|'~~'&~T0c 0 | | ~}(LC"u Cu"TGTHOTJILKG"T%TTHONMPO"xxxt0tt0tt t tt6D  ""                Ix e                                         ?  @ H ?   :<fC  x333 $t>&%} |1$3r$$&$|%5{H} 1`d$d$!`$&`(%5x 3ThHT/tt>t/>t/tt>t/>t/tt>t/>t00?TTC0T0C0TC ~3x3&$%5TTNO&% DT'")(1*$22(15,$251T`$ep$+0y,[U@$%H 4/t*0*$4)) /Ut-.0U(0'/\]L-.+,M**$4)) t+,$(( 4''+,dA` 08$2513pdT32($15TOT3333T,$215T"Ot  $  ""niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN RA	  
+se>-		 01 F- 0H- DE/ D- EE%:SP	 
+dCA-C	 
+KFXR	%=MS	 
+dW-PN
+tiaT		 MSFX
+d%=bA	 D-li 
+ 
+ ~\VuGWu `X" ~\ u VuYu|WeUpW`VeTTV	uUWTYUY`Y" ~\T   !0 0 T0TTdT!)p!D[e$ttp`Ze)tAp_e^etA`uRu"ST@ ~\uQSuRrx"V
+  TT 0!T a %T OT1`mT5DTT1OT 1oT`D5 3TT331OT1`TpQuRu"SuQSuRVu"t|Wu  "T
+0uQSuR$"z ~\Td ~d!\0	dTza`dTza`
+x^_0
+T1'DxT
+01DTx(0T1TDxT01TTddD00T1Dx0?T	0D1x60T$01DT 
+01TDT1vrx ~\(x1xT ~P0x\10T ~26 ~\10?T ~: ~\1?T |dLD ~"dGvx\x`$$`xpxv0TTd	pN
+vxxx5`$?p$x
+ TOT
+TTTOxxdx`4~ DxO |L xDTT333dOTddT  T33T3TddOxT ~"[x\xx`$G`0$D`=p0vx1T xvvxT vvxx$$%`$`x7p
+vDx
+vT DxTOT ~xe | ~Lqx\txvv*vxxxvvvxlghhgTTTN3TT33OghTTdOTd
+TTT""        niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN DI	  
+ELeRA		 
+s >-	0 01DF- DH- EE/ P- Ed%:SC	 
+KCA-		 
+SFXRd%=MN	 
+aW-P 
+tiXT		=MSF 
+d%ibA	
+D-l~ 
+  \ `u`"au`b  ~u\au `cuae_^p	``e^`cu_a^_"c`c ~\T!0!!!!02!0T2T`u")auRT@ ~\1u\ux"o]s@
+T @0T!@ TaT%@OTqmT`DuTTqOT@qT`oDuT@T333TqOTqp`1\u"]u1u\uu"~]au `"T@
+01u\u"] ~$\`c! ~\T! u `u"aTk ~k(\pIdTza`KdTza`JHx^_0
+Tq'DxT
+0qDTx(0TqTDxT0qTTkkD00TqDx0?T	0Dqx60T$0HqDT J0qTDTqvsx ~\/xqxT ~P7x\q0T ~9= ~\q0?T ~A ~\qFT |kLD ~"kNvx\x`$$`xpxv0TTd	pN
+vxxx5`$?p$xJ TCOTJTTTMOxxdx`Pt~ DxV |L MxDTT333kOTkkT  T33T3TkkOxTH ~"bx\xx`$G`0$D`=p0vx1HT xvvHxT vvxx$$%`$`x7p
+vDx
+vT DxHTOT ~xl | ~Lxx\xvv*vxxvvvxlHnoonTTTN3TT33OnoTTkOTkJMTTT""        inI	 
+0t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2 T$0u$  TTDbDDTTT~1  ~1+t(@DTEtt"j0?T+'01X:Xx1x')01QQ1a1a1pp1&"Tdt@.0/&0T ""	 p ~"\ " vvxt!t"t!t#'tt()t*)tt$%tt+-@tt&tt!'t+z{Qz {xQuttuQ@z {}QT$@DDDDDTCDTDTBDT@"DT3O`T./0."xt  t0t"t %t&t
+*!DTtDTtttUttVWtXt\t_^]`Tt     3:t;<=tt	t8tt76ttu0xTT333DvT/TTwOt0tttttTT`d
+ P~|M L tCt BttDDttDX" ~`%Vu\uEWu Yu0Wu&VeUpW`VeTTV	uUWTYUY`Y" ~\# T T ?T0DVu Wu%%Vu""Wu`Y, ~\DTT  VuWu&pY"~I5 \ xT% 3TOT0TO0Du1TvOTtDyDzT`oT ~B;TTzOT  T' ?TT yTTVuWu& ~"\FuSuR ""            inI	 
+1t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2@T!0u$!T@TbDD DTT~T1@~1`+tH	hDoT		
+tt	"jt?T+0g0X1X:1xx)g01QQa11a1p1p"Tfd@.t0/fT0""  	p ~" !\vx"N	tP	tQ	P	ttR	V	tW	tX	tY		tXtS		tTtZ		@t\tU		tNtP		tVZ	z{ {QzxQuttuQz {}@QTS		DoDDs	DT	TrDDTq	Do	"TDTO`T3]		^_	]	"Axt@`t0tBbE tetFfJtjaTDtDT )	(	'	*	t	&	tt	t	t	t		tt				.	Tt-	,	   	  -,	b	i	tj			ktl	ttg	ttf		tetpxT333DToTTOTtt0tttt>	=	TT	d>
+`P M ~ |E	LCtG	I	K	t0	1	2	3	 tE		B	G	I	Kt01	2	3	=	DDtM	tD"~`b `u\Bau%cu0!u&`u_apae`e^`	`_a^cu_^c"c ~`#@\ T ?TT0u Dau%``u"au%`c" ~\,DTT!u au&`c"Fp5 ~\@xT%3@TTOpTOpDTqOTtDDCTAoT ~`;ABTTTO@ T' ?T TTCuTau&` ~"F\u\u""$]B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`X  Vu\Wu Yuv&~PepU`TeUet&tp`TeWVWeUTp	`VeTVYuUWTUxYT{ tTl" ~Q\1#T/T$34 u zxEOtxvvutWu!V"?T0'0'c &xP t! TT  DT"$t,TDTDTTN!t  DT Tt"$T,DTTTDT>T3%%#OTY" ~#`&vxx\$vDDD T0wx 	@ pu&VuWT	`d0x0tvvvv	u%VuKWT 0#'
+ xx1vvx"$ y @pxx"vv$pT{xDT#Tpo`D5{x1 ~\2#?T~08  ~\:"\T D It
+*\t&tt,0t" t%!DTDTDDDTt
+ttUDDTtV0TWDtXxD\_t^t]
+t`Tt     34Tt:;	tt<=DD8DDuDDDTtTDDDTtT&$T`"ptyDTDTtyyvT0x33TT3vOT/TTwOTttItJKLDTMDTTNDTO&DPDT<DRDTITD"~;`Y \DD D5DD4TTvx0TDt`DtTTTTN3TOTTTTTN333OTTTTTNOTbtdT>`dTx7` u @pVu"Wu! ~\TT5D"Ttxvv"vv	"DuDWu&VY" ~`<\tTTTTurxSuR"t  It
+*t\&Jt+tt,t0" t%!DTDTt\tt_^
+t]t`tt     tt3:t;	t<ttt=	tt8ttItJKtPtRtIuTvDttt ""B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`b  `u\au cuv&~Pep_`^e_et&tp`^ea`ae_^p	``e^`cu_a^_xcT tTl" ~Q\1cT/T$34 u xEOxvvutau!`"?T0g0gc fxP Ata@TT` DT"$Ltl0DD?TDTD NatA@ DT`TtL"$Tl DTD0DD?T	mT3%%cOTc" ~#`&vx\$vDDD@T0x 	@ pu&`uaT	`d0x0vvvv	u%`uKaT@0cg
+ x1vvx"$  @px"vv$pTxDTcTpo`Dux1 ~\2c?T~08  ~\:"\AT@D`ItJjF\tftLtl0tBbE teaDTDT DD&	DT	t)(	'	
+tt*		DDTt		0TDt		xD	t	t		
+t.	Tt-	,	   	  -,	b	c	Tti	j		ttk	l	DDg	DDDDDTtTDDDTtTf$T`"ptDTDTtTpx33TT3OToTTOTttx		tyz	{	DT|	DT	T}DT~	&D	DT<D	DTx	TD"~;`c \DCD DuDDtTTx0TDCt`DtTTTTN3TOTTTTTN333OTTTTTNOTbtdT>`dTx7`  @p`u"au! ~\TTCuD"Txvv"vv	"DuDau&`c" ~`<\tTTBTTusx]u\"$At@`ItJjtF\fJtKkttLltB0b tEeaTDDT0Dt	t	t	t		
+tt.		t-,	    -	 	t,tb			itj	ttk	ttl		tg	tt	txty			ztt		txDTtt"t   "            001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix ~ \	Q!Vu"OWu#T?'00 '&Kx8 t!TDTTDT6t,t6t!DTTTTD6t,t>T3%%T#"O~}`Y \T  Tvx$vT/T$34 u EO|xt0D@D DDDT pDCD@T 0T ' T#T`o'vx$v[TPavx$vG$PTx#oT`p5Dx ~\#0?T ~ ~\\!@kQu&Vu"gWGdx@
+|P"dP|x`Y" ~\;vvxQLuPkWu"Vvx"/p@t. ~A12%VuLx;Wuvy~"vw \TxwD  T#0Tx PkQ!Vu"OWu{xkQ`Vu@Wu"'Vu""Wuh ~\xG}#T$Dt(T'V7ttWXtPkQ"Vu"Wuu$Vu"W~H`YW vx\dvt!CDDBt#$DT(t7tVWtXQtuPkWu"Vvx"upWu&VY" ~,`Qvvx\$T'TT+7tVtWr@kQyuPaWu"Vvx".pFPu#VuWu%Vu;W.@DT1upWu"V"t!T}.1$2$%3%$%$D.$/0%.
+t!Y" ~Z`p{x\&T`$"ptyTDTDtyy?t*tT"PkQu"Vuu"WSuR"VuuWu"X~Y`YK vx\
+vt!t#T$DDT't()Dt+,ttV4tWXt@kQyuPaWu"Vvx"pFPu#Vu"W~*`X  Vu\Wu Yuvxx{x}vtxvvvx` FT0T ?tuPaWu'VPvu'VuUWpWeVeTV	`UWTYuUTx"YTtT l"~`Y# vx\x
+vvD  Dpvxx
+vN#@ G@
+T OTT OT ~"x) |~L3 G |"VuL"Wu;`Y] ~x\vv)0?TPT0DT"0D DT%DT" )?T03G ~Lepvx ~\!u#Vu"HW}~
+|T6@F.PTTTMTTTTTO&
+*~"~ \tt?DTTrx tt>Ru"Su   "taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	"" 
+`X" ~5\ D DD5D4~xxdu|veu u fuwg`DtTDTTTM3TOTTTTTN333OTTTTTNOTtb@vext"tpg`fe ewttpg`fe 1!q@wPTGTtfhTT!T!TDTDTTDDTD5~RPS0"Qwaxpdx`FAYZ%&x%&%&x-<&&%%5F%}q!|&' ''@TTT!O.DT@(1 ~wxpL ~(2 ~L|GL * ~ |'~L8 %&(L@"wadxpF ~G\G.T$T$.OT ~N12$L
+$P@dxpF ~N\T.T D$$TT.~ON 12L$$@R ~\F	@<[ ~\""@f ~GxP|~@
+o "\|x)"*dPd?@u	 %3|x@t$~t 33%5
+t%5 |}|*@)*)u"    "001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix`c  ~\;vxeuPau"`x"/p@t]	 ~A`		a%`uLx7auv"vv	dx@
+P"dPx`c" ~}\@TT`xvv$TT3/ $4 uEOxto	DD DTs	 Dr	pDDTo	T@0Qg  Tc`oTgxQvvW$axPPvvv	$x$PTcTpo`Dux ~!Qc\T0? ~\X`u@cau&c"?Tg00 gKfx 8tAa?TD0DDT DtL6tl6taADT DTD?0Dtl6tLm	3%T%Tc"Ow ~\CTxD@ T#0Tx `uPau x"`u@au ``u"au' ~"\	Qj `u"auh ~\xv	R	TS	DtW		TV	7tt		tP"`u"auu$`u"a~H`cW x\	dvtPr	DDq		tRS	DTW	t7t		t	tuPau"`x"upau&`c" ~,`Qvx\S	TV	TTZ		7tt	n@uPaau"`x".pu	Pu#`uau%`u7a]	@DT`	upau `	"tPT}]	`	$a	$%3%$%$D]		$^_	%]	
+tP	c" ~Z`px\fT`$"ptTDTDt?t*tT"Pu"`uu"a]u\"`uuau"b~Y`cK x\	
+vtPtR		TSDDTV		tWX	DtZ	[	tt		4t	t@uPaau"`x"pu	Pu#`u"a~*`b  `u\1au#cuxxxvxvvx`@BT0CT ?uPaau'`Pvu'`u_apae`e^`	`_a^cu_^x"cTtT l"~`c# x\x
+vvD@`Dpxx
+vN#@ v	@
+T@OTT`OT ~"x) |~L3 v	 | `uL"au;`c] ~x\vi0?TLTB0DTb0DE DTeDT" i?T03? ~LepxX	u#`u"Da}~J|FT	6@u.PTTTMTTTTTOFfJj~"~ \tt?DTCTsx`ttm	\u"$]u   "        taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	"" 
+`b" ~5\ CD DDuDtxxkuvlu u muwn`DtTDTTTM3TOTTTTTN333OTTTTTNOTtb@vext"tpn`me ewttpn`me 1!q@wPTGTtgiATTaTAaT-	DTD,	TTDDCTDu~\Z]0"[waxpdx`FAYZ%&x%&%&x-<&&%%5u	%}q!|&'`''@TTTaO]	DT	@(` ~xpL ~(a	 ~L	|vL * ~ |'~L8 %&(L@"wadxpF ~G\G]	T$T$]	OT ~N`		a$L
+$P@dxpF ~N\T]	T D$$TT]	~ON `	a	L$$@R ~\u		@<[ ~\""@f ~	vxP~@
+o "\x)"*dPd?@u	 %3|x@t$~t 33%5
+t%5 |}|*@)*)u"    "				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT 0dD4 ~\=u$Vuu"WWu'VY"`ex	0@ px@T/0?0Tg&hT T0u Vuu"WWu V"IT`du$VuYW`xKpd Te0xTdTTOhg Tvx+%!`YTdTTxOhge i!jTijxpf[pfx@vhjiTd`oTxL 0TVu;PWu'dx.pT d d#``D4"jixxY"`#dKq d
+T'0?tx'PavxdlvTTTdudOWu$Vx)vt6vT`dxxWeO0jix@TTiOjfpxpf@u'VuPWjixx '7aavx	@@aJa0ed}xw Fw4p#0?TD5xVqT~%3$wx*4x!T#Tpo`D5xxQqvxx"lvvxvxlvv*v'"KqT?0'0'_ &x L3DT!tt  8tt,tTTDDTTJ3DT!t8t  tt,tTDTTDT>%T3%#OT`Y" ~+\ t#?TtxVqvvvzxLvd0Td3TT33Td TTOTTddOtPadT !ttu VudIWT az ~P)\Du!Vux"Wvz"v~5`Y tx\v4v#?TqVtTx r TtuPaWu!VVu"Wu$TT   TDyDTTT3/ $4 uE~xO%`Xuguiuhju|x*YuTeeeTe@v T~ 'pWe`VeV/WTee~!0  jiLDeetWeUTp	`VeTVYuUWTUYTee0T ~,# ~EgheLeDtT0Tx	
+Dddxx	pTddxTx|x@add`Td&0}x @ xdDv|xdv ttTx T333TTddOdTdOTdTTOTddOx"T tTl"$`Y5 ~\DghDx@@DxdTVu`Wu$eQ0jipfxfxpu2@Wu Vx"nxTjipf`f$VuxWu@D"TRu"Su   "            				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT. 0kDt ~\=u$`uu"aau'`c"`l3x	0@ pxM@T/0?0Tn&oT PT0u `uu"aau `"IT`du$`uca`x8Kpd!Te0NxTkTTOonN Tvx+%!`cTkTTxOonl p!qTpqxpf[pfx@vhqpTk`oTxL!0T`u;Pau'dx.pT!d!d#``Dt"qpxxc"`c=kKq k
+T'0?x'PavklvTTTkukOau$`x)v6vT`dxxWlO0qpx@TTpOqfpxpf@u'`uPaqpxx g7aa	@@aJa0lk}xw F4pc0?TDuxVqT%3$x*4x!TcTpo`DuxxQqvx"lvvxlvv*vg"KqT?0g0g_ fx L3DTAatt@`8ttLltDT0D? DTDJ3DTaAt8t@`ttLltT DD0DD?Tm	%T3%cOT`c" ~+\ tc?TxVqvvvxLvk0Tk3TT33Tk TTOTTkkOPakT K!ttu `ukIaT a ~P)M\Du!`ux"av"v~5`c x\v4vc?TqVtTCx!s!TuPaau!``u"au$MTT!@!TDTDTT3/ $4 uExO%`bunupuoqux*cuTlllTl@v@T~ 'pae``e`/aTll~!0  qpLDlltae_^p	``e^`cu_a^_cTll0T ~,c ~EnolLlDt	0Tx	
+Dkkxx	pTkkxTxx@adk`Tk&0x @ xkDvxkv t	tx T333TTkkOkTkOTkTTOTkkOx"T tTl"$`c5 ~\DMnoDx@@DxdT`u`au$lQ0qppfxfxpu2@au `x"nxTqppf`f$`uxau@D"T\u"$]u   "             DC	ELDIC	 
+IAWD	 
+TEMDC% 
+AC 
+DnoDDC 
+eGAIDixe-	 
+tESDCC 
+T-KPD 
+x%%:R	O  d d%:%:S D  d d%:%:P 	 
+Dctam
+deh`X DxwvxT  
+u0Wu&VxA0vp&VuWu&VuWupWeUeT	`VWTVYuUUTvxY ~"\3uvt t ~ Q~Qtt5Q~ttttDt 
+					t					5t	t			t	t	
+					tt		     		t		t		tt		tt		ttt		tt	ttt*tt								tt	t]	]d]>`P   t		C			StQt		B			Rtt t"}%$/ t>%$	"			"~/`Y tx\vvQut  a@ t@aaQu$%%
+0q$$%vxbT;0?& ~& |%} }dPd%&$ ~L &%%@$$@vxTtx~ "\('  78(;' ~<<;L;u'65'(()'3)3,1u+2u  (u43	3@4'(3)*33*.-5@X:9$215<;;9,9+ d3@ .d-&Pd8d)@D::d7d)P ~~+;d>Pd-5@d8)Pd'D:7:dd) ~~@TT::Na`3'(/%60:595%6/0@D ~: ~G:K ~F:Q~EW  |9~L] /05L)*.+-3,3?3~@@ ~2%5211"3~!p5c \:9D:6:5%9:"u%5	"	eu$4"		u$e4"~`Y  "\~ `Y
+ tx\v vvwx04vtxvatVuPWu" ~"\'TT T! u!SuR'")(u
+$5u-*<+| ~ } }dd1P'x|))%(5	(+(*) ""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.blob b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.blob
new file mode 100644
index 0000000000000000000000000000000000000000..eeab2ab2b577242d14901f851608f53ffa9d61ce
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.blob
@@ -0,0 +1,235 @@
+A222 222T"               |                 
+                    ]             Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs #  #  &  &  ("  "(  }(  (!!} !  !R-   .3!3!F!  !O-  F.Y!Y!l!  !,  l,!!!  !/ ""#   "T T  u!u !    3!F!Y! !  l ! !((. ") "u/33@" u/@3P""BBddE"tpptsht`usG`uBQq4DTD T t2q3CDuu~q#~=Aq$4$T4$ 4"uuu"""   "    "S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""Cuc c 0$0t ~/ 4c c2 ucc  uf@TfTug$@ 4g% tpgf0TUTfqd 	7u  T&0$5DDDT*0%TNTg%mt ~~pTT3TNTTmtvg%  DTMTTTNTTNT?TNTg%mt`T DD$5T` ~~TTNT-pg$5TOT$5T$+5TTO$5TOT+	`$5p+	$5$gy
++	`d+	ppg(Thh
+T(OTpgT/ToOT.nTo/OTnT.OTTT*	`opgTTj$`og+$5+$5pg*$5T*$5TTOf$T$*`$M`$e`$p``T!$5T R$5T1A+p`+1$g/1%C+$54$5Tpgc c2$g T"$5Q`$p$u!Ap`$A`
+`$`$`$A$5dyp$5T\]`$@p$5"D,@@Dl"$5"2Q T"3hTTtHt/>TOOTu%5Q"(`$O`$$[`jpfp$5T"<dGp$5T2pNT"D,@@Dl"$5"c uc ft?@DT20p'e)e(` &`..&(')TC  $%;@@C0T52p3e2e4` :`:2435TD  0;1t
+0D4
+0tDtnc c233x3$t>T ?*tt/>(@x333$t+> hu ii%5ihhu`hiu h/tt>T ?i(x333+$t> iui hx333$t*>pd/*t;t>`T+x333+$>ttP/+>tx333$<tTtT-*<tTN"4^2N_pt^rN_`D"c uc ft@2c c2ttTTdtjT?Tdtxj@x@kl$ 4*t@ t*Pt-3BT-$%4Tl_Tt`*lkT`ijx@tP3ABik`xt+@3BkT`itB3d
+`UTTT6RcTBZ TDS"0)%33/t>tTt_3%33/tt>T^"uc cTf"0 DD@D ! !Dtfcc2uuEBT0DCT
+uF=<; F E2uuRB0TDTCuSIJS;  R2uuEBT0DCT
+uF?>; F E2uuRB0TDTCuSKLS;  R2BT0/t &   |$ 4pe"\[^]\[p A%A
+;1~A
+\[~A\[$$N`$b`{A`_ud_P^A_]Tede@e7$0tee%;1e_%t_d]P^^]];1-]E^0p;1E^_+`]|^]
+} $_0`t_.]} |^
+^]__`_%`t1;;1\\[p~"!J ! G		`p"" $37T"`VuLVuLLIAFC_R  
+LA2YHPV_F2A_9R 
+22DM		%=LLP 
+d:LOT
+D% } "9Of"tA&2'*36+,78-.u9:uu/u(u;Q)uu4u$uV5%uu0u 1Q!9dtt|$}11tf f'tpdtp ~ 1t ~Q}Q|1q116qNQtt
+
+			t	y__C	`d_ P ~ |	t			 					t
+
+		eG`t "pGDDG}"a|GT%TTHONMPO"T0c1  |0| ~}' tt ttDuVuLV L"tCC"uu C#~"&~~&"~("~(}(~~}(-~R.~O-~~.,~,~/ ~TGTTHOJILK"xxxt0tt0tt t tt6D  ""            CT0uq%u$"0D	u0u "1   Ix e                                          4?@  H  ? : <fC  33x3 $>tW|X3} QV$3m	T33x30$>tVX$|W5{s} Q`dVdV!`$X(W50!3hTTtH/>t/tt>t/>ttt/>t/tt>t/>t0t<tthttt0
+
+t0?TTC0T0C0TC ~3x3X$W5TTNOXW DT3 $%33/tt>x ~33$t >Tu$@4TY"[Zc\$dd(c5,$d5cT`$ep$]0y^[U@$%s 4at\b\$4[[ aUt_`bUZbYa\]L_`]^M\\$4[[ t]^$ZZ 4YY]^dA` 08$d5c3pdT3d($c5TOT3333T,$dc5T"Ot+ V  ""C0'&;`.'&:0P"niaM0P 
+inI: 
+0tI:0P1tin0P 
+tcA:
+evi:0P A/DCTSIB
+SN :0P seT	
+DPt:0P eS		
+put:0P DP		
+nwo:0P BL		0P 
+			:=LOC 
+d%	:0PtixE0P 
+ 
+:~`. ,u-u /up-e+e*	`,-*,/u++*;"/~>`/&  T*0TD`d~10*+$%t!,u""-u`/0 ~u)u($u`%ut,u"A-u!`/" ~:T   A0 |0 Z0TZdT!/p!D3eVttp`2e[tAp7e6etA`u(u$u)3%u"T ~@EQ"(u")umx
+T   0TA  TaT% TOT1`mD5T1OT T1T`o5DT 333TT1OT1`"p(uQt)uu$u"%uQ)u($uj"%uu ,u"- 0TQuQ)u($u"%u ~V`. ~Uu$,u/um-0 ,u-u&-e+*p	`,e*,/u+-*;+"/ t t
+i*|t&tt,t0" t%!DTDTtgtTu$5ux-<sjuTTO-<$?iT3-
+$?htkRttQR
+ttQ9t@tA	ttBtCttt>ttTUtVt[]ttT{|DTttt`/" ~a T T ?T0D,u -u$$,u""-u?`/m ~DDcDTT D! DTT u -u&,/"py ~ xT%3 TTO0TO0D{T1|OTttDDTT~&`o |T TTOT  T' ?TT TT,u-u& ~"u)u($uQ"%u   "D032;`:32:1P"niaM1P 
+inI: 
+0tI:1P1tin1P 
+tcA:
+evi:1P A/DCTSIB
+SN :1P LDI	P 
+ET	:1PtseP 
+D		:1uteSP 
+p		:1woDPP 
+n		:1 
+BL	:1POC		d%=L1P 
+xE	: 
+ti
+:1P`:  ~u 8u;u9e7p9`8e668	u796;7;;`;" ~>&@0TC*dT~`%$7610tu"9u!8;"& ~`04uue5u1u0"tu!8u"K9~`;: !!T0!^A!02T!20Tu8u"[9RT@E ~uQ5u$4nx"-
+@ TT@0eAT@a %T@OTq`mTuDTTqOT@qoT`Du@3TT33qOTq`T"pQu4u0u~51uQ"4uuo5u1u08u"9u @"T0QQ4uu5u1u0V") ~~`;U !Tu 9u 8"At@`itJjtF|fttLl0tBbtE eaTDDDT	0ttTu$5ux-<	uTTO-<$?	T3-
+$?	t		tt		
+tt	h	to	tp		ttq	tr	tt	tmtt		t	t		tt	DTttt`:" ~_u$8u;ul90!8u 9u&9e76p	`8e68;u796;7";`;k ~@T ?T 0T D$8u"9uu$8u"9~?`;w DDcDTTA Da DTT! 8u 9u&p;"~ @xT%@3TOTpTOpDqTOTttDDCTAoT ~&`T |TATOT@T' T ?T TTC&8u" 9u ~4uV5uu0u""1    C20'&t;*'`&t$u%~%uQ'&)(.t`."& "'     UL    2bDDDTTT~TQ ~Q t(T*OTGDTMtt"j0?T0'10'TPV1llE'10'TP'&Tt$1h'T1h?T%0'Tt$1m'TmT#t$k1'Tk1T"t$P&Tdt@/.0&0T" "C p"   "    D2032t;*3e2t0u%~1uV3254:t`:"2 "3     UL    2bDD DTTT~?TQ@~Q`tHhTjOTv	DT	|	t	t"j0?T0g10gTPV1llEg10gTPg&Tt$1hgT1h?T%0gTt$1mgTmT#t$k1gTk1T"t$PfTdt@/.0f0T" "C p"   "    C0'&;`.'&:0P"B01	P 
+TS	:0pute0P 
+iL	:U-knP 
+p		:0kniLsoL-P 
+sL	:0-kninwoD0P 
+M		:X IDP 
+ E	:0
+tix`.  ~u ,u/u-P (~p+e*e5t`p+e*e(t,`+-p-e,e*,	`+-*/u+*;vx/TtT l ~"'^q1#HTT3/ $4 uEuxOoxvvt",u"Z-u?T'00 'z&x gt!T !tEtt-./  DT6tt,TDTTDTet! DT T !t-t.Et/t6t,DTTTDTET3%%#OT/" ~#`Ovsx$vDDD T0rx 	@ pu(,u -T	`d0x0ovvvvu&,uR-T 0#'
+ sxH1vvx"$ t @psx"vv$pTvxDT#Tpo`D5vx1 ~Q^#?T~0g  ~i"T D it
+*|t&tt,0t" t%!DTDTDDDTTu$5u-<uTTO+$:?T+
+$3tD`DTaTbDtcDguT$5u-<jTuTO+$:?iT3+
+$?htktRtQtR
+tQt9T:@t	tABtCD>D{DDTDtTDDTDtT&$Tp`"tTDDTt|T0xT333TT|OT/TT}OttTUtVTWDXDTYDTTZ&DT[D<D]DTTTD/" ~q`2D1TTTTNO%DmxTT3TND5%%T4OTTqxT0Dt`DtTTTTTNOT3TTTN33TOT3TTTTNOTtbT^TO#oTT
+`o4D#T^TOT#TToTOTdTT>``dpx7 @ p",u"~Z-u? TT5"DxTovvv""vDD,u5-u(`/" ~ktTTTTxm0Tu(u$uQ)%u  ""D032;`:32:1P"B01	P 
+TS	:1pute1P 
+iL	:U-knP 
+p		:1kniLsoL-P 
+sL	:1-kninwoD1P 
+M		:X IDP 
+ E	:1
+tix`:  ~u 8u;u9P (~p7e6e5t`p7e6e(t8`79p9e8e68	`796;u76;x;TtT l ~"'^q1cHTT3/ $4 uExOxvvt"8u"Z9u?Tg00 gzfx gtAaT@M!tEtNOtmno` DTL6ttl0DD?TT DDetaA@DT T`MNO!tmtnEtotL6tl DTD0DD?T	tT3%%cOT;" ~#`Ovx$vDDD@T0x 	@ pu(8u 9T	`d0x0vvvvu&8uR9T@0cg
+ xH1vvx"$  @px"vv$pTxDTcTpo`Dux1 ~Q^c?T~0g  ~i"AT@D`itJjF|tftLtl0tBbE teaDTDT DD1	DTTu$5u-<4	uTTO+$:?3	T+
+$32	t5		DDT		TDt		DuT$5u-<	TuTO+$:?	T3+
+$?		tt		tt		
+tth		Tio	t	tp	q	tr	Dm	DDDTDtTDDTDtTf$Tp`"tTDDTtTpxT333TTOToTTOtt		t	T	D	DT	DT	T&DT	D<D	DTT	D;" ~q`2DqTTTTNO%DCnxTT3TNDu%%TtOTTxT0DCt`DtTTTTTNOT3TTTN33TOT3TTTTNOTt	bTTOcoTT
+`otDcT	TOTcTToTOTdTT>``dx7 @ p"8u"~Z9u? TCTu"DxTvvv""vDD8u59u(`;" ~ktTTBTTxnpTu4u0uV51u  ""C0'&;`.'&:0P"001	
+XTb:0P teS	 
+pu	:0PtiaWP 
+P		:0 IDM 
+ X	:0P
+CGA:0P GA		d%=CWP  d%=R0P 
+KO	:P 
+0		:0 :CL 
+d%	:0P
+1KO:0P 2KO	0P 
+KO	:P 
+3O	:0P
+4K		:0 d% 	:0PcarTP 
+kS	:0
+cny:0P woD	%: nP 
+xE	:0
+tix& NA6-p^ P3	:0PLDM	d%=L. 
+ ~*`!,uu-ux/qxxvvxvoxv`qx1 T0?T o,uP-u+uP-u+,e+p-`,e**,	u+-*/+/;~x"TtT l/" ~	`)Q!,u"-up/ ~DA4 T xTv{$vTT/ $34 uEOwx0tGDDHDTLDT pDKDGT 0TQ ' T#T`oQ'v{x$v{[TPv{x$vO$PT~x#oT`p5D~xQ? ~#0?T ~H ~J@qu#,u"-#?T0'0'I &x6 t!TDTDTT8t,4t!TDTTTDt,8ET3%%#OT"Odwx@P
+"dxP"w`/L ~xx
+vqvD D qx
+vRpx'@ O@TT TOT ~"OxU | b ~O |,u-u' ~" ~x |TrxDT / T'0x 1T ?Pqu!,ux"-`v@q',u"-uu+,u"-t 8 tt0" t%t&t
+*!DTtTDtRQt
+tRQtpptR/TTTTTOTtttt`ttabttcgttTTjTTTOiThtk9@tABtCt>ttt=t<t{0x3TT33D|T/TT}OttttT`d
+ P~|  tC "t	 Bt "	tDt$tD/" ~`jvqx6,Pqu$,ux"1-/pqt4 ~@s78,u-u'vtx"vH`/ ~xdvqt'KDJDt)*DTt.tatbctPqu$,ux"1-pqu),u" -~X`/ qx
+vt't)T*DDT-t./Dt12ttabct@#tuP-u$,qx"1pNPu(,u"W-~,`/ qxvT*-T1Ttabt#t@P$,u"1-upqxN.,uPp-u',u-u'4T@Dp7',u"-ut'}T478VW3VWWV4VD5VW64
+'"t;`/ ~xvq)0?TPT0DT"0D DT%DT" )?T103 ~pqx ~Ju),u"-}~
+|T6@N.PTTTMTTTTTO&
+*~" xxO)T*Dt.-T T0x0taTbDatDbt3ctP#$,u"1-uu*,u-pTKOTTJOT0LTDT 0HDT"DT/"eap ~vx&$T`"ptDTDTt?t*tTT0OMHDTJTL DTKpDD#",uP1-u$uq")u($uyu%u-u$,.u1"uT$  44@tu7WVT V ~WVW V@! ~"t?tDTTmxt t0TE(uuQ)u%u$qx"vt%'t(t't)t-t./0tt/*tt+1t@t3,tt%'tt-{1z{0z 0uxtu{ 0@z {}0T*GDDHDTLDTTKDDTJDG"TDTO`T34564 ""            C0'&;`.'&:0P"taD	P 
+aL	:0 CLo 
+x%%:XR
+ 
+x	:0Pd%:A0P 
+:L	: 
+d%	:0PD%:P0P 
+:S	:Bdd%0P 
+:F	:ppD%P 
+mD	:0%  : 
+ D	:0P%:WTP 
+dT	:0d%:Q0P 
+WR	:
+d%::0P :QR	 
+d%oL		%RCSP 
+dL	:0 
+So	:0P
+S_Bp. ~u! DmxTT3NT5D%%T4xOyxwxu'<u>u'=?u(m<Dtl0x50GTtmTlt     x0xU0pxPT ?yx{z/pTGitTthxvT<=;`DtTDTTTTMT3OTTTTNT333OTTTNTTO1TTTN%TObt0x xNOettp?`>e(xJaH3t4@7u*P ~H' ~07 |8 $>0x60?>t(t@?>t,tP`xwx	xH@pHettp?`>e,~|4 },TGTthlTT!T!Tt`
+tRtQTTTDD<tT5~Dt)(u'&%u$m0"izxpdzx`FdeWXxWXWXx-<XX%W5xW|}e!XY Y@YTTT!O4@DT7~Zx; rp~F Z8 ~xP3Z ~ |Y~f WXZ@"dzxpFxdzPpFs ~4DT TVVT4 ~Oz78VV~@~ ]dzxpF0TxA0 ~  ~z z ~   ~z z     "H@ ~x |x"@DD*tTxTv! vx`FpxpF0POwxP ~
+@wxN@<x ~@"x["\dPd@?u	 %3x$@t ~t33%5
+t%5} |\[@\[u" th0!DDGDDu'<u"S=th GTth+ht0yE"A|}GDu(<u"r=M(TTGTth'<u"'=u|P}TGT%%HOTRQTSth"th  p h80t p @ p@'MGDu'<u S= p#"T0?,8tDRD"th	 E'Ah0t"#0?T,tRTT@uEP}A|$'GuD=u'<"Glt G!TDT!T`d!xNOQCuGDDDDTGpTKOTTTJO0LT DTH0DTDTmTtl1TDTGq0a,TTG"DGT@tlluBu?u+>b`T
+TQ"DTTt`DmG@DDHDTLDT TJKpDGDT<tQDGlu	t?u(>}"	|GTTTTHOZY\[l"tGDt'/tt-%tTTOT%tt-'ut$}`B|QDG*ttl->u"?ut`TaPTNTaT@T*T-x"vtl;0tD*D-`t#?T0t,Ql602OTDT`T
+TQlZ0tBB@C,q*DD-t`2pB?ebt+tp&p>el0#?T0t,Avxx"v lT`IQoBDltgt`DT=Dt/tl$BCPBPpT
+`TQ1Dm"0lBtxpBv>u"?u,DDp`phtlTHDL DTJTKpDDG"#0?T8t, p  uQ
+BGDTGtItl	D'tTaDTTT=OTDTmu?u,>"?tlvx0t)0ODBlt0B p Bxpv  ""        D032;`:32:1P"001	
+XTb:1P teS	 
+pu	:1PtiaWP 
+P		:1 IDM 
+ X	:1P
+CGA:1P GA		d%=CWP  d%=R1P 
+KO	:P 
+0		:1 :CL 
+d%	:1P
+1KO:1P 2KO	1P 
+KO	:P 
+3O	:1P
+4K		:1 d% 	:1PcarTP 
+kS	:1
+cny:1P woD	%: nP 
+xE	:1
+tix& NA6-p^ P3	:1PLDM	d%=L: 
+ ~*`!8uu9ux;xvxvxv`x1@T0C?T 8uP9u,uP9u,8e7p9`8e668	u796;7;;x"TtT l;" ~	`)12"8u"o9ucT?g00 gfIx6 tAaD?TD0DT D8tLl4taADT DD?T0Dl8tLt	T3%%Tc"OAp; ~4@TT`xvv$TT3/ $4 uEOxtv	DDTw	D{	 DTz	pDDv	T@0T1g  TcoT`x1gvW$vxPPv	$v~x$PTcpoT`uxD~1? c0?T ~Hqu@9u&8	"~dx@P
+"dxP" ~~x | CTxD@T/ T'0x q?Tq uP9u"8x"o`@qu&8uu"99u,8"A8t@`t0tBbE tetFfJtjaTDtDT	 tt		
+tt	p	p	4	3	2t/TT	4TTOT3	T2	t5	*	t1	t	tt	tt		tt	tTT	TTT	OT		th	o	p	tq	tr	ttm	tl	ttk	tpx33TDT3oTTOTtttC	tTA	C	
+`d P ~ |CtK	M	O	Q	8	t:	;	<	 	BtKM	O	Q	t8			:	;	<DAS	ttD`;" ~jvxqk8uP9u#x"	/p@tcs ~f	g	u(8ux9vv;" ~`Lvxvx
+@D`xDRpx
+v '@~	@T@OTT`OT ~"xU | ~	b|~ u&8ux"9vtT	V	W	ttV	X	t\	tt]	^		t_t^		tYtZ		t`tb		@t[tT		tVt\	{`	z(z {gxg(utu {{g}@z Y	gTv	DDTw	D{	DTz	DTD	TyDTv	"DT3O`Tc	d		ec	`;" ~X
+vxtV		tXY	DTD\	Tt]		D^`	tta		t		t#@P#8u"9upx}	8uP9u)`;" ~,vxY	TT\		T`	tt	1@#uP9u#8x".p}	Pu)8u9u(8u9c	@DTf	up9u&8	"tVT}c	f	Vg	VW3WVWVDc		Vde	Wc	
+tV	;" ~H`vxV	dtDz		DyX	tTY	Dt]		tt		t#uP9u#8x"up9u*8;": ~;`vxiTL0?B0DTbDT0TE DTe Di"0?TQ~3 x	p8u9u+~J"|F}T6@}	.PTTTTMTTTOTFfJj ~"~	xX	Y	DT]	tT\	T px0	t	DTt		Dtb		t#uP9u#88u"9u+pTTz	OT	TyO	0{TT D0w	TDT""Dp; ~{xfT`$"ptTDTDt?t*tTT0~			|TwDTy		T{ DDz	Dp"P#u#8u"94uu5u1u0#8uu9u":T u $4	@tcf	uVWT  ~WVVW V@a ~"t?tDCTTnxt`tpTt	4uV5uu0u""1D032;`:32:1P"taD	P 
+aL	:1 CLo 
+x%%:XR
+ 
+x	:1Pd%:A1P 
+:L	: 
+d%	:1PD%:P1P 
+:S	:Bdd%1P 
+:F	:ppD%P 
+mD	:1%  : 
+ D	:1P%:WTP 
+dT	:1d%:Q1P 
+WR	:
+d%::1P :QR	 
+d%oL		%RCSP 
+dL	:1 
+So	:1P
+S_Bp: ~u! DCnxTT3NTuD%%TtxOxxu'IuKu'JLu(o<Dtnpx50GTtoTnt 	   xpxU0pxPT ?x{z/pTGktTtjxvTIJ;`DtTDTTTTMT3OTTTTNT333OTTTNTTOqTTTN%TObtpx 	x}~	ettpL`Ke(xJaU3tc		@fu*P ~U' ~0f		 |g $>px60LKt(t@LKt,tP`xx	xU@pUettpL`Ke,~|4 },TGTtjnATTaTAaTt		
+tt	TTTDD<tCTu~D~54u321u0o0"kxpdx`FdeWXxWXWXx-<XX%W5xW|}e!XY`Y@YTTTaOc	@DTf	~Zx; p~F 	Zg ~xP3Z ~ |Y~f WXZ@"dxpFxdPpFs ~c	DT TVV	Tc ~Oz	fg	VV~@~ ]dxpFpTxA0 ~  ~z z ~	  ~z z	    "H@ ~x |x"@DD*tTxTv! vx`FpxpF0P~	xP ~
+@x}	@<x ~@"x["\dPd@?u	 %3x$@t ~t33%5
+t%5} |\[@\[u" tj0!DSDGDDu'Iu}"J|PGT3TT33HOTVUXWtj"t	}N|YDGIusJu(j"t TGtj0jt"N(TTGTtj'Iu"'Jutj   p0jt8 p MpMN S'DG'IuJu p "c0?Tl8tL	DD"tj t		N'0jt"c0?TltL	TuT	PMNt|$}'GYDu'Iu"JntT T!TD!TdT!`}	x~	PuQ DGDDDTv	pTz	OTTy	OT0{	TDT 	0wDTDTTont1TDT0T	TG"Tv	@DTtn	Ouu+KuLT
+`T"QDTT	tDo	@DvDw	DT	T{ DTy		pDzv	DT<tQDG 	tnu(Ku}"L	|GTTT3HOT^]`_tn	"DvV	tt^	\	ttT	TT333T	OtTt\		tV}`Ou|$QDG *ttnKuLu-vx"n a?Tx	Q`OQo		tt	l	QDT	t^tnOP$PPOp`T
+TQ1oDn"0tOpOvx"vxtn0t;Y	D\	Dt	c0?TLtlQ0nT62TDTT
+`TQ0nOZtPO@	DY\	Dt	Ot2ppLeKe+t&p0nc0?TLtlxAv	"tT	PTNT	T@Y	TT\	u"Lu,KDDp`ptjnw	DT{	DT	 Tyz	pDv	"Dc?T0Ltl 8
+ p	Q
+OuG Dv	Ttx	n	tD	tV	DTTTTl	OTD?oTu+Ku"1Ltnvx0t)0QOnT0t Op xpOv ""    C0'&;`.'&:0P"				%:XRP 
+x		:0%XT	% :dP 
+xT	:0siDx0P 
+SL	:khC-0P 
+P		:aF-D
+tlu:0P KCA	 
+D-	:0P-ON	CTAMP 
+HA	:0
+seR:0P >-		 01 F- 0H- DE/ D- EE%:SPP 
+dC	:0KCA-0P 
+R		:MSFX
+d%=:0P -PN	tiaW0P 
+T		:MSFX
+d%=:0P ibA	
+D-l`. ?u*u@uBuAyxxw/uQ==TT==@  T,~-eep`,q-,=>=T0 ~AvBD==te+p-`,e**,	u+-*/+/;T==0 ~<+#|T 7 ~@?xvd`D4==Dt_0Tx	
+D<<xx	pT<<xt_xT T333TT<<Oy<PT<0x<Dvyx<vt< ?T<T x<T<<T<TO<TOT<OT=<)0RTTCT| ~
+} $xx9>w"PRDDCu"-u#,_TT  T DDTT/T$34 u {xEO|xTtT l"~5`/; oxv4v#?TqtTx m TouP-u$,"?T'000'I&xr T3DTO T3!TT3D t 8t )	0t,t	t,TTDTDTp3DT!TT3OTD T38t t )0t	,t	t,DTTTDTET3%%#OT/"`q#< <
+?T'0osx'Pvv<lTT<OT,u<8-u&oxvv6dT`x}x=W0AOBTx@OTABpff}xpu@-u',xBAx}x' q$@s	@=7 <70rx7pFTBD#T0?5DTTqT{x%$3rx*4x!T|#poT`5xDq|vsx"lvvsxxlv*vqv"q'$`/F ~t#?TqvoxLv<T
+0<3TT33T%%<OTo<P<T !tt,u*-u+< T ~RuD-u$, ~"}xoxvv*vvuxvxvsxlvvx@?@?TTTTNT333O@?TT<OT<
+TTT"$`/a ~D?@Dx@@D}xdT,u`_-u#=Q0BApfxf}xpu2@-u(,x"
+x}TBApf`f#,ux_-u@D/"e`0=~x	 x@@p~?T/0T&0@? TTu0-u),,u"]*-u+ ~"v~x$x`$`xpxvT0T
+dx	pNvx$x$5`x?p
+T OT
+TTTOxx`dxD4 ~ x |Dx3TT33<OT<< T T333TT<x<OT"dTu`-u#,`/_xvQd Kp0Tex<TTOT?@Tx+ v`/%<!TTxOT?@= uABATBApfxf}xIpvV@ABT<Tx:`o T)0u',uxx-T " BAx}x ~"}xxx`$G`0$D`=p0vx1T xvvxT vvxx$$%`$`x7p
+vDx
+vT DxTOT ~x |Nq0<D4 ~lu#,uu"_--u,,<"T ~<{1T	`dT`d
+x^_
+01DTx'0T
+T1(DxT0T1Dx0TT1TD<<001TDxT	0?10Dx6T$00T1 D
+01DT1xT~vm x}T1}xP ~x}1T0 ~ ~1T0? ~~ 1|T D<"<uT)u($uQ"%u   "        D032;`:32:1P"				%:XRP 
+x		:1%XT	% :dP 
+xT	:1siDx1P 
+SL	:khC-1P 
+P		:aF-D
+tlu:1P KCA	 
+D-	:1P-ON	CTAMP 
+HA	:1
+seR:1P >-		 01 F- 0H- DE/ D- EE%:SPP 
+dC	:1KCA-1P 
+R		:MSFX
+d%=:1P -PN	tiaW1P 
+T		:MSFX
+d%=:1P ibA	
+D-l`: Lu*uMuOuNxx;uQJJTTJJ@@ T,~9eep`8q98J>JT0 ~NvODJJte7p9`8e668	u796;7;;TJJ0 ~<+c|T 7 ~MLxvd`DtJJDt	0Tx	
+DIIxx	pTIIxt	xT T333TTIIOIPTI0xIDvxIvtI ?TIT xITIITITOITOTIOTJI)0	TTr	T| ~
+} $x9>"P	DDr	u"9u#8M_TT!!T@DTDT/T$34 u xEOxTtT l"~5`;; xv4vc?TqtTCx!n!TuP9u$8"?Tg000gIfxr T3DATO T3aTT3D t@8t`i	0Ltlt	tl0D?TDT DDp3DTaTT3OATD T38t@t`i0Lt	lt	tl DTD0DD?T	tT3%%cOT;"`qcI I
+?T'0x'PvvIlTTIOT8uI89u&xvv6dT`xxJW0NOOTx@OTNOpffxpu@9u'8xONxxg $@	@J7 I70x7pF	BDcT0?uDT	qTx%$3x*4x!TcpoT`uxDqvx"lvvxxlv*vv"qg$`;F ~tc?TqvxLvIT
+0I3TT33T%%IOTIPIT K!tt8u*9u+I T ~RMuD9u$8 ~"xxvv*vvxvxvxlvvxHMLMLTTTTNT333OMLTTIOTIJMTTT"$`;a ~DMLMDx@@DxdT8u`_9u#JQ0ONpfxfxpu2@9u(8x"
+xTONpf`f#8ux_9u@D;"e`0Jx	 x@@pM?T/0T&0ML TPTu09u)88u"]*9u+ ~"vx$x`$`xpxvT0T
+dx	pNvx$x$5`x?pJT COTJTTTMOxx`dxPDt ~ x |DMx3TT33IOTII T T333TTIxIOHT"dTu`9u#8`;_xvQd!Kp0TNexITTOTLMNTx+ v`;%I!TTxOTLMJ uAONTONpfxfxIpvV@NOTITx:`o!T)0u'8uxx9T!"!ONxx ~"xxx`$G`0$D`=p0vx1HT xvvHxT vvxx$$%`$`x7p
+vDx
+vT DxHTOT ~x |Nq0IDt ~lu#8uu"_99u,8I"T ~I{qTI`dTK`dJx^H_
+0qDTx'0T
+Tq(DxT0TqDx0TTqTDII00qTDxT	0?q0Dx6T$0H0Tq DJ0qDTqxT~vn xTqxP ~xqT0 ~ ~qT0? ~~ q|T DI"IuT5u40uV"1u   "        C0'&;`.'&DC	" gai 
+SN ~"P~~1_YH2_5VI_F2RV_P2A_9CR_2434  ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/gphy.c b/arch/mips/cpu/mips32/vrx200/gphy.c
new file mode 100644
index 0000000000000000000000000000000000000000..be140010bc2b2c8bd9f4755ffef41d3c1729a5c2
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gphy.c
@@ -0,0 +1,59 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+
+static inline void ltq_gphy_copy(const void *fw_start, const void *fw_end,
+				ulong dst_addr)
+{
+	const ulong fw_len = (ulong) fw_end - (ulong) fw_start;
+	const ulong addr = CKSEG1ADDR(dst_addr);
+
+	debug("ltq_gphy_copy: addr %08lx, fw_start %p, fw_end %p\n",
+		addr, fw_start, fw_end);
+
+	memcpy((void *) addr, fw_start, fw_len);
+}
+
+void ltq_gphy_phy11g_a1x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy11g_a1x_start;
+	extern ulong __ltq_fw_phy11g_a1x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy11g_a1x_start, &__ltq_fw_phy11g_a1x_end,
+			addr);
+}
+
+void ltq_gphy_phy11g_a2x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy11g_a2x_start;
+	extern ulong __ltq_fw_phy11g_a2x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy11g_a2x_start, &__ltq_fw_phy11g_a2x_end,
+			addr);
+}
+
+void ltq_gphy_phy22f_a1x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy22f_a1x_start;
+	extern ulong __ltq_fw_phy22f_a1x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy22f_a1x_start, &__ltq_fw_phy22f_a1x_end,
+			addr);
+}
+
+void ltq_gphy_phy22f_a2x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy22f_a2x_start;
+	extern ulong __ltq_fw_phy22f_a2x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy22f_a2x_start, &__ltq_fw_phy22f_a2x_end,
+			addr);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/gphy_fw.S b/arch/mips/cpu/mips32/vrx200/gphy_fw.S
new file mode 100644
index 0000000000000000000000000000000000000000..b262f17820d12d913026c4ca1bf88b2d794e8b19
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gphy_fw.S
@@ -0,0 +1,28 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <asm/asm.h>
+
+	.section .rodata.__ltq_fw_phy11g_a1x
+EXPORT(__ltq_fw_phy11g_a1x_start)
+	.incbin "fw_phy11g_a1x.blob"
+EXPORT(__ltq_fw_phy11g_a1x_end)
+
+	.section .rodata.__ltq_fw_phy11g_a2x
+EXPORT(__ltq_fw_phy11g_a2x_start)
+	.incbin "fw_phy11g_a2x.blob"
+EXPORT(__ltq_fw_phy11g_a2x_end)
+
+	.section .rodata.__ltq_fw_phy22f_a1x
+EXPORT(__ltq_fw_phy22f_a1x_start)
+	.incbin "fw_phy22f_a1x.blob"
+EXPORT(__ltq_fw_phy22f_a1x_end)
+
+	.section .rodata.__ltq_fw_phy22f_a2x
+EXPORT(__ltq_fw_phy22f_a2x_start)
+	.incbin "fw_phy22f_a2x.blob"
+EXPORT(__ltq_fw_phy22f_a2x_end)
diff --git a/arch/mips/cpu/mips32/vrx200/mem.c b/arch/mips/cpu/mips32/vrx200/mem.c
new file mode 100644
index 0000000000000000000000000000000000000000..6f46a3dde2651e90e966f9abfae05f344ec37dd9
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/mem.c
@@ -0,0 +1,58 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CCR03_EIGHT_BANK_MODE	(1 << 0)
+#define LTQ_CCR08_CS_MAP_SHIFT		24
+#define LTQ_CCR08_CS_MAP_MASK		(0x3 << LTQ_CCR08_CS_MAP_SHIFT)
+#define LTQ_CCR11_COLUMN_SIZE_SHIFT	24
+#define LTQ_CCR11_COLUMN_SIZE_MASK	(0x7 << LTQ_CCR11_COLUMN_SIZE_SHIFT)
+#define LTQ_CCR11_ADDR_PINS_MASK	0x7
+#define LTQ_CCR15_MAX_COL_REG_SHIFT	24
+#define LTQ_CCR15_MAX_COL_REG_MASK	(0xF << LTQ_CCR15_MAX_COL_REG_SHIFT)
+#define LTQ_CCR16_MAX_ROW_REG_MASK	0xF
+
+static void *ltq_mc_ddr_base = (void *) CKSEG1ADDR(LTQ_MC_DDR_BASE);
+
+static inline u32 ltq_mc_ccr_read(u32 index)
+{
+	return ltq_readl(ltq_mc_ddr_base + LTQ_MC_DDR_CCR_OFFSET(index));
+}
+
+phys_size_t initdram(int board_type)
+{
+	u32 max_col_reg, max_row_reg, column_size, addr_pins;
+	u32 banks, cs_map;
+	phys_size_t size;
+
+	banks = (ltq_mc_ccr_read(3) & LTQ_CCR03_EIGHT_BANK_MODE) ? 8 : 4;
+
+	cs_map = (ltq_mc_ccr_read(8) & LTQ_CCR08_CS_MAP_MASK) >>
+		LTQ_CCR08_CS_MAP_SHIFT;
+
+	column_size = (ltq_mc_ccr_read(11) & LTQ_CCR11_COLUMN_SIZE_MASK) >>
+		LTQ_CCR11_COLUMN_SIZE_SHIFT;
+
+	addr_pins = ltq_mc_ccr_read(11) & LTQ_CCR11_ADDR_PINS_MASK;
+
+	max_col_reg = (ltq_mc_ccr_read(15) & LTQ_CCR15_MAX_COL_REG_MASK) >>
+		LTQ_CCR15_MAX_COL_REG_SHIFT;
+
+	max_row_reg = ltq_mc_ccr_read(16) & LTQ_CCR16_MAX_ROW_REG_MASK;
+
+	/*
+	 * size (bytes) = 2 ^ rowsize * 2 ^ colsize * banks * chipselects
+	 *                 * datawidth (bytes)
+	 */
+	size = (2 << (max_col_reg - column_size - 1)) *
+		(2 << (max_row_reg - addr_pins - 1)) * banks * cs_map * 2;
+
+	return size;
+}
diff --git a/arch/mips/cpu/mips32/vrx200/mem_init.S b/arch/mips/cpu/mips32/vrx200/mem_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..29ffdcfa6174bb7994a57fdd5c503b0935e93288
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/mem_init.S
@@ -0,0 +1,234 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* Must be configured in BOARDDIR */
+#include <ddr_settings.h>
+
+#define LTQ_MC_DDR_START		(1 << 8)
+#define LTQ_MC_DDR_DLL_LOCK_IND	1
+
+#define CCS_ALWAYS_LAST			0x0430
+#define CCS_AHBM_CR_BURST_EN		(1 << 2)
+#define CCS_FPIM_CR_BURST_EN		(1 << 1)
+
+#define CCR03_EIGHT_BANK_MODE		(1 << 0)
+
+	/* Store given value in MC DDR CCRx register */
+	.macro ccr_sw num, val
+	li	t1, \val
+	sw	t1, LTQ_MC_DDR_CCR_OFFSET(\num)(t0)
+	.endm
+
+LEAF(ltq_mem_init)
+	/* Load MC DDR module base */
+	li	t0, (LTQ_MC_DDR_BASE | KSEG1)
+
+	/* Put memory controller in inactive mode */
+	sw	zero, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+
+	/* Init MC DDR CCR registers with values from ddr_settings.h */
+	ccr_sw	0, MC_CCR00_VALUE
+	ccr_sw	1, MC_CCR01_VALUE
+	ccr_sw	2, MC_CCR02_VALUE
+	ccr_sw	3, MC_CCR03_VALUE
+	ccr_sw	4, MC_CCR04_VALUE
+	ccr_sw	5, MC_CCR05_VALUE
+	ccr_sw	6, MC_CCR06_VALUE
+	ccr_sw	7, MC_CCR07_VALUE
+	ccr_sw	8, MC_CCR08_VALUE
+	ccr_sw	9, MC_CCR09_VALUE
+
+	ccr_sw	10, MC_CCR10_VALUE
+	ccr_sw	11, MC_CCR11_VALUE
+	ccr_sw	12, MC_CCR12_VALUE
+	ccr_sw	13, MC_CCR13_VALUE
+	ccr_sw	14, MC_CCR14_VALUE
+	ccr_sw	15, MC_CCR15_VALUE
+	ccr_sw	16, MC_CCR16_VALUE
+	ccr_sw	17, MC_CCR17_VALUE
+	ccr_sw	18, MC_CCR18_VALUE
+	ccr_sw	19, MC_CCR19_VALUE
+
+	ccr_sw	20, MC_CCR20_VALUE
+	ccr_sw	21, MC_CCR21_VALUE
+	ccr_sw	22, MC_CCR22_VALUE
+	ccr_sw	23, MC_CCR23_VALUE
+	ccr_sw	24, MC_CCR24_VALUE
+	ccr_sw	25, MC_CCR25_VALUE
+	ccr_sw	26, MC_CCR26_VALUE
+	ccr_sw	27, MC_CCR27_VALUE
+	ccr_sw	28, MC_CCR28_VALUE
+	ccr_sw	29, MC_CCR29_VALUE
+
+	ccr_sw	30, MC_CCR30_VALUE
+	ccr_sw	31, MC_CCR31_VALUE
+	ccr_sw	32, MC_CCR32_VALUE
+	ccr_sw	33, MC_CCR33_VALUE
+	ccr_sw	34, MC_CCR34_VALUE
+	ccr_sw	35, MC_CCR35_VALUE
+	ccr_sw	36, MC_CCR36_VALUE
+	ccr_sw	37, MC_CCR37_VALUE
+	ccr_sw	38, MC_CCR38_VALUE
+	ccr_sw	39, MC_CCR39_VALUE
+
+	ccr_sw	40, MC_CCR40_VALUE
+	ccr_sw	41, MC_CCR41_VALUE
+	ccr_sw	42, MC_CCR42_VALUE
+	ccr_sw	43, MC_CCR43_VALUE
+	ccr_sw	44, MC_CCR44_VALUE
+	ccr_sw	45, MC_CCR45_VALUE
+	ccr_sw	46, MC_CCR46_VALUE
+
+	ccr_sw	52, MC_CCR52_VALUE
+	ccr_sw	53, MC_CCR53_VALUE
+	ccr_sw	54, MC_CCR54_VALUE
+	ccr_sw	55, MC_CCR55_VALUE
+	ccr_sw	56, MC_CCR56_VALUE
+	ccr_sw	57, MC_CCR57_VALUE
+	ccr_sw	58, MC_CCR58_VALUE
+	ccr_sw	59, MC_CCR59_VALUE
+
+	ccr_sw	60, MC_CCR60_VALUE
+	ccr_sw	61, MC_CCR61_VALUE
+
+	/* Disable bursts between FPI Master bus and XBAR bus */
+	li	t4, (LTQ_MC_GLOBAL_BASE | KSEG1)
+	li	t5, CCS_AHBM_CR_BURST_EN
+	sw	t5, CCS_ALWAYS_LAST(t4)
+
+	/* Init abort condition for DRAM probe */
+	move	t4, zero
+
+	/*
+	 * Put memory controller in active mode and start initialitation
+	 * sequence for connected DDR-SDRAM device
+	 */
+mc_start:
+	lw	t1, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+	li	t2, LTQ_MC_DDR_START
+	or	t1, t1, t2
+	sw	t1, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+
+	/*
+	 * Wait until DLL has locked and core is ready for data transfers.
+	 * DLL lock indication is in register CCR47 and CCR48
+	 */
+wait_ready:
+	li	t1, LTQ_MC_DDR_DLL_LOCK_IND
+	lw	t2, LTQ_MC_DDR_CCR_OFFSET(47)(t0)
+	and	t2, t2, t1
+	bne	t1, t2, wait_ready
+
+	lw	t2, LTQ_MC_DDR_CCR_OFFSET(48)(t0)
+	and	t2, t2, t1
+	bne	t1, t2, wait_ready
+
+#ifdef CONFIG_SYS_DRAM_PROBE
+dram_probe:
+	/* Initialization is finished after the second MC start */
+	bnez	t4, mc_finished
+
+	/*
+	 * Preload register values for CCR03 and CCR11. Initial settings
+	 * are 8-bank mode enabled, 14 use address row bits, 10 used
+	 * column address bits.
+	 */
+	li	t1, CONFIG_SYS_SDRAM_BASE_UC
+	li	t5, MC_CCR03_VALUE
+	li	t6, MC_CCR11_VALUE
+	addi	t4, t4, 1
+
+	/*
+	 * Store test values to DRAM at offsets 0 and 2^13 (bit 2 in bank select
+	 * address BA[3]) and read back the value at offset 0. If the resulting
+	 * value is equal to 1 we can skip to the next test. Otherwise
+	 * the 8-bank mode does not work with the current DRAM device,
+	 * thus we need to clear the according bit in register CCR03.
+	 */
+	li	t2, 1
+	sw	t2, 0x0(t1)
+	li	t3, (1 << 13)
+	add	t3, t3, t1
+	sw	zero, 0(t3)
+	lw	t3, 0(t1)
+	bnez	t3, row_col_test
+
+	/* Clear CCR03.EIGHT_BANK_MODE */
+	li	t3, ~CCR03_EIGHT_BANK_MODE
+	and	t5, t5, t3
+
+row_col_test:
+	/*
+	 * Store test values to DRAM at offsets 0, 2^27 (bit 13 of row address
+	 * RA[14]) and 2^26 (bit 12 of RA[14]). The chosen test values
+	 * represent the difference between max. row address bits (14) and used
+	 * row address bits. Then the read back value at offset 0 indicates
+	 * the useable row address bits with the current DRAM device. This
+	 * value must be set in the CCR11 register.
+	 */
+	sw	zero, 0(t1)
+
+	li	t2, 1
+	li	t3, (1 << 27)
+	add	t3, t3, t1
+	sw	t2, 0(t3)
+
+	li	t2, 2
+	li	t3, (1 << 26)
+	add	t3, t3, t1
+	sw	t2, 0(t3)
+
+	/* Update CCR11.ADDR_PINS */
+	lw	t3, 0(t1)
+	add	t6, t6, t3
+
+	/*
+	 * Store test values to DRAM at offsets 0, 2^10 (bit 9 of column address
+	 * CA[10]) and 2^9 (bit 8 of CA[10]). The chosen test values represent
+	 * the difference between max. column address bits (12) and used
+	 * column address bits. Then the read back value at offset 0 indicates
+	 * the useable column address bits with the current DRAM device. This
+	 * value must be set in the CCR11 register.
+	 */
+	sw	zero, 0(t1)
+
+	li	t2, 1
+	li	t3, (1 << 10)
+	add	t3, t3, t1
+	sw	t2, 0(t3)
+
+	li	t2, 2
+	li	t3, (1 << 9)
+	add	t3, t3, t1
+	sw	t2, 0(t3)
+
+	/* Update CCR11.COLUMN_SIZE */
+	lw	t3, 0(t1)
+	sll	t3, t3, 24
+	add	t6, t6, t3
+
+	/* Put memory controller in inactive mode */
+	sw	zero, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+
+	/* Update CCR03 and CCR11 and restart memory controller initialiation */
+	sw	t5, LTQ_MC_DDR_CCR_OFFSET(3)(t0)
+	sw	t6, LTQ_MC_DDR_CCR_OFFSET(11)(t0)
+	b	mc_start
+
+mc_finished:
+#endif /* CONFIG_SYS_DRAM_PROBE */
+
+	jr	ra
+
+	END(ltq_mem_init)
diff --git a/arch/mips/cpu/mips32/vrx200/pmu.c b/arch/mips/cpu/mips32/vrx200/pmu.c
new file mode 100644
index 0000000000000000000000000000000000000000..d42c1cfbf55fd9e3a5ce55cea2b62d0675001f2b
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/pmu.c
@@ -0,0 +1,131 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PMU_PWDCR_RESERVED		((1 << 13) | (1 << 4))
+
+#define LTQ_PMU_PWDCR_PCIELOC_EN	(1 << 31)
+#define LTQ_PMU_PWDCR_GPHY		(1 << 30)
+#define LTQ_PMU_PWDCR_PPE_TOP		(1 << 29)
+#define LTQ_PMU_PWDCR_SWITCH		(1 << 28)
+#define LTQ_PMU_PWDCR_USB1		(1 << 27)
+#define LTQ_PMU_PWDCR_USB1_PHY		(1 << 26)
+#define LTQ_PMU_PWDCR_TDM		(1 << 25)
+#define LTQ_PMU_PWDCR_PPE_DPLUS		(1 << 24)
+#define LTQ_PMU_PWDCR_PPE_DPLUM		(1 << 23)
+#define LTQ_PMU_PWDCR_PPE_EMA		(1 << 22)
+#define LTQ_PMU_PWDCR_PPE_TC		(1 << 21)
+#define LTQ_PMU_PWDCR_DEU		(1 << 20)
+#define LTQ_PMU_PWDCR_PPE_SLL01		(1 << 19)
+#define LTQ_PMU_PWDCR_PPE_QSB		(1 << 18)
+#define LTQ_PMU_PWDCR_UART1		(1 << 17)
+#define LTQ_PMU_PWDCR_SDIO		(1 << 16)
+#define LTQ_PMU_PWDCR_AHBM		(1 << 15)
+#define LTQ_PMU_PWDCR_FPIM		(1 << 14)
+#define LTQ_PMU_PWDCR_GPTC		(1 << 12)
+#define LTQ_PMU_PWDCR_LEDC		(1 << 11)
+#define LTQ_PMU_PWDCR_EBU		(1 << 10)
+#define LTQ_PMU_PWDCR_DSL		(1 << 9)
+#define LTQ_PMU_PWDCR_SPI		(1 << 8)
+#define LTQ_PMU_PWDCR_USIF		(1 << 7)
+#define LTQ_PMU_PWDCR_USB0		(1 << 6)
+#define LTQ_PMU_PWDCR_DMA		(1 << 5)
+#define LTQ_PMU_PWDCR_DFEV1		(1 << 3)
+#define LTQ_PMU_PWDCR_DFEV0		(1 << 2)
+#define LTQ_PMU_PWDCR_FPIS		(1 << 1)
+#define LTQ_PMU_PWDCR_USB0_PHY		(1 << 0)
+
+struct ltq_pmu_regs {
+	u32	rsvd0[7];
+	u32	pwdcr;		/* Power down control */
+	u32	sr;		/* Power down status */
+	u32	pwdcr1;		/* Power down control 1 */
+	u32	sr1;		/* Power down status 1 */
+};
+
+static struct ltq_pmu_regs *ltq_pmu_regs =
+	(struct ltq_pmu_regs *) CKSEG1ADDR(LTQ_PMU_BASE);
+
+u32 ltq_pm_map(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_PM_CORE:
+		val = LTQ_PMU_PWDCR_UART1 | LTQ_PMU_PWDCR_FPIM |
+			LTQ_PMU_PWDCR_LEDC | LTQ_PMU_PWDCR_EBU;
+		break;
+	case LTQ_PM_DMA:
+		val = LTQ_PMU_PWDCR_DMA;
+		break;
+	case LTQ_PM_ETH:
+		val = LTQ_PMU_PWDCR_GPHY | LTQ_PMU_PWDCR_PPE_TOP |
+			LTQ_PMU_PWDCR_SWITCH | LTQ_PMU_PWDCR_PPE_DPLUS |
+			LTQ_PMU_PWDCR_PPE_DPLUM | LTQ_PMU_PWDCR_PPE_EMA |
+			LTQ_PMU_PWDCR_PPE_TC | LTQ_PMU_PWDCR_PPE_SLL01 |
+			LTQ_PMU_PWDCR_PPE_QSB;
+		break;
+	case LTQ_PM_SPI:
+		val = LTQ_PMU_PWDCR_SPI;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_pm_enable(enum ltq_pm_modules module)
+{
+	const unsigned long timeout = 1000;
+	unsigned long timebase;
+	u32 sr, val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_pmu_regs->pwdcr, val);
+
+	timebase = get_timer(0);
+
+	do {
+		sr = ltq_readl(&ltq_pmu_regs->sr);
+		if (~sr & val)
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int ltq_pm_disable(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_pmu_regs->pwdcr, val);
+
+	return 0;
+}
+
+void ltq_pmu_init(void)
+{
+	u32 set, clr;
+
+	clr = ltq_pm_map(LTQ_PM_CORE);
+	set = ~(LTQ_PMU_PWDCR_RESERVED | clr);
+
+	ltq_clrsetbits(&ltq_pmu_regs->pwdcr, clr, set);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/rcu.c b/arch/mips/cpu/mips32/vrx200/rcu.c
new file mode 100644
index 0000000000000000000000000000000000000000..4d7c27e6c8ebe370439ad162b29c6f5d3cad8921
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/rcu.c
@@ -0,0 +1,195 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_RCU_RD_GPHY0	(1 << 31)	/* GPHY0 */
+#define LTQ_RCU_RD_SRST		(1 << 30)	/* Global SW Reset */
+#define LTQ_RCU_RD_GPHY1	(1 << 29)	/* GPHY1 */
+#define LTQ_RCU_RD_ENMIP2	(1 << 28)	/* Enable NMI of PLL2 */
+#define LTQ_RCU_RD_REG25_PD	(1 << 26)	/* Power down 2.5V regulator */
+#define LTQ_RCU_RD_ENDINIT	(1 << 25)	/* FPI slave bus access */
+#define LTQ_RCU_RD_PPE_ATM_TC	(1 << 23)	/* PPE ATM TC */
+#define LTQ_RCU_RD_PCIE		(1 << 22)	/* PCI-E core */
+#define LTQ_RCU_RD_ETHSW	(1 << 21)	/* Ethernet switch */
+#define LTQ_RCU_RD_DSP_DEN	(1 << 20)	/* Enable DSP JTAG */
+#define LTQ_RCU_RD_TDM		(1 << 19)	/* TDM module interface */
+#define LTQ_RCU_RD_ENMIP1	(1 << 18)	/* Enable NMI of PLL1 */
+#define LTQ_RCU_RD_SWBCK	(1 << 17)	/* Switch backward compat */
+#define LTQ_RCU_RD_HSNAND	(1 << 16)	/* HSNAND controller */
+#define LTQ_RCU_RD_ENMIP0	(1 << 15)	/* Enable NMI of PLL0 */
+#define LTQ_RCU_RD_MC		(1 << 14)	/* Memory Controller */
+#define LTQ_RCU_RD_PCI		(1 << 13)	/* PCI core */
+#define LTQ_RCU_RD_PCIE_PHY	(1 << 12)	/* PCI-E Phy */
+#define LTQ_RCU_RD_DFE_CORE	(1 << 11)	/* DFE core */
+#define LTQ_RCU_RD_SDIO		(1 << 10)	/* SDIO core */
+#define LTQ_RCU_RD_DMA		(1 << 9)	/* DMA core */
+#define LTQ_RCU_RD_PPE		(1 << 8)	/* PPE core */
+#define LTQ_RCU_RD_DFE		(1 << 7)	/* DFE core */
+#define LTQ_RCU_RD_AHB		(1 << 6)	/* AHB bus */
+#define LTQ_RCU_RD_HRST_CFG	(1 << 5)	/* HW reset configuration */
+#define LTQ_RCU_RD_USB		(1 << 4)	/* USB and Phy core */
+#define LTQ_RCU_RD_PPE_DSP	(1 << 3)	/* PPE DSP interface */
+#define LTQ_RCU_RD_FPI		(1 << 2)	/* FPI bus */
+#define LTQ_RCU_RD_CPU		(1 << 1)	/* CPU subsystem */
+#define LTQ_RCU_RD_HRST		(1 << 0)	/* HW reset via HRST pin */
+
+#define LTQ_RCU_STAT_BOOT_SHIFT		17
+#define LTQ_RCU_STAT_BOOT_MASK		(0xF << LTQ_RCU_STAT_BOOT_SHIFT)
+#define LTQ_RCU_STAT_BOOT_H		(1 << 12)
+
+#define LTQ_RCU_GP_STRAP_CLOCKSOURCE	(1 << 15)
+
+struct ltq_rcu_regs {
+	u32	rsvd0[4];
+	u32	req;		/* Reset request */
+	u32	stat;		/* Reset status */
+	u32	usb0_cfg;	/* USB0 configure */
+	u32	gp_strap;	/* GPIO strapping */
+	u32	gfs_add0;	/* GPHY0 firmware base addr */
+	u32	stat2;		/* SLIC and USB reset status */
+	u32	pci_rdy;	/* PCI boot ready */
+	u32	ppe_conf;	/* PPE ethernet config */
+	u32	pcie_phy_con;	/* PCIE PHY config/status */
+	u32	usb1_cfg;	/* USB1 configure */
+	u32	usb_ana_cfg1a;	/* USB analog config 1a */
+	u32	usb_ana_cfg1b;	/* USB analog config 1b */
+	u32	rsvd1;
+	u32	gf_mdio_add;	/* GPHY0/1 MDIO address */
+	u32	req2;		/* SLIC and USB reset request */
+	u32	ahb_endian;	/* AHB bus endianess */
+	u32	rsvd2[4];
+	u32	gcc;		/* General CPU config */
+	u32	rsvd3;
+	u32	gfs_add1;	/* GPHY1 firmware base addr */
+};
+
+static struct ltq_rcu_regs *ltq_rcu_regs =
+	(struct ltq_rcu_regs *) CKSEG1ADDR(LTQ_RCU_BASE);
+
+u32 ltq_reset_map(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_RESET_CORE:
+	case LTQ_RESET_SOFT:
+		val = LTQ_RCU_RD_SRST | LTQ_RCU_RD_CPU | LTQ_RCU_RD_ENMIP2 |
+			LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_DMA:
+		val = LTQ_RCU_RD_DMA;
+		break;
+	case LTQ_RESET_ETH:
+		val = LTQ_RCU_RD_PPE | LTQ_RCU_RD_ETHSW;
+		break;
+	case LTQ_RESET_PHY:
+		val = LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_HARD:
+		val = LTQ_RCU_RD_HRST;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_reset_activate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+int ltq_reset_deactivate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+enum ltq_boot_select ltq_boot_select(void)
+{
+	u32 stat;
+	unsigned int bootstrap;
+
+	/*
+	 * Boot select value is built from bits 20-17 and bit 12.
+	 * The bit sequence is read as 4-2-1-0-3.
+	 */
+	stat = ltq_readl(&ltq_rcu_regs->stat);
+	bootstrap = ((stat & LTQ_RCU_STAT_BOOT_H) << 4) |
+		((stat & LTQ_RCU_STAT_BOOT_MASK) >> LTQ_RCU_STAT_BOOT_SHIFT);
+
+	switch (bootstrap) {
+	case 0:
+		return BOOT_NOR_NO_BOOTROM;
+	case 1:
+		return BOOT_RGMII1;
+	case 2:
+		return BOOT_NOR;
+	case 4:
+		return BOOT_UART_NO_EEPROM;
+	case 6:
+		return BOOT_PCI;
+	case 8:
+		return BOOT_UART;
+	case 10:
+		return BOOT_SPI;
+	case 12:
+		return BOOT_NAND;
+	default:
+		return BOOT_UNKNOWN;
+	}
+}
+
+void ltq_rcu_gphy_boot(unsigned int id, ulong addr)
+{
+	u32 module;
+	void *gfs_add;
+
+	switch (id) {
+	case 0:
+		module = LTQ_RCU_RD_GPHY0;
+		gfs_add = &ltq_rcu_regs->gfs_add0;
+		break;
+	case 1:
+		module = LTQ_RCU_RD_GPHY1;
+		gfs_add = &ltq_rcu_regs->gfs_add1;
+		break;
+	default:
+		BUG();
+	}
+
+	/* Stop and reset GPHY */
+	ltq_setbits(&ltq_rcu_regs->req, module);
+
+	/* Configure firmware and boot address */
+	ltq_writel(gfs_add, CPHYSADDR(addr & 0xFFFFC000));
+
+	/* Start GPHY by releasing reset */
+	ltq_clrbits(&ltq_rcu_regs->req, module);
+}
diff --git a/arch/mips/include/asm/arch-danube/config.h b/arch/mips/include/asm/arch-danube/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..fb380ced90041a8e33e828bd88bc913b600eaabd
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/config.h
@@ -0,0 +1,164 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * Common board configuration for Lantiq XWAY Danube family
+ *
+ * Use following defines in your board config to enable specific features
+ * and drivers for this SoC:
+ *
+ * CONFIG_LTQ_SUPPORT_UART
+ * - support the Danube ASC/UART interface and console
+ *
+ * CONFIG_LTQ_SUPPORT_NOR_FLASH
+ * - support a parallel NOR flash via the CFI interface in flash bank 0
+ *
+ * CONFIG_LTQ_SUPPORT_ETHERNET
+ * - support the Danube ETOP and MAC interface
+ *
+ * CONFIG_LTQ_SUPPORT_SPI_FLASH
+ * - support the Danube SPI interface and serial flash drivers
+ * - specific SPI flash drivers must be configured separately
+ */
+
+#ifndef __DANUBE_CONFIG_H__
+#define __DANUBE_CONFIG_H__
+
+/* CPU and SoC type */
+#define CONFIG_SOC_LANTIQ
+#define CONFIG_SOC_XWAY_DANUBE
+
+/* Cache configuration */
+#define CONFIG_SYS_MIPS_CACHE_MODE	CONF_CM_CACHABLE_NONCOHERENT
+#define CONFIG_SYS_DCACHE_SIZE		(16 * 1024)
+#define CONFIG_SYS_ICACHE_SIZE		(16 * 1024)
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#define CONFIG_SYS_MIPS_CACHE_EXT_INIT
+
+/*
+ * Supported clock modes
+ * PLL0 clock output is 333 MHz
+ * PLL1 clock output is 262.144 MHz
+ */
+#define LTQ_CLK_CPU_333_DDR_167		0	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_111_DDR_111		1	/* Base PLL0, OCP 1 */
+
+/* CPU speed */
+#define CONFIG_SYS_CLOCK_MODE		LTQ_CLK_CPU_333_DDR_167
+#define CONFIG_SYS_MIPS_TIMER_FREQ	166666667
+#define CONFIG_SYS_HZ			1000
+
+/* RAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_MEMTEST_START	0x81000000
+#define CONFIG_SYS_MEMTEST_END		0x82000000
+#define CONFIG_SYS_LOAD_ADDR		0x81000000
+#define CONFIG_SYS_INIT_SP_OFFSET	0x4000
+
+/* SRAM */
+#define CONFIG_SYS_SRAM_BASE		0xBE180000
+#define CONFIG_SYS_SRAM_SIZE		0x10000
+
+/* ASC/UART driver and console */
+#define CONFIG_LANTIQ_SERIAL
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* GPIO */
+#define CONFIG_LANTIQ_GPIO
+#define CONFIG_LTQ_GPIO_MAX_BANKS	2
+
+/* FLASH driver */
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+#define CONFIG_SYS_FLASH_BASE		0xB0000000
+#define CONFIG_FLASH_16BIT
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	50
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+
+#define CONFIG_CMD_FLASH
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_NOR_FLASH */
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_LANTIQ_SPI
+#define CONFIG_SPI_FLASH
+
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#define CONFIG_NAND_LANTIQ
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0xB4000000
+
+#define CONFIG_CMD_NAND
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_ETHERNET)
+#define CONFIG_LANTIQ_DMA
+#define CONFIG_LANTIQ_DANUBE_ETOP
+
+#define CONFIG_PHYLIB
+#define CONFIG_MII
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#endif
+
+#define CONFIG_SPL_MAX_SIZE		(32 * 1024)
+#define CONFIG_SPL_BSS_MAX_SIZE		(8 * 1024)
+#define CONFIG_SPL_STACK_MAX_SIZE	(8 * 1024)
+#define CONFIG_SPL_MALLOC_MAX_SIZE	(32 * 1024)
+/*#define CONFIG_SPL_STACK_BSS_IN_SRAM*/
+
+#if defined(CONFIG_SPL_STACK_BSS_IN_SRAM)
+#define CONFIG_SPL_STACK_BASE		(CONFIG_SYS_SRAM_BASE + \
+					CONFIG_SPL_MAX_SIZE + \
+					CONFIG_SPL_STACK_MAX_SIZE - 1)
+#define CONFIG_SPL_BSS_BASE	  	(CONFIG_SPL_STACK_BASE + 1)
+#define CONFIG_SPL_MALLOC_BASE		(CONFIG_SYS_SDRAM_BASE + \
+					CONFIG_SYS_INIT_SP_OFFSET)
+#else
+#define CONFIG_SPL_STACK_BASE		(CONFIG_SYS_SDRAM_BASE + \
+					CONFIG_SYS_INIT_SP_OFFSET + \
+					CONFIG_SPL_STACK_MAX_SIZE - 1)
+#define CONFIG_SPL_BSS_BASE		(CONFIG_SPL_STACK_BASE + 1)
+#define CONFIG_SPL_MALLOC_BASE		(CONFIG_SPL_BSS_BASE + \
+					CONFIG_SPL_BSS_MAX_SIZE)
+#endif
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define CONFIG_SYS_TEXT_BASE		0xa0100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SYS_DISABLE_CACHE
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_SYS_TEXT_BASE		0xB0000000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SPL_TEXT_BASE		0xB0000000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR) || defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_XWAY_EBU_BOOTCFG	0x688C688C
+#define CONFIG_XWAY_SWAP_BYTES
+#endif
+
+#define	CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#endif /* __DANUBE_CONFIG_H__ */
diff --git a/arch/mips/include/asm/arch-danube/gpio.h b/arch/mips/include/asm/arch-danube/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..f760c300a802369157afdc99aa393cd1d656973f
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/gpio.h
@@ -0,0 +1,13 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __DANUBE_GPIO_H__
+#define __DANUBE_GPIO_H__
+
+#include <asm/lantiq/gpio.h>
+
+#endif /* __DANUBE_GPIO_H__ */
diff --git a/arch/mips/include/asm/arch-danube/nand.h b/arch/mips/include/asm/arch-danube/nand.h
new file mode 100644
index 0000000000000000000000000000000000000000..3349efc0bc943c044a7ee32c9b53d1b17bb44b7f
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/nand.h
@@ -0,0 +1,14 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __DANUBE_NAND_H__
+#define __DANUBE_NAND_H__
+
+struct nand_chip;
+int ltq_nand_init(struct nand_chip *nand);
+
+#endif /* __DANUBE_NAND_H__ */
diff --git a/arch/mips/include/asm/arch-danube/soc.h b/arch/mips/include/asm/arch-danube/soc.h
new file mode 100644
index 0000000000000000000000000000000000000000..a0e8fd0c625eba5aaf958c48279ca141cb5289d4
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/soc.h
@@ -0,0 +1,39 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __DANUBE_SOC_H__
+#define __DANUBE_SOC_H__
+
+#define LTQ_ASC0_BASE			0x1E100400
+#define LTQ_SPI_BASE			0x1E100800
+#define LTQ_GPIO_BASE			0x1E100B00
+#define LTQ_SSIO_BASE			0x1E100BB0
+#define LTQ_ASC1_BASE			0x1E100C00
+#define LTQ_DMA_BASE			0x1E104100
+
+#define LTQ_EBU_BASE			0x1E105300
+#define LTQ_EBU_REGION0_BASE		0x10000000
+#define LTQ_EBU_REGION1_BASE		0x14000000
+#define LTQ_EBU_NAND_BASE		(LTQ_EBU_BASE + 0xB0)
+
+#define LTQ_PPE_BASE			0x1E180000
+#define LTQ_PPE_ETOP_BASE		(LTQ_PPE_BASE + 0x11800)
+#define LTQ_PPE_ENET0_BASE		(LTQ_PPE_BASE + 0x11840)
+
+#define LTQ_PMU_BASE			0x1F102000
+#define LTQ_CGU_BASE			0x1F103000
+#define LTQ_MPS_BASE			0x1F107000
+#define LTQ_CHIPID_BASE			(LTQ_MPS_BASE + 0x340)
+#define LTQ_RCU_BASE			0x1F203000
+
+#define LTQ_MC_GEN_BASE			0x1F800000
+#define LTQ_MC_SDR_BASE			0x1F800200
+#define LTQ_MC_DDR_BASE			0x1F801000
+#define LTQ_MC_DDR_DC_OFFSET(x)		(x * 0x10)
+
+#endif /* __DANUBE_SOC_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/config.h b/arch/mips/include/asm/arch-vrx200/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..a6264a82bd213b39b00c68dc92ed8280071fbc12
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/config.h
@@ -0,0 +1,185 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * Common board configuration for Lantiq XWAY VRX200 family
+ *
+ * Use following defines in your board config to enable specific features
+ * and drivers for this SoC:
+ *
+ * CONFIG_LTQ_SUPPORT_UART
+ * - support the VRX200 ASC/UART interface and console
+ *
+ * CONFIG_LTQ_SUPPORT_NOR_FLASH
+ * - support a parallel NOR flash via the CFI interface in flash bank 0
+ *
+ * CONFIG_LTQ_SUPPORT_SPI_FLASH
+ * - support the VRX200 SPI interface and serial flash drivers
+ * - specific SPI flash drivers must be configured separately
+ *
+ * CONFIG_LTQ_SUPPORT_ETHERNET
+ * - support the VRX200 internal switch
+ *
+ * CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH
+ * - build a preloader that runs in the internal SRAM and loads
+ *   the U-Boot from SPI flash into RAM
+ */
+
+#ifndef __VRX200_CONFIG_H__
+#define __VRX200_CONFIG_H__
+
+/* CPU and SoC type */
+#define CONFIG_SOC_LANTIQ
+#define CONFIG_SOC_XWAY_VRX200
+
+/* Cache configuration */
+#define CONFIG_SYS_MIPS_CACHE_MODE	CONF_CM_CACHABLE_NONCOHERENT
+#define CONFIG_SYS_DCACHE_SIZE		(32 * 1024)
+#define CONFIG_SYS_ICACHE_SIZE		(32 * 1024)
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#define CONFIG_SYS_MIPS_CACHE_EXT_INIT
+
+/*
+ * Supported clock modes
+ * PLL0 clock output is 1000 MHz
+ * PLL1 clock output is 393.219 MHz
+ */
+#define LTQ_CLK_CPU_600_DDR_300	0	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_600_DDR_200	1	/* Base PLL0, OCP 3 */
+#define LTQ_CLK_CPU_500_DDR_250	2	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_500_DDR_200	3	/* Base PLL0, OCP 2.5 */
+#define LTQ_CLK_CPU_333_DDR_167	4	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_167_DDR_167	5	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_125_DDR_125	6	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_393_DDR_197	7	/* Base PLL1, OCP 2 */
+#define LTQ_CLK_CPU_197_DDR_197	8	/* Base PLL1, OCP 1 */
+
+/* CPU speed */
+#define CONFIG_SYS_CLOCK_MODE		LTQ_CLK_CPU_500_DDR_250
+#define CONFIG_SYS_MIPS_TIMER_FREQ	250000000
+#define CONFIG_SYS_HZ			1000
+
+/* RAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_SDRAM_BASE_UC	0xa0000000
+#define CONFIG_SYS_MEMTEST_START	0x81000000
+#define CONFIG_SYS_MEMTEST_END		0x82000000
+#define CONFIG_SYS_LOAD_ADDR		0x81000000
+#define CONFIG_SYS_INIT_SP_OFFSET	(32 * 1024)
+
+/* SRAM */
+#define CONFIG_SYS_SRAM_BASE		0xBE220000
+#define CONFIG_SYS_SRAM_SIZE		0x10000
+
+/* ASC/UART driver and console */
+#define CONFIG_LANTIQ_SERIAL
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* GPIO */
+#define CONFIG_LANTIQ_GPIO
+#define CONFIG_LTQ_GPIO_MAX_BANKS	3
+#define CONFIG_LTQ_HAS_GPIO_BANK3
+
+/* FLASH driver */
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+#define CONFIG_SYS_FLASH_BASE		0xB0000000
+#define CONFIG_FLASH_16BIT
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	50
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+
+#define CONFIG_CMD_FLASH
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_NOR_FLASH */
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_LANTIQ_SPI
+#define CONFIG_SPI_FLASH
+
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#define CONFIG_NAND_LANTIQ
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0xB4000000
+
+#define CONFIG_CMD_NAND
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_ETHERNET)
+#define CONFIG_LANTIQ_DMA
+#define CONFIG_LANTIQ_VRX200_SWITCH
+#define CONFIG_PHY_LANTIQ
+
+#define CONFIG_SYS_RX_ETH_BUFFER	8
+#define CONFIG_PHYLIB
+#define CONFIG_MII
+#define CONFIG_UDP_CHECKSUM
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#endif
+
+#define CONFIG_SPL_MAX_SIZE		(32 * 1024)
+#define CONFIG_SPL_BSS_MAX_SIZE		(8 * 1024)
+#define CONFIG_SPL_STACK_MAX_SIZE	(8 * 1024)
+#define CONFIG_SPL_MALLOC_MAX_SIZE	(32 * 1024)
+#define CONFIG_SPL_STACK_BSS_IN_SRAM
+
+#if defined(CONFIG_SPL_STACK_BSS_IN_SRAM)
+#define CONFIG_SPL_STACK_BASE		(CONFIG_SYS_SRAM_BASE + \
+					CONFIG_SPL_MAX_SIZE + \
+					CONFIG_SPL_STACK_MAX_SIZE - 1)
+#define CONFIG_SPL_BSS_BASE	  	(CONFIG_SPL_STACK_BASE + 1)
+#define CONFIG_SPL_MALLOC_BASE		(CONFIG_SYS_SDRAM_BASE + \
+					CONFIG_SYS_INIT_SP_OFFSET)
+#else
+#define CONFIG_SPL_STACK_BASE		(CONFIG_SYS_SDRAM_BASE + \
+					CONFIG_SYS_INIT_SP_OFFSET + \
+					CONFIG_SPL_STACK_MAX_SIZE - 1)
+#define CONFIG_SPL_BSS_BASE		(CONFIG_SPL_STACK_BASE + 1)
+#define CONFIG_SPL_MALLOC_BASE		(CONFIG_SPL_BSS_BASE + \
+					CONFIG_SPL_BSS_MAX_SIZE)
+#endif
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define CONFIG_SYS_TEXT_BASE		0xA0100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SYS_DISABLE_CACHE
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_SYS_TEXT_BASE		0xB0000000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SPL_TEXT_BASE		0xBE220000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SPL_TEXT_BASE		0xB0000000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR) || defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_XWAY_EBU_BOOTCFG	0x688C688C
+#define CONFIG_XWAY_SWAP_BYTES
+#endif
+
+#define	CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#endif /* __VRX200_CONFIG_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gphy.h b/arch/mips/include/asm/arch-vrx200/gphy.h
new file mode 100644
index 0000000000000000000000000000000000000000..4dd5e62496a56f513d9bfe99ffee3cc39e4587cc
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gphy.h
@@ -0,0 +1,66 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __VRX200_GPHY_H__
+#define __VRX200_GPHY_H__
+
+enum ltq_gphy_clk {
+	/* XTAL 36 MHz input */
+	LTQ_GPHY_CLK_36MHZ_XTAL = 1,
+	/* 25 MHz from PLL0 with divider */
+	LTQ_GPHY_CLK_25MHZ_PLL0 = 2,
+	/* derived from PLL2 output (XTAL is 36 MHz) */
+	LTQ_GPHY_CLK_24MHZ_PLL2 = 3,
+	/* 25 MHz Clock from Pin GPIO3 */
+	LTQ_GPHY_CLK_25MHZ_GPIO3 = 4,
+};
+
+/*
+ * Load PHY11G firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a1x_load(ulong addr);
+
+/*
+ * Load PHY11G firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a2x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a1x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a2x_load(ulong addr);
+
+/*
+ * Set clock source of internal GPHYs
+ *
+ * According registers resides in CGU address space. Thus this function
+ * is implemented by the CGU driver.
+ */
+extern void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk);
+
+/*
+ * Boot internal GPHY with id from given RAM address
+ *
+ * According registers resides in RCU address space. Thus this function
+ * is implemented by the RCU driver.
+ */
+extern void ltq_rcu_gphy_boot(unsigned int id, ulong addr);
+
+#endif /* __VRX200_GPHY_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gpio.h b/arch/mips/include/asm/arch-vrx200/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..0b343b80b57dbc4dfb8abe48ded207db8a0e1aad
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gpio.h
@@ -0,0 +1,13 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __VRX200_GPIO_H__
+#define __VRX200_GPIO_H__
+
+#include <asm/lantiq/gpio.h>
+
+#endif /* __VRX200_GPIO_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/nand.h b/arch/mips/include/asm/arch-vrx200/nand.h
new file mode 100644
index 0000000000000000000000000000000000000000..2ffd6de34bcfdecc805ee28e922b388b2c51bb22
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/nand.h
@@ -0,0 +1,14 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __VRX200_NAND_H__
+#define __VRX200_NAND_H__
+
+struct nand_chip;
+int ltq_nand_init(struct nand_chip *nand);
+
+#endif /* __VRX200_NAND_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/soc.h b/arch/mips/include/asm/arch-vrx200/soc.h
new file mode 100644
index 0000000000000000000000000000000000000000..73a92a15fc71412b3610c35bb5cd7ddbdf55c018
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/soc.h
@@ -0,0 +1,46 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __VRX200_SOC_H__
+#define __VRX200_SOC_H__
+
+#define LTQ_ASC0_BASE			0x1E100400
+#define LTQ_SPI_BASE			0x1E100800
+#define LTQ_GPIO_BASE			0x1E100B00
+#define LTQ_SSIO_BASE			0x1E100BB0
+#define LTQ_ASC1_BASE			0x1E100C00
+#define LTQ_DMA_BASE			0x1E104100
+
+#define LTQ_EBU_BASE			0x1E105300
+#define LTQ_EBU_REGION0_BASE		0x10000000
+#define LTQ_EBU_REGION1_BASE		0x14000000
+#define LTQ_EBU_NAND_BASE		(LTQ_EBU_BASE + 0xB0)
+
+#define LTQ_SWITCH_BASE			0x1E108000
+#define LTQ_SWITCH_CORE_BASE		LTQ_SWITCH_BASE
+#define LTQ_SWITCH_TOP_PDI_BASE		LTQ_SWITCH_CORE_BASE
+#define LTQ_SWITCH_BM_PDI_BASE		(LTQ_SWITCH_CORE_BASE + 4 * 0x40)
+#define LTQ_SWITCH_MAC_PDI_0_BASE	(LTQ_SWITCH_CORE_BASE + 4 * 0x900)
+#define LTQ_SWITCH_MAC_PDI_X_BASE(x)	(LTQ_SWITCH_MAC_PDI_0_BASE + x * 0x30)
+#define LTQ_SWITCH_TOPLEVEL_BASE	(LTQ_SWITCH_BASE + 4 * 0xC40)
+#define LTQ_SWITCH_MDIO_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE)
+#define LTQ_SWITCH_MII_PDI_BASE		(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x36)
+#define LTQ_SWITCH_PMAC_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x82)
+
+#define LTQ_PMU_BASE			0x1F102000
+#define LTQ_CGU_BASE			0x1F103000
+#define LTQ_DCDC_BASE			0x1F106A00
+#define LTQ_MPS_BASE			0x1F107000
+#define LTQ_CHIPID_BASE			(LTQ_MPS_BASE + 0x340)
+#define LTQ_RCU_BASE			0x1F203000
+
+#define LTQ_MC_GLOBAL_BASE		0x1F400000
+#define LTQ_MC_DDR_BASE			0x1F401000
+#define LTQ_MC_DDR_CCR_OFFSET(x)	(x * 0x10)
+
+#endif /* __VRX200_SOC_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/switch.h b/arch/mips/include/asm/arch-vrx200/switch.h
new file mode 100644
index 0000000000000000000000000000000000000000..58ab8576ac64edd1013539336647b3f330466d0f
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/switch.h
@@ -0,0 +1,514 @@
+/*
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *   Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __VR9_SWITCH_H__
+#define __VR9_SWITCH_H__
+
+/* Switch core registers */
+struct vr9_switch_core_regs {
+	__be32 swres;
+	/* TODO: implement registers */
+	__be32 rsvd0[0x3f];
+};
+
+/* Switch buffer management registers */
+struct vr9_switch_bm_regs {
+	struct bm_core {
+		__be32 ram_val3;	/* RAM value 3 */
+		__be32 ram_val2;	/* RAM value 2 */
+		__be32 ram_val1;	/* RAM value 1 */
+		__be32 ram_val0;	/* RAM value 0 */
+		__be32 ram_addr;	/* RAM address */
+		__be32 ram_ctrl;	/* RAM access control */
+		__be32 fsqm_gctrl;	/* Free segment queue global control */
+		__be32 cons_sel;	/* Number of consumed segments */
+		__be32 cons_pkt;	/* Number of consumed packet pointers */
+		__be32 gctrl;		/* Global control */
+		__be32 queue_gctrl;	/* Queue manager global control */
+		/* TODO: implement registers */
+		__be32 rsvd0[0x35];
+	} core;
+
+	struct bm_port {
+		__be32 pcfg;		/* Port config */
+		__be32 rmon_ctrl;	/* RMON control */
+	} port[13];
+
+	__be32 rsvd0[0x66];
+
+	struct bm_queue {
+		__be32 rsvd0;
+		__be32 pqm_rs;		/* Packet queue manager rate shape assignment */
+	} queue[32];
+
+	struct bm_shaper {
+		__be32 ctrl;		/* Rate shaper control */
+		__be32 cbs;		/* Rate shaper committed burst size */
+		__be32 ibs;		/* Rate shaper instantaneous burst size */
+		__be32 cir_ext;		/* Rate shaper rate exponent */
+		__be32 cir_mant;	/* Rate shaper rate mantissa */
+	} shaper[16];
+
+	__be32 rsvd1[0x2a8];
+};
+
+/* Switch parser and classification engine registers */
+struct vr9_switch_pce_regs {
+	struct pce_core {
+		__be32 tbl_key[16];	/* Table key data */
+		__be32 tbl_mask;	/* Table mask */
+		__be32 tbl_val[5];	/* Table value */
+		__be32 tbl_addr;	/* Table entry address */
+		__be32 tbl_ctrl;	/* Table access control */
+		__be32 tbl_stat;	/* Table general status */
+		__be32 age_0;		/* Aging counter config 0 */
+		__be32 age_1;		/* Aging counter config 1 */
+		__be32 pmap_1;		/* Port map (monitoring) */
+		__be32 pmap_2;		/* Port map (multicast) */
+		__be32 pmap_3;		/* Port map (unknown unicast) */
+		__be32 gctrl_0;		/* Global control 0 */
+		__be32 gctrl_1;		/* Global control 1 */
+		__be32 tcm_gctrl;	/* Three-color marker global control */
+		__be32 igmp_ctrl;	/* IGMP control */
+		__be32 igmp_drpm;	/* IGMP default router port map */
+		__be32 igmp_age_0;	/* IGMP aging 0 */
+		__be32 igmp_age_1;	/* IGMP aging 1 */
+		__be32 igmp_stat;	/* IGMP status */
+		__be32 wol_gctrl;	/* Wake-on-LAN control */
+		__be32 wol_da_0;	/* Wake-on-LAN destination address 0 */
+		__be32 wol_da_1;	/* Wake-on-LAN destination address 1 */
+		__be32 wol_da_2;	/* Wake-on-LAN destination address 2 */
+		__be32 wol_pw_0;	/* Wake-on-LAN password 0 */
+		__be32 wol_pw_1;	/* Wake-on-LAN password 1 */
+		__be32 wol_pw_2;	/* Wake-on-LAN password 2 */
+		__be32 ier_0;		/* PCE global interrupt enable 0 */
+		__be32 ier_1;		/* PCE global interrupt enable 1 */
+		__be32 isr_0;		/* PCE global interrupt status 0 */
+		__be32 isr_1;		/* PCE global interrupt status 1 */
+		__be32 parser_stat;	/* Parser status */
+		__be32 rsvd0[0x6];
+	} core;
+
+	__be32 rsvd0[0x10];
+
+	struct pce_port {
+		__be32 pctrl_0;		/* Port control 0 */
+		__be32 pctrl_1;		/* Port control 1 */
+		__be32 pctrl_2;		/* Port control 2 */
+		__be32 pctrl_3;		/* Port control 3 */
+		__be32 wol_ctrl;	/* Wake-on-LAN control */
+		__be32 vlan_ctrl;	/* VLAN control */
+		__be32 def_pvid;	/* Default port VID */
+		__be32 pstat;		/* Port status */
+		__be32 pier;		/* Interrupt enable */
+		__be32 pisr;		/* Interrupt status */
+	} port[13];
+
+	__be32 rsvd1[0x7e];
+
+	struct pce_meter {
+		/* TODO: implement registers */
+		__be32 rsvd0[0x7];
+	} meter[8];
+
+	__be32 rsvd2[0x308];
+};
+
+static inline unsigned int to_pce_tbl_key_id(unsigned int id)
+{
+	BUG_ON(id > 15);
+
+	return 15 - id;
+}
+
+static inline unsigned int to_pce_tbl_value_id(unsigned int id)
+{
+	BUG_ON(id > 4);
+
+	return 4 - id;
+}
+
+/* Switch ethernet MAC registers */
+struct vr9_switch_mac_regs {
+	struct mac_core {
+		__be32 test;		/* MAC test */
+		__be32 pfad_cfg;	/* Pause frame source address config */
+		__be32 pfsa_0;		/* Pause frame source address 0 */
+		__be32 pfsa_1;		/* Pause frame source address 1 */
+		__be32 pfsa_2;		/* Pause frame source address 2 */
+		__be32 flen;		/* Frame length */
+		__be32 vlan_etype_0;	/* VLAN ethertype 0 */
+		__be32 vlan_etype_1;	/* VLAN ethertype 1 */
+		__be32 ier;		/* Interrupt enable */
+		__be32 isr;		/* Interrupt status */
+		__be32 rsvd0[0x36];
+	} core;
+
+	struct mac_port {
+		__be32 pstat;		/* Port status */
+		__be32 pisr;		/* Interrupt status */
+		__be32 pier;		/* Interrupt enable */
+		__be32 ctrl_0;		/* Control 0 */
+		__be32 ctrl_1;		/* Control 1 */
+		__be32 ctrl_2;		/* Control 2 */
+		__be32 ctrl_3;		/* Control 3 */
+		__be32 ctrl_4;		/* Control 4 */
+		__be32 ctrl_5;		/* Control 5 */
+		__be32 rsvd0[0x2];
+		__be32 testen;		/* Test enable */
+	} port[13];
+
+	__be32 rsvd0[0xa4];
+};
+
+/* Switch Fetch DMA registers */
+struct vr9_switch_fdma_regs {
+	struct fdma_core {
+		__be32 ctrl;		/* FDMA control */
+		__be32 stetype;		/* Special tag ethertype control */
+		__be32 vtetype;		/* VLAN tag ethertype control */
+		__be32 stat;		/* FDMA status */
+		__be32 ier;		/* FDMA interrupt enable */
+		__be32 isr;		/* FDMA interrupt status */
+	} core;
+
+	__be32 rsvd0[0x3a];
+
+	struct fdma_port {
+		__be32 pctrl;		/* Port control */
+		__be32 prio;		/* Port priority */
+		__be32 pstat_0;		/* Port status 0 */
+		__be32 pstat_1;		/* Port status 1 */
+		__be32 tstamp_0;	/* Egress time stamp 0 */
+		__be32 tstamp_1;	/* Egress time stamp 1 */
+	} port[13];
+
+	__be32 rsvd1[0x72];
+};
+
+/* Switch Store DMA registers */
+struct vr9_switch_sdma_regs {
+	struct sdma_core {
+		__be32 ctrl;		/* SDMA Control */
+		__be32 fcthr_1;		/* Flow control threshold 1 */
+		__be32 rsvd0;
+		__be32 fcthr_3;		/* Flow control threshold 3 */
+		__be32 fcthr_4;		/* Flow control threshold 4 */
+		__be32 fcthr_5;		/* Flow control threshold 5 */
+		__be32 fcthr_6;		/* Flow control threshold 6 */
+		__be32 fcthr_7;		/* Flow control threshold 7 */
+		__be32 stat_0;		/* SDMA status 0 */
+		__be32 stat_1;		/* SDMA status 1 */
+		__be32 stat_2;		/* SDMA status 2 */
+		__be32 ier;		/* SDMA interrupt enable */
+		__be32 isr;		/* SDMA interrupt status */
+	} core;
+
+	__be32 rsvd0[0x73];
+
+	struct sdma_port {
+		__be32 pctrl;		/* Port control */
+		__be32 prio;		/* Port priority */
+		__be32 pstat_0;		/* Port status 0 */
+		__be32 pstat_1;		/* Port status 1 */
+		__be32 tstamp_0;	/* Ingress time stamp 0 */
+		__be32 tstamp_1;	/* Ingress time stamp 1 */
+	} port[13];
+
+	__be32 rsvd1[0x32];
+};
+
+/* Switch MDIO control and status registers */
+struct vr9_switch_mdio_regs {
+	__be32 glob_ctrl;	/* Global control 0 */
+	__be32 rsvd0[7];
+	__be32 mdio_ctrl;	/* MDIO control */
+	__be32 mdio_read;	/* MDIO read data */
+	__be32 mdio_write;	/* MDIO write data */
+	__be32 mdc_cfg_0;	/* MDC clock configuration 0 */
+	__be32 mdc_cfg_1;	/* MDC clock configuration 1 */
+	__be32 rsvd1[0x3];
+	__be32 phy_addr[6];	/* PHY address port 5..0 */
+	__be32 mdio_stat[6];	/* MDIO PHY polling status port 0..5 */
+	__be32 aneg_eee[6];	/* EEE auto-neg overrides port 0..5 */
+	__be32 rsvd2[0x14];
+};
+
+static inline unsigned int to_mdio_phyaddr_id(unsigned int id)
+{
+	BUG_ON(id > 5);
+
+	return 5 - id;
+}
+
+/* Switch xMII control registers */
+struct vr9_switch_mii_regs {
+	__be32 mii_cfg0;	/* xMII port 0 configuration */
+	__be32 pcdu0;		/* Port 0 clock delay configuration */
+	__be32 mii_cfg1;	/* xMII port 1 configuration */
+	__be32 pcdu1;		/* Port 1 clock delay configuration */
+	__be32 rsvd0[0x6];
+	__be32 mii_cfg5;	/* xMII port 5 configuration */
+	__be32 pcdu5;		/* Port 5 clock delay configuration */
+	__be32 rsvd1[0x14];
+	__be32 rxb_ctl_0;	/* Port 0 receive buffer control */
+	__be32 rxb_ctl_1;	/* Port 1 receive buffer control */
+	__be32 rxb_ctl_5;	/* Port 5 receive buffer control */
+	__be32 rsvd2[0x28];
+	__be32 dbg_ctl;		/* Debug control */
+};
+
+/* Switch Pseudo-MAC registers */
+struct vr9_switch_pmac_regs {
+	__be32 hd_ctl;		/* PMAC header control */
+	__be32 tl;		/* PMAC type/length */
+	__be32 sa1;		/* PMAC source address 1 */
+	__be32 sa2;		/* PMAC source address 2 */
+	__be32 sa3;		/* PMAC source address 3 */
+	__be32 da1;		/* PMAC destination address 1 */
+	__be32 da2;		/* PMAC destination address 2 */
+	__be32 da3;		/* PMAC destination address 3 */
+	__be32 vlan;		/* PMAC VLAN */
+	__be32 rx_ipg;		/* PMAC interpacket gap in RX direction */
+	__be32 st_etype;	/* PMAC special tag ethertype */
+	__be32 ewan;		/* PMAC ethernet WAN group */
+	__be32 ctl;		/* PMAC control */
+	__be32 rsvd0[0x2];
+};
+
+struct vr9_switch_regs {
+	struct vr9_switch_core_regs core;
+	struct vr9_switch_bm_regs bm;
+	struct vr9_switch_pce_regs pce;
+	struct vr9_switch_mac_regs mac;
+	struct vr9_switch_fdma_regs fdma;
+	struct vr9_switch_sdma_regs sdma;
+	struct vr9_switch_mdio_regs mdio;
+	struct vr9_switch_mii_regs mii;
+	struct vr9_switch_pmac_regs pmac;
+};
+
+static inline void *to_pce_tbl_key(struct vr9_switch_regs *regs,
+						unsigned int id)
+{
+	return &regs->pce.core.tbl_key[to_pce_tbl_key_id(id)];
+}
+
+static inline void *to_pce_tbl_value(struct vr9_switch_regs *regs,
+						unsigned int id)
+{
+	return &regs->pce.core.tbl_val[to_pce_tbl_value_id(id)];
+}
+
+static inline void *to_mac_ctrl(struct vr9_switch_regs *regs,
+					unsigned int id, unsigned int ctrl)
+{
+	struct mac_port *mac = &regs->mac.port[id];
+
+	switch (ctrl) {
+	case 0:
+		return &mac->ctrl_0;
+	case 1:
+		return &mac->ctrl_1;
+	case 2:
+		return &mac->ctrl_2;
+	case 3:
+		return &mac->ctrl_3;
+	case 4:
+		return &mac->ctrl_4;
+	case 5:
+		return &mac->ctrl_5;
+	default:
+		return NULL;
+	}
+}
+
+static inline void *to_mdio_phyaddr(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	return &regs->mdio.phy_addr[to_mdio_phyaddr_id(id)];
+}
+
+static inline void *to_mii_miicfg(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	switch (id) {
+	case 0:
+		return &regs->mii.mii_cfg0;
+	case 1:
+		return &regs->mii.mii_cfg1;
+	case 5:
+		return &regs->mii.mii_cfg5;
+	default:
+		return NULL;
+	}
+}
+
+static inline void *to_mii_pcdu(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	switch (id) {
+	case 0:
+		return &regs->mii.pcdu0;
+	case 1:
+		return &regs->mii.pcdu1;
+	case 5:
+		return &regs->mii.pcdu5;
+	default:
+		return NULL;
+	}
+}
+
+#define VR9_SWITCH_REG_OFFSET(reg)	(4 * (reg))
+
+#define BUILD_CHECK_VR9_REG(name, offset)	\
+	BUILD_BUG_ON(offsetof(struct vr9_switch_regs, name) != (4 * offset))
+
+static inline void build_check_vr9_registers(void)
+{
+	BUILD_CHECK_VR9_REG(core, 0x0);
+	BUILD_CHECK_VR9_REG(bm.core, 0x40);
+	BUILD_CHECK_VR9_REG(bm.core.queue_gctrl, 0x4a);
+	BUILD_CHECK_VR9_REG(bm.port[0], 0x80);
+	BUILD_CHECK_VR9_REG(bm.queue, 0x100);
+	BUILD_CHECK_VR9_REG(bm.shaper, 0x140);
+	BUILD_CHECK_VR9_REG(pce.core, 0x438);
+	BUILD_CHECK_VR9_REG(pce.core.tbl_ctrl, 0x44f);
+	BUILD_CHECK_VR9_REG(pce.core.parser_stat, 0x469);
+	BUILD_CHECK_VR9_REG(pce.port[0], 0x480);
+	BUILD_CHECK_VR9_REG(pce.meter[0], 0x580);
+	BUILD_CHECK_VR9_REG(mac.core, 0x8c0);
+	BUILD_CHECK_VR9_REG(mac.port[0].pstat, 0x900);
+	BUILD_CHECK_VR9_REG(mac.port[0].ctrl_0, 0x903);
+	BUILD_CHECK_VR9_REG(mac.port[1].pstat, 0x90c);
+	BUILD_CHECK_VR9_REG(mac.port[1].ctrl_0, 0x90f);
+	BUILD_CHECK_VR9_REG(mac.port[2].pstat, 0x918);
+	BUILD_CHECK_VR9_REG(mac.port[2].ctrl_0, 0x91b);
+	BUILD_CHECK_VR9_REG(fdma.core, 0xa40);
+	BUILD_CHECK_VR9_REG(fdma.port[0], 0xa80);
+	BUILD_CHECK_VR9_REG(sdma.core, 0xb40);
+	BUILD_CHECK_VR9_REG(sdma.port[0], 0xbc0);
+	BUILD_CHECK_VR9_REG(mdio, 0xc40);
+	BUILD_CHECK_VR9_REG(mii, (0xc40 + 0x36));
+	BUILD_CHECK_VR9_REG(pmac, (0xc40 + 0x82));
+}
+
+#define BM_GCTRL_F_SRES		1
+
+#define MAC_CTRL0_BM		(1 << 12)
+#define MAC_CTRL0_APADEN	(1 << 11)
+#define MAC_CTRL0_VPAD2EN	(1 << 10)
+#define MAC_CTRL0_VPADEN	(1 << 9)
+#define MAC_CTRL0_PADEN		(1 << 8)
+#define MAC_CTRL0_FCS		(1 << 7)
+#define MAC_CTRL0_FCON_SHIFT	4
+#define MAC_CTRL0_FCON_AUTO	(0x0 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_RX	(0x1 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_TX	(0x2 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_RXTX	(0x3 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_NONE	(0x4 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FDUP_SHIFT	2
+#define MAC_CTRL0_FDUP_AUTO	(0x0 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_FDUP_EN	(0x1 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_FDUP_DIS	(0x3 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_GMII_AUTO	0x0
+#define MAC_CTRL0_GMII_MII	0x1
+#define MAC_CTRL0_GMII_GMII	0x2
+#define MAC_CTRL0_GMII_GMII_2G	0x3
+
+#define MAC_CTRL1_DEFERMODE	(1 << 15)
+#define MAC_CTRL1_SHORTPRE	(1 << 8)
+
+#define MAC_CTRL2_MLEN		(1 << 3)
+#define MAC_CTRL2_LCHKL		(1 << 2)
+#define MAC_CTRL2_LCHKS_DIS	0x0
+#define MAC_CTRL2_LCHKS_UNTAG	0x1
+#define MAC_CTRL2_LCHKS_TAG	0x2
+
+#define PHY_ADDR_LNKST_SHIFT	13
+#define PHY_ADDR_LNKST_AUTO	(0x0 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_LNKST_UP	(0x1 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_LNKST_DOWN	(0x2 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_SPEED_SHIFT	11
+#define PHY_ADDR_SPEED_M10	(0x0 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_M100	(0x1 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_G1	(0x2 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_AUTO	(0x3 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_FDUP_SHIFT	9
+#define PHY_ADDR_FDUP_AUTO	(0x0 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FDUP_EN	(0x1 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FDUP_DIS	(0x3 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FCONTX_SHIFT	7
+#define PHY_ADDR_FCONTX_AUTO	(0x0 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONTX_EN	(0x1 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONTX_DIS	(0x3 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONRX_SHIFT	5
+#define PHY_ADDR_FCONRX_AUTO	(0x0 << PHY_ADDR_FCONRX_SHIFT)
+#define PHY_ADDR_FCONRX_EN	(0x1 << PHY_ADDR_FCONRX_SHIFT)
+#define PHY_ADDR_FCONRX_DIS	(0x3 << PHY_ADDR_FCONRX_SHIFT)
+
+#define MII_CFG_RES		(1 << 15)
+#define MII_CFG_EN		(1 << 14)
+#define MII_CFG_LDCLKDIS	(1 << 12)
+#define MII_CFG_MIIRATE_SHIFT	4
+#define MII_CFG_MIIRATE_MASK	(0x7 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M2P5	(0x0 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M25	(0x1 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M125	(0x2 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M50	(0x3 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_AUTO	(0x4 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIMODE_MASK	0xf
+#define MII_CFG_MIIMODE_MIIP	0x0
+#define MII_CFG_MIIMODE_MIIM	0x1
+#define MII_CFG_MIIMODE_RMIIP	0x2
+#define MII_CFG_MIIMODE_RMIIM	0x3
+#define MII_CFG_MIIMODE_RGMII	0x4
+
+#define PCDU_RXDLY_SHIFT	7
+#define PCDU_RXDLY_MASK		(0x7 << PCDU_RXDLY_SHIFT)
+#define PCDU_TXDLY_MASK		0x7
+
+#define PMAC_HD_CTL_FC		(1 << 10)
+#define PMAC_HD_CTL_CCRC	(1 << 9)
+#define PMAC_HD_CTL_RST		(1 << 8)
+#define PMAC_HD_CTL_AST		(1 << 7)
+#define PMAC_HD_CTL_RXSH	(1 << 6)
+#define PMAC_HD_CTL_RC		(1 << 4)
+#define PMAC_HD_CTL_AS		(1 << 3)
+#define PMAC_HD_CTL_AC		(1 << 2)
+
+#define PCE_PCTRL_0_IGSTEN	(1 << 11)
+
+#define FDMA_PCTRL_STEN		(1 << 1)
+#define FDMA_PCTRL_EN		(1 << 0)
+
+#define SDMA_PCTRL_EN		(1 << 0)
+
+#define MDIO_GLOB_CTRL_SE	(1 << 15)
+
+#define MDIO_MDC_CFG1_RES	(1 << 15)
+#define MDIO_MDC_CFG1_MCEN	(1 << 8)
+
+#define MDIO_CTRL_MBUSY		(1 << 12)
+#define MDIO_CTRL_OP_READ	(1 << 11)
+#define MDIO_CTRL_OP_WRITE	(1 << 10)
+#define MDIO_CTRL_PHYAD_SHIFT	5
+#define MDIO_CTRL_PHYAD_MASK	(0x1f << MDIO_CTRL_PHYAD_SHIFT)
+#define MDIO_CTRL_REGAD_MASK	0x1f
+
+#endif
diff --git a/arch/mips/include/asm/asm.h b/arch/mips/include/asm/asm.h
index 933ccb1b7864abb9993bcaa187f25f15c9878dbf..dd0ffb62f6c1d26fa0b5e90937c7146d09f1c451 100644
--- a/arch/mips/include/asm/asm.h
+++ b/arch/mips/include/asm/asm.h
@@ -53,6 +53,7 @@
 		.align	2;                              \
 		.type	symbol, @function;              \
 		.ent	symbol, 0;                      \
+		.section .text.symbol,"x";              \
 symbol:		.frame	sp, 0, ra
 
 /*
@@ -62,7 +63,8 @@ symbol:		.frame	sp, 0, ra
 		.globl	symbol;                         \
 		.align	2;                              \
 		.type	symbol, @function;              \
-		.ent	symbol, 0;                       \
+		.ent	symbol, 0;                      \
+		.section .text.symbol,"x";              \
 symbol:		.frame	sp, framesize, rpc
 
 /*
diff --git a/arch/mips/include/asm/config.h b/arch/mips/include/asm/config.h
index 049c44eaf84de0ce67d86afcf0cd016d4bd6c407..6ddc3494c6bee9dbaa6d45e1ddb3802c314b97f7 100644
--- a/arch/mips/include/asm/config.h
+++ b/arch/mips/include/asm/config.h
@@ -21,4 +21,7 @@
 #ifndef _ASM_CONFIG_H_
 #define _ASM_CONFIG_H_
 
+#define CONFIG_LMB
+#define CONFIG_SYS_BOOT_RAMDISK_HIGH
+
 #endif
diff --git a/arch/mips/include/asm/gpio.h b/arch/mips/include/asm/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..7d87bfe568595e5e25ac1c3f50916ce95d9cf041
--- /dev/null
+++ b/arch/mips/include/asm/gpio.h
@@ -0,0 +1,7 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <asm/arch/gpio.h>
+#include <asm-generic/gpio.h>
diff --git a/arch/mips/include/asm/lantiq/chipid.h b/arch/mips/include/asm/lantiq/chipid.h
new file mode 100644
index 0000000000000000000000000000000000000000..1c67d4150549d95d12bbe0febf5fb4eb58621eaf
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/chipid.h
@@ -0,0 +1,74 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_CHIPID_H__
+#define __LANTIQ_CHIPID_H__
+
+enum ltq_chip_partnum {
+	LTQ_SOC_UNKNOWN = 0,
+	LTQ_SOC_VRX288_2 = 0x000B,	/* VRX288 v1.2 */
+	LTQ_SOC_VRX268_2 = 0x000C,	/* VRX268 v1.2 */
+	LTQ_SOC_GRX288_2 = 0x000D,	/* GRX288 v1.2 */
+	LTQ_SOC_DANUBE = 0x0129,
+	LTQ_SOC_DANUBE_S = 0x012B,
+	LTQ_SOC_TWINPASS = 0x012D,
+	LTQ_SOC_VRX288 = 0x01C0,	/* VRX288 v1.1 */
+	LTQ_SOC_VRX268 = 0x01C2,	/* VRX268 v1.1 */
+	LTQ_SOC_GRX288 = 0x01C9,	/* GRX288 v1.1 */
+};
+
+extern unsigned int ltq_chip_version_get(void);
+extern unsigned int ltq_chip_partnum_get(void);
+extern const char *ltq_chip_partnum_str(void);
+
+extern void ltq_chip_print_info(void);
+
+#ifdef CONFIG_SOC_XWAY_DANUBE
+static inline int ltq_soc_is_danube(void)
+{
+	return 1;
+}
+#else
+static inline int ltq_soc_is_danube(void)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SOC_XWAY_VRX200
+static inline int ltq_soc_is_vrx200(void)
+{
+	return 1;
+}
+
+static inline int ltq_soc_is_vrx200_v1(void)
+{
+	return ltq_chip_version_get() == 1;
+}
+
+static inline int ltq_soc_is_vrx200_v2(void)
+{
+	return ltq_chip_version_get() == 2;
+}
+#else
+static inline int ltq_soc_is_vrx200(void)
+{
+	return 0;
+}
+
+static inline int ltq_soc_is_vrx200_v1(void)
+{
+	return 0;
+}
+
+static inline int ltq_soc_is_vrx200_v2(void)
+{
+	return 0;
+}
+#endif
+
+#endif /* __LANTIQ_CHIPID_H__ */
diff --git a/arch/mips/include/asm/lantiq/clk.h b/arch/mips/include/asm/lantiq/clk.h
new file mode 100644
index 0000000000000000000000000000000000000000..3e01618c99b130e87ffdff8555a4ecc08ece6f0c
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/clk.h
@@ -0,0 +1,33 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * Based on Lantiq port in Linux kernel
+ */
+
+#ifndef __LANTIQ_CLK_H__
+#define __LANTIQ_CLK_H__
+
+/* Symbolic clock speeds */
+enum ltq_clk {
+	CLOCK_83_MHZ = 83333333,
+	CLOCK_111_MHZ = 111111111,
+	CLOCK_125_MHZ = 125000000,
+	CLOCK_133_MHZ = 133333333,
+	CLOCK_166_MHZ = 166666667,
+	CLOCK_197_MHZ = 197000000,
+	CLOCK_333_MHZ = 333333333,
+	CLOCK_393_MHZ = 393219000,
+	CLOCK_500_MHZ = 500000000,
+	CLOCK_600_MHZ = 600000000,
+	CLOCK_1000_MHZ = 1000000000,
+};
+
+extern unsigned long ltq_get_cpu_clock(void);
+extern unsigned long ltq_get_bus_clock(void);
+extern unsigned long ltq_get_io_region_clock(void);
+
+#endif /* __LANTIQ_CLK_H__ */
diff --git a/arch/mips/include/asm/lantiq/config.h b/arch/mips/include/asm/lantiq/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..a4ae5d250abf7a5406d34a4ad34d11aba7c1674c
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/config.h
@@ -0,0 +1,166 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_CONFIG_H__
+#define __LANTIQ_CONFIG_H__
+
+/* Memory usage */
+#define CONFIG_SYS_MAXARGS		24
+#define CONFIG_SYS_MALLOC_LEN		1024*1024
+#define CONFIG_SYS_BOOTPARAMS_LEN	128*1024
+
+/* Command line */
+#define CONFIG_SYS_PROMPT		CONFIG_MACH_TYPE " # "
+#define CONFIG_SYS_CBSIZE		512
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT)+16)
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+
+/*
+ * Enable advanced console features on demand to reduce
+ * flash and RAM footprint
+ */
+#if defined(CONFIG_LTQ_ADVANCED_CONSOLE)
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#endif
+
+/* SPI flash SPL */
+#if defined(CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH) && defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_SPL
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_NOR_FLASH) && defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SPL
+#endif
+
+/* Common SPL */
+#if defined(CONFIG_SPL)
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_START_S_PATH		\
+		"arch/mips/cpu/mips32/lantiq-common"
+#define CONFIG_SPL_LDSCRIPT		\
+		"arch/mips/cpu/mips32/lantiq-common/u-boot-spl.lds"
+#endif
+
+#if defined(CONFIG_LTQ_SPL_CONSOLE)
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZMA)
+#define CONFIG_LZMA
+#define CONFIG_SPL_LZMA_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+#define CONFIG_LZO
+#define CONFIG_SPL_LZO_SUPPORT
+#endif
+
+/* Basic commands */
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_EDITENV
+#define CONFIG_CMD_IMI
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_LOADB
+
+/* Other U-Boot settings */
+#define CONFIG_UBOOT_VERSION
+#define CONFIG_TIMESTAMP
+
+/* Default environment */
+#define CONFIG_ENV_CONSOLEDEV					\
+	"consoledev=" CONFIG_CONSOLE_DEV "\0"
+
+#define CONFIG_ENV_ADDCONSOLE					\
+	"addconsole=setenv bootargs $bootargs"			\
+	" console=$consoledev,$baudrate\0"
+
+#if defined(CONFIG_NET_DEV)
+#define CONFIG_ENV_NETDEV					\
+	"netdev=" CONFIG_NET_DEV "\0"
+#else
+#define CONFIG_ENV_NETDEV					\
+	"netdev=eth0\0"
+#endif
+
+#define CONFIG_ENV_ADDIP					\
+	"addip=setenv bootargs $bootargs"			\
+	" ip=$ipaddr:$serverip::::$netdev:off\0"
+
+#define CONFIG_ENV_ADDETH					\
+	"addeth=setenv bootargs $bootargs"			\
+	" ethaddr=$ethaddr\0"
+
+#define CONFIG_ENV_ADDMACHTYPE					\
+	"addmachtype=setenv bootargs $bootargs"			\
+	" machtype=" CONFIG_MACH_TYPE "\0"
+
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_ENV_WRITE_UBOOT_NOR					\
+	"write-uboot-nor="						\
+	"protect off " __stringify(CONFIG_SYS_FLASH_BASE) " +$filesize && " \
+	"erase " __stringify(CONFIG_SYS_FLASH_BASE) " +$filesize && "	\
+	"cp.b $fileaddr " __stringify(CONFIG_SYS_FLASH_BASE) " $filesize\0"
+
+#define CONFIG_ENV_LOAD_UBOOT_NOR					\
+	"load-uboot-nor=tftpboot u-boot.bin\0"				\
+	"load-uboot-norspl=tftpboot u-boot.ltq.norspl\0"		\
+	"load-uboot-norspl-lzo=tftpboot u-boot.ltq.lzo.norspl\0"	\
+	"load-uboot-norspl-lzma=tftpboot u-boot.ltq.lzma.norspl\0"
+#else
+#define CONFIG_ENV_WRITE_UBOOT_NOR
+#define CONFIG_ENV_LOAD_UBOOT_NOR
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_ENV_SF_PROBE					\
+	"sf-probe=sf probe " __stringify(CONFIG_ENV_SPI_CS) " "	\
+	__stringify(CONFIG_ENV_SPI_MAX_HZ) " "			\
+	__stringify(CONFIG_ENV_SPI_MODE) " \0"
+
+#define CONFIG_ENV_WRITE_UBOOT_SF				\
+	"write-uboot-sf="					\
+	"run sf-probe && sf erase 0 +$filesize && "		\
+	"sf write $fileaddr 0 $filesize\0"
+
+#define CONFIG_ENV_LOAD_UBOOT_SF					\
+	"load-uboot-sfspl=tftpboot u-boot.ltq.sfspl\0"			\
+	"load-uboot-sfspl-lzo=tftpboot u-boot.ltq.lzo.sfspl\0"		\
+	"load-uboot-sfspl-lzma=tftpboot u-boot.ltq.lzma.sfspl\0"
+#else
+#define CONFIG_ENV_SF_PROBE
+#define CONFIG_ENV_WRITE_UBOOT_SF
+#define CONFIG_ENV_LOAD_UBOOT_SF
+#endif
+
+#define CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_CONSOLEDEV		\
+	CONFIG_ENV_ADDCONSOLE		\
+	CONFIG_ENV_NETDEV		\
+	CONFIG_ENV_ADDIP		\
+	CONFIG_ENV_ADDETH		\
+	CONFIG_ENV_ADDMACHTYPE		\
+	CONFIG_ENV_WRITE_UBOOT_NOR	\
+	CONFIG_ENV_LOAD_UBOOT_NOR	\
+	CONFIG_ENV_SF_PROBE		\
+	CONFIG_ENV_WRITE_UBOOT_SF	\
+	CONFIG_ENV_LOAD_UBOOT_SF
+
+#endif /* __LANTIQ_CONFIG_H__ */
diff --git a/arch/mips/include/asm/lantiq/cpu.h b/arch/mips/include/asm/lantiq/cpu.h
new file mode 100644
index 0000000000000000000000000000000000000000..d52a82489f8c36ec8fe39f4e411ee328b42805e2
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/cpu.h
@@ -0,0 +1,35 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_CPU_H__
+#define __LANTIQ_CPU_H__
+
+enum ltq_boot_select {
+	BOOT_NOR,
+	BOOT_NOR_NO_BOOTROM,
+	BOOT_UART,
+	BOOT_UART_NO_EEPROM,
+	BOOT_SPI,
+	BOOT_NAND,
+	BOOT_PCI,
+	BOOT_MII0,
+	BOOT_RMII0,
+	BOOT_RGMII1,
+	BOOT_UNKNOWN,
+};
+
+enum ltq_boot_select ltq_boot_select(void);
+const char *ltq_boot_select_str(void);
+
+void ltq_pmu_init(void);
+void ltq_ebu_init(void);
+void ltq_gpio_init(void);
+
+void ltq_pll_init(void);
+void ltq_dcdc_init(unsigned int dig_ref);
+
+#endif /* __LANTIQ_CPU_H__ */
diff --git a/arch/mips/include/asm/lantiq/dma.h b/arch/mips/include/asm/lantiq/dma.h
new file mode 100644
index 0000000000000000000000000000000000000000..40b8d283cfdcf0f3b1164d42adfdc68761b85939
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/dma.h
@@ -0,0 +1,95 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_DMA_H__
+#define __LANTIQ_DMA_H__
+
+enum ltq_dma_endianess {
+	LTQ_DMA_ENDIANESS_B0_B1_B2_B3,	/* No byte swapping */
+	LTQ_DMA_ENDIANESS_B1_B0_B3_B2,	/* B0B1B2B3 => B1B0B3B2 */
+	LTQ_DMA_ENDIANESS_B2_B3_B0_B1,	/* B0B1B2B3 => B2B3B0B1 */
+	LTQ_DMA_ENDIANESS_B3_B2_B1_B0,	/* B0B1B2B3 => B3B2B1B0 */
+};
+
+enum ltq_dma_burst_len {
+	LTQ_DMA_BURST_2WORDS = 1,
+	LTQ_DMA_BURST_4WORDS = 2,
+	LTQ_DMA_BURST_8WORDS = 3,
+};
+
+struct ltq_dma_desc {
+	u32 ctl;
+	u32 addr;
+};
+
+struct ltq_dma_channel {
+	struct ltq_dma_device *dev;
+	u8 chan_no;
+	u8 class;
+	u16 num_desc;
+	struct ltq_dma_desc *desc_base;
+	void *mem_base;
+	u32 dma_addr;
+};
+
+struct ltq_dma_device {
+	enum ltq_dma_endianess rx_endian_swap;
+	enum ltq_dma_endianess tx_endian_swap;
+	enum ltq_dma_burst_len rx_burst_len;
+	enum ltq_dma_burst_len tx_burst_len;
+	struct ltq_dma_channel rx_chan;
+	struct ltq_dma_channel tx_chan;
+	u8 port;
+};
+
+/**
+ * Initialize DMA hardware and driver
+ */
+void ltq_dma_init(void);
+
+/**
+ * Register given DMA client context
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+int ltq_dma_register(struct ltq_dma_device *dev);
+
+/**
+ * Reset and halt all channels related to given DMA client
+ */
+void ltq_dma_reset(struct ltq_dma_device *dev);
+void ltq_dma_enable(struct ltq_dma_device *dev);
+void ltq_dma_disable(struct ltq_dma_device *dev);
+
+/**
+ * Map RX DMA descriptor to memory region
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+int ltq_dma_rx_map(struct ltq_dma_device *dev, int index, void *data, int len);
+
+/**
+ * Check if new data is available.
+ *
+ * @returns length of received data, 0 otherwise
+ */
+int ltq_dma_rx_poll(struct ltq_dma_device *dev, int index);
+
+int ltq_dma_rx_length(struct ltq_dma_device *dev, int index);
+
+/**
+ * Map TX DMA descriptor to memory region
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+int ltq_dma_tx_map(struct ltq_dma_device *dev, int index, void *data, int len,
+			unsigned long timeout);
+
+int ltq_dma_tx_wait(struct ltq_dma_device *dev, int index,
+			unsigned long timeout);
+
+#endif /* __LANTIQ_DMA_H__ */
diff --git a/arch/mips/include/asm/lantiq/eth.h b/arch/mips/include/asm/lantiq/eth.h
new file mode 100644
index 0000000000000000000000000000000000000000..c3a40cc7c152ee2584cb01b1c05a18458c872218
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/eth.h
@@ -0,0 +1,36 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_ETH_H__
+#define __LANTIQ_ETH_H__
+
+#include <phy.h>
+
+enum LTQ_ETH_PORT_FLAGS {
+	LTQ_ETH_PORT_NONE	= 0,
+	LTQ_ETH_PORT_PHY	= 1,
+	LTQ_ETH_PORT_SWITCH	= (1 << 1),
+	LTQ_ETH_PORT_MAC	= (1 << 2),
+};
+
+struct ltq_eth_port_config {
+	u8 num;
+	u8 phy_addr;
+	u16 flags;
+	phy_interface_t phy_if;
+	u8 rgmii_rx_delay;
+	u8 rgmii_tx_delay;
+};
+
+struct ltq_eth_board_config {
+	const struct ltq_eth_port_config *ports;
+	int num_ports;
+};
+
+extern int ltq_eth_initialize(const struct ltq_eth_board_config *board_config);
+
+#endif /* __LANTIQ_ETH_H__ */
diff --git a/arch/mips/include/asm/lantiq/gpio.h b/arch/mips/include/asm/lantiq/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..7ab4d9ff08a00dc095de2b880172b26d45b6b151
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/gpio.h
@@ -0,0 +1,51 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_GPIO_H__
+#define __LANTIQ_GPIO_H__
+
+enum ltq_gpio_dir {
+	GPIO_DIR_IN = 0,
+	GPIO_DIR_OUT
+};
+
+enum ltq_gpio_od {
+	GPIO_OD_ACTIVE = 0,
+	GPIO_OD_NORMAL
+};
+
+enum ltq_gpio_altsel {
+	GPIO_ALTSEL_CLR = 0,
+	GPIO_ALTSEL_SET
+};
+
+extern int gpio_set_altfunc(unsigned gpio, int altsel0, int altsel1, int dir);
+extern int gpio_set_opendrain(unsigned gpio, int od);
+
+static inline int gpio_to_port(unsigned gpio)
+{
+	return gpio >> 4;
+}
+
+static inline int gpio_to_pin(unsigned gpio)
+{
+	return gpio & 0xF;
+}
+
+static inline int gpio_to_bit(unsigned gpio)
+{
+	return 1 << gpio_to_pin(gpio);
+}
+
+static inline int gpio_to_gpio(unsigned port, unsigned pin)
+{
+	return (port << 4) | (pin & 0xF);
+}
+
+#include <asm-generic/gpio.h>
+
+#endif /* __LANTIQ_GPIO_H__ */
diff --git a/arch/mips/include/asm/lantiq/io.h b/arch/mips/include/asm/lantiq/io.h
new file mode 100644
index 0000000000000000000000000000000000000000..42b27217cd9c3c09157dcd9e757703bdb75b1fd0
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/io.h
@@ -0,0 +1,38 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_IO_H__
+#define __LANTIQ_IO_H__
+
+#include <asm/io.h>
+
+#define ltq_readb(a)		__raw_readb(a)
+#define ltq_writeb(a, v)	__raw_writeb(v, a)
+
+#define ltq_readl(a)		__raw_readl(a)
+#define ltq_writel(a, v)	__raw_writel(v, a)
+
+#define ltq_clrbits(a, clear) \
+	ltq_writel(a, ltq_readl(a) & ~(clear))
+
+#define ltq_setbits(a, set) \
+	ltq_writel(a, ltq_readl(a) | (set))
+
+#define ltq_clrsetbits(a, clear, set) \
+	ltq_writel(a, (ltq_readl(a) & ~(clear)) | (set))
+
+static inline void ltq_reg_dump(const void *addr, const char *desc)
+{
+	u32 data;
+
+	data = ltq_readl(addr);
+	printf("ltq_reg_dump: %s 0x%p = 0x%08x\n",
+		desc, addr, data);
+}
+
+#endif /* __LANTIQ_IO_H__ */
diff --git a/arch/mips/include/asm/lantiq/pm.h b/arch/mips/include/asm/lantiq/pm.h
new file mode 100644
index 0000000000000000000000000000000000000000..b025e9f0496a42e8bcc6048e614f2770cd243605
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/pm.h
@@ -0,0 +1,22 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_PM_H__
+#define __LANTIQ_PM_H__
+
+enum ltq_pm_modules {
+	LTQ_PM_CORE,
+	LTQ_PM_DMA,
+	LTQ_PM_ETH,
+	LTQ_PM_SPI,
+};
+
+u32 ltq_pm_map(enum ltq_pm_modules module);
+int ltq_pm_enable(enum ltq_pm_modules module);
+int ltq_pm_disable(enum ltq_pm_modules module);
+
+#endif /* __LANTIQ_PM_H__ */
diff --git a/arch/mips/include/asm/lantiq/reset.h b/arch/mips/include/asm/lantiq/reset.h
new file mode 100644
index 0000000000000000000000000000000000000000..3707bd8c3f6855fc5459f52fca0967d905c63c4b
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/reset.h
@@ -0,0 +1,38 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __LANTIQ_RESET_H__
+#define __LANTIQ_RESET_H__
+
+enum ltq_reset_modules {
+	LTQ_RESET_CORE,
+	LTQ_RESET_DMA,
+	LTQ_RESET_ETH,
+	LTQ_RESET_PHY,
+	LTQ_RESET_HARD,
+	LTQ_RESET_SOFT,
+};
+
+extern u32 ltq_reset_map(enum ltq_reset_modules module);
+extern int ltq_reset_activate(enum ltq_reset_modules module);
+extern int ltq_reset_deactivate(enum ltq_reset_modules module);
+
+static inline int ltq_reset_once(enum ltq_reset_modules module, ulong usec)
+{
+	int ret;
+
+	ret = ltq_reset_activate(module);
+	if (ret)
+		return ret;
+
+	__udelay(usec);
+	ret = ltq_reset_deactivate(module);
+
+	return ret;
+}
+
+#endif /* __LANTIQ_RESET_H__ */
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index be7e5c65ec1f38e91435844192af5a9637c2b337..b3bc2556d55889b2ba5bad590e3d4807aca56f3b 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -46,7 +46,10 @@
 #define CP0_ENTRYLO1 $3
 #define CP0_CONF $3
 #define CP0_CONTEXT $4
+#define CP0_CONTEXTCONFIG $4,1
+#define CP0_USERLOCAL $4,1
 #define CP0_PAGEMASK $5
+#define CP0_PAGEGRAIN $5,1
 #define CP0_WIRED $6
 #define CP0_INFO $7
 #define CP0_BADVADDR $8
@@ -54,10 +57,19 @@
 #define CP0_ENTRYHI $10
 #define CP0_COMPARE $11
 #define CP0_STATUS $12
+#define CP0_INTCTL $12,1
+#define CP0_SRSCTL $12,2
+#define CP0_SRSMAP $12,3
+#define CP0_SRSHIGH $12,4
 #define CP0_CAUSE $13
 #define CP0_EPC $14
 #define CP0_PRID $15
+#define CP0_EBASE $15,1
 #define CP0_CONFIG $16
+#define CP0_CONFIG1 $16,1
+#define CP0_CONFIG2 $16,2
+#define CP0_CONFIG3 $16,3
+#define CP0_CONFIG7 $16,7
 #define CP0_LLADDR $17
 #define CP0_WATCHLO $18
 #define CP0_WATCHHI $19
@@ -70,7 +82,17 @@
 #define CP0_ECC $26
 #define CP0_CACHEERR $27
 #define CP0_TAGLO $28
+#define CP0_ITAGLO $28
+#define CP0_IDATALO $28,1
+#define CP0_DTAGLO $28,2
+#define CP0_DDATALO $28,3
+#define CP0_L23TAGLO $28,4
+#define CP0_L23DATALO $28,5
 #define CP0_TAGHI $29
+#define CP0_IDATAHI $29,1
+#define CP0_DTAGHI $29,2
+#define CP0_L23TAGHI $29,4
+#define CP0_L23DATAHI $29,5
 #define CP0_ERROREPC $30
 #define CP0_DESAVE $31
 
@@ -395,6 +417,12 @@
 #define  CAUSEF_BD		(_ULCAST_(1)   << 31)
 
 /*
+ * Bits in the coprocessor 0 EBase register.
+ */
+#define EBASEB_CPUNUM		0
+#define EBASEF_CPUNUM		(_ULCAST_(1023))
+
+/*
  * Bits in the coprocessor 0 config register.
  */
 /* Generic bits.  */
diff --git a/arch/mips/include/asm/u-boot-mips.h b/arch/mips/include/asm/u-boot-mips.h
index e77636eaaf67b46e20cd6b3b26f6e5716dde3a54..a46f4595fb868052ec8805d8f0cf580a54228b72 100644
--- a/arch/mips/include/asm/u-boot-mips.h
+++ b/arch/mips/include/asm/u-boot-mips.h
@@ -24,3 +24,4 @@ static inline unsigned long image_copy_end(void)
 }
 
 extern int incaip_set_cpuclk(void);
+extern int arch_cpu_init(void);
diff --git a/arch/mips/lib/board.c b/arch/mips/lib/board.c
index f19f198ae98eab8f4069727d94cdc8141eb0c201..6c65d97a5d42c800d6c25da927f1a526919a6757 100644
--- a/arch/mips/lib/board.c
+++ b/arch/mips/lib/board.c
@@ -32,11 +32,14 @@
 #include <nand.h>
 #include <onenand_uboot.h>
 #include <spi.h>
+#include <spi_flash.h>
 
 #ifdef CONFIG_BITBANGMII
 #include <miiphy.h>
 #endif
 
+#include <sas/init.h>
+
 DECLARE_GLOBAL_DATA_PTR;
 
 ulong monitor_flash_len;
@@ -49,6 +52,16 @@ static char *failed = "*** failed ***\n";
  */
 const unsigned long mips_io_port_base = -1;
 
+int __arch_cpu_init(void)
+{
+	/*
+	 * Nothing to do in this dummy implementation
+	 */
+	return 0;
+}
+int arch_cpu_init(void)
+	__attribute__((weak, alias("__arch_cpu_init")));
+
 int __board_early_init_f(void)
 {
 	/*
@@ -122,6 +135,7 @@ static int init_baudrate(void)
 typedef int (init_fnc_t)(void);
 
 init_fnc_t *init_sequence[] = {
+	arch_cpu_init,
 	board_early_init_f,
 	timer_init,
 	env_init,		/* initialize environment */
@@ -134,6 +148,9 @@ init_fnc_t *init_sequence[] = {
 	display_banner,		/* say that we are here */
 	checkboard,
 	init_func_ram,
+#ifdef CONFIG_LIB_SPHAIRON
+	sas_init_f,
+#endif
 	NULL,
 };
 
@@ -296,6 +313,16 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	onenand_init();
 #endif
 
+#ifdef CONFIG_CMD_SPI
+	puts("SPI:   ");
+	spi_init();		/* go init the SPI */
+	puts("ready\n");
+#endif
+
+#if defined(CONFIG_SPI_FLASH)
+	spi_flash_init();
+#endif
+
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
@@ -319,12 +346,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	/* Initialize from environment */
 	load_addr = getenv_ulong("loadaddr", 16, load_addr);
 
-#ifdef CONFIG_CMD_SPI
-	puts("SPI:   ");
-	spi_init();		/* go init the SPI */
-	puts("ready\n");
-#endif
-
 #if defined(CONFIG_MISC_INIT_R)
 	/* miscellaneous platform dependent initialisations */
 	misc_init_r();
@@ -338,6 +359,8 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	eth_initialize(gd->bd);
 #endif
 
+	sas_init_r();
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;)
 		main_loop();
diff --git a/arch/mips/lib/bootm.c b/arch/mips/lib/bootm.c
index a36154a892c1ea687b5148772d1d384da664712d..ee0078bfb96babffd16ffc1c8045d3552c49fd17 100644
--- a/arch/mips/lib/bootm.c
+++ b/arch/mips/lib/bootm.c
@@ -33,23 +33,172 @@ DECLARE_GLOBAL_DATA_PTR;
 #define	LINUX_MAX_ENVS		256
 #define	LINUX_MAX_ARGS		256
 
+#ifdef CONFIG_DISABLE_ENV_INIT
+#define need_linux_env		0
+#else
+#define need_linux_env		1
+#endif
+
 static int linux_argc;
 static char **linux_argv;
+static char *linux_argp;
 
 static char **linux_env;
 static char *linux_env_p;
 static int linux_env_idx;
 
-static void linux_params_init(ulong start, char *commandline);
-static void linux_env_set(char *env_name, char *env_val);
+static ulong arch_get_sp(void)
+{
+	ulong ret;
 
-static void boot_prep_linux(bootm_headers_t *images)
+	__asm__ __volatile__("move %0, $sp" : "=r"(ret) : );
+
+	return ret;
+}
+
+void arch_lmb_reserve(struct lmb *lmb)
 {
-	char *commandline = getenv("bootargs");
-	char env_buf[12];
-	char *cp;
+	ulong sp;
+
+	/*
+	* Booting a (Linux) kernel image
+	*
+	* Allocate space for command line and board info - the
+	* address should be as high as possible within the reach of
+	* the kernel (see CONFIG_SYS_BOOTMAPSZ settings), but in unused
+	* memory, which means far enough below the current stack
+	* pointer.
+	*/
+	sp = arch_get_sp();
+	debug("## Current stack ends at 0x%08lx\n", sp);
+
+	/* adjust sp by 4K to be safe */
+	sp -= 4096;
+	lmb_reserve(lmb, sp, CONFIG_SYS_SDRAM_BASE + gd->ram_size - sp);
+}
+
+static void linux_cmdline_init(void)
+{
+	linux_argc = 1;
+	linux_argv = (char **) UNCACHED_SDRAM(gd->bd->bi_boot_params);
+	linux_argv[0] = 0;
+	linux_argp = (char *) (linux_argv + LINUX_MAX_ARGS);
+}
+
+static void linux_cmdline_set(const char *value, size_t len)
+{
+	linux_argv[linux_argc] = linux_argp;
+	memcpy(linux_argp, value, len);
+	linux_argp[len] = 0;
+
+	linux_argp += len + 1;
+	linux_argc++;
+}
+
+static void linux_cmdline_dump(void)
+{
+#ifdef DEBUG
+	int i;
+
+	printf("## cmdline argv at 0x%p, argp at 0x%p\n",
+		linux_argv, linux_argp);
+
+	for (i = 1; i < linux_argc; i++)
+		printf("   arg %03d: %s\n", i, linux_argv[i]);
+#endif
+}
+
+static void boot_cmdline_linux(bootm_headers_t *images)
+{
+	const char *bootargs, *next, *quote;
+	char buf[12];
+	unsigned int mem = gd->ram_size >> 20;
+	ulong rd_start, rd_size;
+
+	linux_cmdline_init();
+
+	/* append mem */
+	sprintf(buf, "mem=%uM", mem);
+	linux_cmdline_set(buf, strlen(buf));
+
+	/* append rd_start and rd_size */
+	rd_start = images->initrd_start;
+	rd_size = images->initrd_end - images->initrd_start;
+
+	if (rd_size) {
+		sprintf(buf, "rd_start=0x%08lX", rd_start);
+		linux_cmdline_set(buf, strlen(buf));
+		sprintf(buf, "rd_size=0x%lX", rd_size);
+		linux_cmdline_set(buf, strlen(buf));
+	}
+
+	bootargs = getenv("bootargs");
+	if (!bootargs)
+		return;
+
+	next = bootargs;
+
+	while (bootargs && *bootargs && linux_argc < LINUX_MAX_ARGS) {
+		quote = strchr(bootargs, '"');
+		next = strchr(bootargs, ' ');
+
+		while (next && quote && quote < next) {
+			/* we found a left quote before the next blank
+			 * now we have to find the matching right quote
+			 */
+			next = strchr(quote + 1, '"');
+			if (next) {
+				quote = strchr(next + 1, '"');
+				next = strchr(next + 1, ' ');
+			}
+		}
+
+		if (!next)
+			next = bootargs + strlen(bootargs);
+
+		linux_cmdline_set(bootargs, next - bootargs);
+
+		if (*next)
+			next++;
+
+		bootargs = next;
+	}
+
+	linux_cmdline_dump();
+}
+
+static void linux_env_init(void)
+{
+	linux_env = (char **) (((ulong) linux_argp + 15) & ~15);
+	linux_env[0] = 0;
+	linux_env_p = (char *) (linux_env + LINUX_MAX_ENVS);
+	linux_env_idx = 0;
+}
+
+static void linux_env_set(const char *env_name, const char *env_val)
+{
+	if (linux_env_idx < LINUX_MAX_ENVS - 1) {
+		linux_env[linux_env_idx] = linux_env_p;
+
+		strcpy(linux_env_p, env_name);
+		linux_env_p += strlen(env_name);
+
+		strcpy(linux_env_p, "=");
+		linux_env_p += 1;
+
+		strcpy(linux_env_p, env_val);
+		linux_env_p += strlen(env_val);
 
-	linux_params_init(UNCACHED_SDRAM(gd->bd->bi_boot_params), commandline);
+		linux_env_p++;
+		linux_env[++linux_env_idx] = 0;
+	}
+}
+
+static void boot_prep_linux_legacy(bootm_headers_t *images)
+{
+	char env_buf[12];
+	const char *cp;
+	ulong rd_start, rd_size;
 
 #ifdef CONFIG_MEMSIZE_IN_BYTES
 	sprintf(env_buf, "%lu", (ulong)gd->ram_size);
@@ -60,12 +209,17 @@ static void boot_prep_linux(bootm_headers_t *images)
 		(ulong)(gd->ram_size >> 20));
 #endif /* CONFIG_MEMSIZE_IN_BYTES */
 
+	rd_start = UNCACHED_SDRAM(images->initrd_start);
+	rd_size = images->initrd_end - images->initrd_start;
+
+	linux_env_init();
+
 	linux_env_set("memsize", env_buf);
 
-	sprintf(env_buf, "0x%08X", (uint) UNCACHED_SDRAM(images->rd_start));
+	sprintf(env_buf, "0x%08lX", rd_start);
 	linux_env_set("initrd_start", env_buf);
 
-	sprintf(env_buf, "0x%X", (uint) (images->rd_end - images->rd_start));
+	sprintf(env_buf, "0x%lX", rd_size);
 	linux_env_set("initrd_size", env_buf);
 
 	sprintf(env_buf, "0x%08X", (uint) (gd->bd->bi_flashstart));
@@ -83,31 +237,39 @@ static void boot_prep_linux(bootm_headers_t *images)
 		linux_env_set("eth1addr", cp);
 }
 
-static void boot_jump_linux(bootm_headers_t *images)
+static void boot_prep_linux(bootm_headers_t *images)
 {
-	void (*theKernel) (int, char **, char **, int *);
+	if (need_linux_env)
+		boot_prep_linux_legacy(images);
+}
 
-	/* find kernel entry point */
-	theKernel = (void (*)(int, char **, char **, int *))images->ep;
+static void boot_jump_linux(bootm_headers_t *images)
+{
+	typedef void __noreturn (*kernel_entry_t)(int, ulong, ulong, ulong);
+	kernel_entry_t kernel = (kernel_entry_t) images->ep;
 
-	debug("## Transferring control to Linux (at address %08lx) ...\n",
-		(ulong) theKernel);
+	debug("## Transferring control to Linux (at address %p) ...\n", kernel);
 
 	bootstage_mark(BOOTSTAGE_ID_RUN_OS);
 
 	/* we assume that the kernel is in place */
 	printf("\nStarting kernel ...\n\n");
 
-	theKernel(linux_argc, linux_argv, linux_env, 0);
+	kernel(linux_argc, (ulong)linux_argv, (ulong)linux_env, 0);
 }
 
 int do_bootm_linux(int flag, int argc, char * const argv[],
 			bootm_headers_t *images)
 {
 	/* No need for those on MIPS */
-	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
+	if (flag & BOOTM_STATE_OS_BD_T)
 		return -1;
 
+	if (flag & BOOTM_STATE_OS_CMDLINE) {
+		boot_cmdline_linux(images);
+		return 0;
+	}
+
 	if (flag & BOOTM_STATE_OS_PREP) {
 		boot_prep_linux(images);
 		return 0;
@@ -118,76 +280,10 @@ int do_bootm_linux(int flag, int argc, char * const argv[],
 		return 0;
 	}
 
+	boot_cmdline_linux(images);
 	boot_prep_linux(images);
 	boot_jump_linux(images);
 
 	/* does not return */
 	return 1;
 }
-
-static void linux_params_init(ulong start, char *line)
-{
-	char *next, *quote, *argp;
-
-	linux_argc = 1;
-	linux_argv = (char **) start;
-	linux_argv[0] = 0;
-	argp = (char *) (linux_argv + LINUX_MAX_ARGS);
-
-	next = line;
-
-	while (line && *line && linux_argc < LINUX_MAX_ARGS) {
-		quote = strchr(line, '"');
-		next = strchr(line, ' ');
-
-		while (next && quote && quote < next) {
-			/* we found a left quote before the next blank
-			 * now we have to find the matching right quote
-			 */
-			next = strchr(quote + 1, '"');
-			if (next) {
-				quote = strchr(next + 1, '"');
-				next = strchr(next + 1, ' ');
-			}
-		}
-
-		if (!next)
-			next = line + strlen(line);
-
-		linux_argv[linux_argc] = argp;
-		memcpy(argp, line, next - line);
-		argp[next - line] = 0;
-
-		argp += next - line + 1;
-		linux_argc++;
-
-		if (*next)
-			next++;
-
-		line = next;
-	}
-
-	linux_env = (char **) (((ulong) argp + 15) & ~15);
-	linux_env[0] = 0;
-	linux_env_p = (char *) (linux_env + LINUX_MAX_ENVS);
-	linux_env_idx = 0;
-}
-
-static void linux_env_set(char *env_name, char *env_val)
-{
-	if (linux_env_idx < LINUX_MAX_ENVS - 1) {
-		linux_env[linux_env_idx] = linux_env_p;
-
-		strcpy(linux_env_p, env_name);
-		linux_env_p += strlen(env_name);
-
-		strcpy(linux_env_p, "=");
-		linux_env_p += 1;
-
-		strcpy(linux_env_p, env_val);
-		linux_env_p += strlen(env_val);
-
-		linux_env_p++;
-		linux_env[++linux_env_idx] = 0;
-	}
-}
diff --git a/arch/powerpc/lib/board.c b/arch/powerpc/lib/board.c
index 422b4a39bb8a5c08d2f0f195cbc41902e4fe6ae3..064cd92eb6fc317fb93a093d21b2e36ef5df95dc 100644
--- a/arch/powerpc/lib/board.c
+++ b/arch/powerpc/lib/board.c
@@ -87,6 +87,8 @@
 #include <miiphy.h>
 #endif
 
+#include <sas/init.h>
+
 #ifdef CONFIG_SYS_UPDATE_FLASH_SIZE
 extern int update_flash_size(int flash_size);
 #endif
@@ -324,6 +326,9 @@ static init_fnc_t *init_sequence[] = {
 #if defined(CONFIG_SYS_DRAM_TEST)
 	testdram,
 #endif /* CONFIG_SYS_DRAM_TEST */
+#ifdef CONFIG_LIB_SPHAIRON
+	sas_init_f,
+#endif
 	INIT_FUNC_WATCHDOG_RESET
 	NULL,	/* Terminate this list */
 };
@@ -1039,6 +1044,8 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
+	sas_init_r();
+
 	/* Initialization complete - start the monitor */
 
 	/* main_loop() can return to retry autoboot, if so just run it again. */
diff --git a/board/lantiq/easy50712/Makefile b/board/lantiq/easy50712/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..903c6412baa984387ad3a52a9c8d7dd36dd4a67d
--- /dev/null
+++ b/board/lantiq/easy50712/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/lantiq/easy50712/config.mk b/board/lantiq/easy50712/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/lantiq/easy50712/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/lantiq/easy50712/ddr_settings.h b/board/lantiq/easy50712/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..bddf26b3413993cc3b8318449de438c864031ec5
--- /dev/null
+++ b/board/lantiq/easy50712/ddr_settings.h
@@ -0,0 +1,55 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define MC_DC00_VALUE	0x1B1B
+#define MC_DC01_VALUE	0x0
+#define MC_DC02_VALUE	0x0
+#define MC_DC03_VALUE	0x0
+#define MC_DC04_VALUE	0x0
+#define MC_DC05_VALUE	0x200
+#define MC_DC06_VALUE	0x605
+#define MC_DC07_VALUE	0x303
+#define MC_DC08_VALUE	0x102
+#define MC_DC09_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13c
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04
+#define MC_DC21_VALUE	0xd00
+#define MC_DC22_VALUE	0xd0d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+#define MC_DC46_VALUE	0x0
diff --git a/board/lantiq/easy50712/easy50712.c b/board/lantiq/easy50712/easy50712.c
new file mode 100644
index 0000000000000000000000000000000000000000..dd6f01a37bbeb8998e6e77f235c89d0da8def4a7
--- /dev/null
+++ b/board/lantiq/easy50712/easy50712.c
@@ -0,0 +1,113 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <switch.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/chipid.h>
+
+static void gpio_init(void)
+{
+	/* SPI/CS output (low-active) for serial flash */
+	gpio_direction_output(22, 1);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* enable CLK_OUT2 for external switch */
+	gpio_set_altfunc(3, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* MAC0: Lantiq ADM6996I switch */
+	{ 0, 0x0, LTQ_ETH_PORT_SWITCH, PHY_INTERFACE_MODE_RMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t *bis)
+{
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+static struct switch_device adm6996i_dev = {
+	.name = "adm6996i",
+	.cpu_port = 5,
+	.port_mask = 0xF,
+};
+
+int board_switch_init(void)
+{
+	/* Deactivate HRST line to release reset of ADM6996I switch */
+	ltq_reset_once(LTQ_RESET_HARD, 200000);
+
+	/* ADM6996I needs some time to come out of reset */
+	__udelay(50000);
+
+	return switch_device_register(&adm6996i_dev);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	switch (cs) {
+	case 2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 2:
+		gpio_set_value(22, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 2:
+		gpio_set_value(22, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/board/lantiq/easy80920/Makefile b/board/lantiq/easy80920/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..903c6412baa984387ad3a52a9c8d7dd36dd4a67d
--- /dev/null
+++ b/board/lantiq/easy80920/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/lantiq/easy80920/config.mk b/board/lantiq/easy80920/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/lantiq/easy80920/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/lantiq/easy80920/ddr_settings.h b/board/lantiq/easy80920/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..b459f9783b7a3612ddbfcda61e717844e54b372c
--- /dev/null
+++ b/board/lantiq/easy80920/ddr_settings.h
@@ -0,0 +1,70 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x0
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401B04
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1D445D
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x141F04
+#define	MC_CCR40_VALUE	0x142704
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7800301
+#define	MC_CCR58_VALUE	0x7800301
+#define	MC_CCR59_VALUE	0x7800301
+#define	MC_CCR60_VALUE	0x7800301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/lantiq/easy80920/easy80920.c b/board/lantiq/easy80920/easy80920.c
new file mode 100644
index 0000000000000000000000000000000000000000..cce21ad5a65b24809f57b10298849a905e9d6da8
--- /dev/null
+++ b/board/lantiq/easy80920/easy80920.c
@@ -0,0 +1,139 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#elif defined(CONFIG_SYS_BOOT_NOR)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static void gpio_init(void)
+{
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* GPIO 3.0 as input for NAND Ready Busy */
+	gpio_set_altfunc(48, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* GPIO 3.1 as output for NAND Read */
+	gpio_set_altfunc(49, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init)
+		gpio_init();
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: external Lantiq PEF7071 10/100/1000 PHY for LAN port 0 */
+	{ 0, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC1: external Lantiq PEF7071 10/100/1000 PHY for LAN port 1 */
+	{ 1, 0x1, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 2 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 3 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Lantiq PEF7071 10/100/1000 PHY for WANoE port */
+	{ 5, 0x5, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_addr = 0x80FF0000;
+
+	ltq_gphy_phy11g_a1x_load(fw_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_addr);
+	ltq_rcu_gphy_boot(1, fw_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/board/sphairon/isdn_sip_gw/Makefile b/board/sphairon/isdn_sip_gw/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/isdn_sip_gw/config.mk b/board/sphairon/isdn_sip_gw/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/isdn_sip_gw/ddr_settings.h b/board/sphairon/isdn_sip_gw/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..6e16774a6e8256acd526cd550955bd42fc094a63
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x1000000
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401503
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1536b0
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x142404
+#define	MC_CCR40_VALUE	0x142604
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7C00301
+#define	MC_CCR58_VALUE	0x7C00301
+#define	MC_CCR59_VALUE	0x7C00301
+#define	MC_CCR60_VALUE	0x7C00301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/isdn_sip_gw/isdn_sip_gw.c b/board/sphairon/isdn_sip_gw/isdn_sip_gw.c
new file mode 100644
index 0000000000000000000000000000000000000000..aa78483c1c3d2917b7013f55bac491a182ec7f65
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/isdn_sip_gw.c
@@ -0,0 +1,256 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static inline void gpio_init(void)
+{
+	/* GPIO button WLAN enable (low-active) */
+	gpio_direction_input(45);
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(46);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* SPI CS 1.0..1.3 to ISAC-SX 0..3 */
+	gpio_direction_output(39, 1);
+	gpio_direction_output(32, 1);
+	gpio_direction_output(34, 1);
+	gpio_direction_output(22, 1);
+
+	/* Atheros AR8031 10/100/1000 PHY reset line */
+	gpio_direction_output(15, 1);
+
+	/* SPI CS 1.4 to PLL ZL30342 */
+	gpio_direction_output(37, 1);
+
+	/* USB port0 power enable, disabled at startup */
+	gpio_direction_output(41, 0);
+	/* USB port1 power enable, disabled at startup */
+	gpio_direction_output(33, 0);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* GPIO 3.0 as input for NAND Ready Busy */
+	gpio_set_altfunc(48, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* GPIO 3.1 as output for NAND Read */
+	gpio_set_altfunc(49, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* LEDC/LED_ST for LED shift register */
+	gpio_set_altfunc(4, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_D for LED shift register */
+	gpio_set_altfunc(5, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_SH for LED shift register */
+	gpio_set_altfunc(6, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* Watchdog trigger line for MAX6722, needs clarification */
+	/* gpio_direction_output(8, 1); */
+
+	/* PCI-E CLKREQ, needs clarification */
+	/* gpio_direction_output(44, 1); */
+
+	/* PCM DCL/FSC input/output switch -> default output */
+	gpio_direction_output(47, 1);
+
+        /* High output for supervisor */
+        gpio_direction_output(8, 1);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init) {
+		ltq_gpio_init();
+		gpio_init();
+	}
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: Lantiq S-VIP */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC1: unused */
+	{ 1, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 0 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 1 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Atheros AR8031 10/100/1000 PHY for WANoE port */
+	{ 5, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII, 0, 3 },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+
+	ltq_gphy_phy11g_a2x_load(fw_ge_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_ge_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	/* Serial flash at bus 0 (SPI) */
+	if (bus == 0 && cs == 4)
+		return 1;
+
+	/* ISAC-SX 0..3 at bus 1 (USIF) */
+	if (bus == 1 && cs < 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4)
+		gpio = 10;
+
+	else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* ISAC-SX 0 */
+			gpio = 39;
+			break;
+		case 1:		/* ISAC-SX 1 */
+			gpio = 32;
+			break;
+		case 2:		/* ISAC-SX 2 */
+			gpio = 34;
+			break;
+		case 3:		/* ISAC-SX 3 */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 0);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4)
+		gpio = 10;
+
+	else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* ISAC-SX 0 */
+			gpio = 39;
+			break;
+		case 1:		/* ISAC-SX 1 */
+			gpio = 32;
+			break;
+		case 2:		/* ISAC-SX 2 */
+			gpio = 34;
+			break;
+		case 3:		/* ISAC-SX 3 */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 1);
+}
+
+int sas_cf_check_board(void)
+{
+	/* check if reset button is pressed */
+	return 0 == gpio_get_value(46);
+}
+
+void sas_cf_led_action(enum sas_cf_state state)
+{
+	switch (state) {
+	case CF_STARTED:
+		/* LED Power green on */
+		gpio_set_value(78, 0);
+		break;
+	case CF_FINISHED:
+		/* LED Power green off */
+		gpio_set_value(78, 1);
+		break;
+	case CF_FAILED:
+		/* LED Power green off */
+		gpio_set_value(78, 1);
+		/* MGM LED red on */
+		gpio_set_value(74, 0);
+		break;
+	}
+	return;
+}
+
+int sas_board_init_r(void)
+{
+	/* enable CLKOUT0 for Supervisor */
+        gpio_set_altfunc(8, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	return 0;
+}
diff --git a/board/sphairon/sl2510/Makefile b/board/sphairon/sl2510/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/sl2510/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/sl2510/config.mk b/board/sphairon/sl2510/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/sl2510/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/sl2510/ddr_settings.h b/board/sphairon/sl2510/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..6e16774a6e8256acd526cd550955bd42fc094a63
--- /dev/null
+++ b/board/sphairon/sl2510/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x1000000
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401503
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1536b0
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x142404
+#define	MC_CCR40_VALUE	0x142604
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7C00301
+#define	MC_CCR58_VALUE	0x7C00301
+#define	MC_CCR59_VALUE	0x7C00301
+#define	MC_CCR60_VALUE	0x7C00301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/sl2510/sl2510.c b/board/sphairon/sl2510/sl2510.c
new file mode 100644
index 0000000000000000000000000000000000000000..51299506e0ad4e15df31bb1cd3973d35e71596bc
--- /dev/null
+++ b/board/sphairon/sl2510/sl2510.c
@@ -0,0 +1,165 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static inline void gpio_init(void)
+{
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(46);
+
+	/* LED Power green */
+	gpio_direction_output(11, 1);
+	/* LED Power red */
+	gpio_direction_output(12, 0);
+	/* LED Internet green */
+	gpio_direction_output(8, 1);
+	/* LED Internet red */
+	gpio_direction_output(9, 1);
+	/* LED DSL sync green */
+	gpio_direction_output(2, 1);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init)
+		gpio_init();
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: unused */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC1: unused */
+	{ 1, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: unused */
+	{ 4, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC5: unused */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+
+	ltq_gphy_phy11g_a2x_load(fw_ge_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_ge_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+int sas_cf_check_board(void)
+{
+	/* check if reset button is pressed */
+	return 0 == gpio_get_value(46);
+}
+
+void sas_cf_led_action(enum sas_cf_state state)
+{
+	switch (state) {
+	case CF_STARTED:
+		/* LED Power green on */
+		gpio_set_value(11, 0);
+		break;
+	case CF_FINISHED:
+		/* LED Power green off */
+		gpio_set_value(11, 1);
+		break;
+	case CF_FAILED:
+		/* LED Internet red on */
+		gpio_set_value(9, 0);
+		/* LED Power green off */
+		gpio_set_value(11, 0);
+		break;
+	}
+	return;
+}
diff --git a/board/sphairon/sl550x/Makefile b/board/sphairon/sl550x/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/sl550x/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/sl550x/config.mk b/board/sphairon/sl550x/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/sl550x/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/sl550x/ddr_settings.h b/board/sphairon/sl550x/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..6e16774a6e8256acd526cd550955bd42fc094a63
--- /dev/null
+++ b/board/sphairon/sl550x/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x1000000
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401503
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1536b0
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x142404
+#define	MC_CCR40_VALUE	0x142604
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7C00301
+#define	MC_CCR58_VALUE	0x7C00301
+#define	MC_CCR59_VALUE	0x7C00301
+#define	MC_CCR60_VALUE	0x7C00301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/sl550x/sl550x.c b/board/sphairon/sl550x/sl550x.c
new file mode 100644
index 0000000000000000000000000000000000000000..54a95eca077ee55e0bafe2be4e5ecaba44707dd8
--- /dev/null
+++ b/board/sphairon/sl550x/sl550x.c
@@ -0,0 +1,213 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static inline void gpio_init(void)
+{
+	/* GPIO button WLAN enable (low-active) */
+	gpio_direction_input(45);
+	/* GPIO button WPS enable (low-active) */
+	gpio_direction_input(46);
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(47);
+
+	/* LED Power green */
+	gpio_direction_output(3, 1);
+	/* LED Power red */
+	gpio_direction_output(19, 0);
+	/* LED Info green */
+	gpio_direction_output(20, 1);
+	/* LED Info red */
+	gpio_direction_output(21, 1);
+	/* LED Internet green */
+	gpio_direction_output(27, 1);
+	/* LED Internet red */
+	gpio_direction_output(28, 1);
+	/* LED WLAN green */
+	gpio_direction_output(29, 1);
+	/* LED WPS green */
+	gpio_direction_output(30, 1);
+	/* LED USB2 green */
+	gpio_direction_output(32, 1);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* SPI CS 1.0 to ISAC-SX */
+	gpio_direction_output(39, 1);
+
+	/* USB port0 power enable, disabled at startup */
+	gpio_direction_output(41, 0);
+	/* USB port1 power enable, disabled at startup */
+	gpio_direction_output(33, 0);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* GPIO 3.0 as input for NAND Ready Busy */
+	gpio_set_altfunc(48, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* GPIO 3.1 as output for NAND Read */
+	gpio_set_altfunc(49, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* LEDC/LED_ST for LED shift register */
+	gpio_set_altfunc(4, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_D for LED shift register */
+	gpio_set_altfunc(5, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_SH for LED shift register */
+	gpio_set_altfunc(6, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* Ralink iNIC WLAN reset, low-active, asserted at startup */
+	gpio_direction_output(15, 0);
+	/* Ralink iNIC WLAN power, disabled at startup */
+	gpio_direction_output(37, 0);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init) {
+		ltq_gpio_init();
+		gpio_init();
+	}
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: external Lantiq PEF7071 10/100/1000 PHY for WANoE port */
+	{ 0, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC1: external Lantiq PEF7071 10/100/1000 PHY for LAN port 3/4 */
+	{ 1, 0x1, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC2: internal GPHY1 with 10/100 firmware for LAN port 1/2 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC3: internal GPHY0 with 10/100 firmware for LAN port 1/2 */
+	{ 3, 0x12, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC4: internal GPHY0 with 10/100/1000 firmware for LAN port 3/4 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: Ralink iNIC */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+	const ulong fw_fe_addr = 0x80FF0000;
+
+	ltq_gphy_phy11g_a2x_load(fw_ge_addr);
+	ltq_gphy_phy22f_a2x_load(fw_fe_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_fe_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+int sas_cf_check_board(void)
+{
+	/* check if reset button is pressed */
+	return 0 == gpio_get_value(47);
+}
+
+void sas_cf_led_action(enum sas_cf_state state)
+{
+	switch (state) {
+	case CF_STARTED:
+		/* LED Power green on */
+		gpio_direction_output(3, 0);
+		break;
+	case CF_FINISHED:
+		/* LED Power green off */
+		gpio_direction_output(3, 1);
+		break;
+	case CF_FAILED:
+		/* LED Info red on */
+		gpio_direction_output(21, 0);
+		/* LED Power green off */
+		gpio_direction_output(3, 0);
+		break;
+	}
+	return;
+}
diff --git a/board/sphairon/sl6501/Makefile b/board/sphairon/sl6501/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/sl6501/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/sl6501/config.mk b/board/sphairon/sl6501/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/sl6501/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/sl6501/ddr_settings.h b/board/sphairon/sl6501/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..5fe8d6c5570ec4672618a68a42e432fdbc1aa4cd
--- /dev/null
+++ b/board/sphairon/sl6501/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2014 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x1000000
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401503
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1536b0
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x142404
+#define	MC_CCR40_VALUE	0x142604
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7C00301
+#define	MC_CCR58_VALUE	0x7C00301
+#define	MC_CCR59_VALUE	0x7C00301
+#define	MC_CCR60_VALUE	0x7C00301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/sl6501/sl6501.c b/board/sphairon/sl6501/sl6501.c
new file mode 100644
index 0000000000000000000000000000000000000000..970fa9e5a189e9ab6ad1b02fc29ab5e87cf0d574
--- /dev/null
+++ b/board/sphairon/sl6501/sl6501.c
@@ -0,0 +1,245 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2014 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static inline void gpio_init(void)
+{
+	/* GPIO button WLAN enable (low-active) */
+	gpio_direction_input(45);
+	/* GPIO button WPS enable (low-active) */
+	gpio_direction_input(46);
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(47);
+
+	/* LED Power green */
+	gpio_direction_output(3, 1);
+	/* LED FXO green */
+	gpio_direction_output(14, 1);
+	/* LED Power red */
+	gpio_direction_output(19, 0);
+	/* LED Info green */
+	gpio_direction_output(20, 1);
+	/* LED Info red */
+	gpio_direction_output(21, 1);
+	/* LED Internet green */
+	gpio_direction_output(27, 1);
+	/* LED Internet red */
+	gpio_direction_output(28, 1);
+	/* LED WLAN green */
+	gpio_direction_output(29, 1);
+	/* LED WPS green */
+	gpio_direction_output(30, 1);
+	/* LED USB2 green */
+	gpio_direction_output(32, 1);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* SPI CS 1.0 to IPAC-X FXS */
+	gpio_direction_output(39, 1);
+	/* SPI CS 1.1 to IPAC-X FXO */
+	gpio_direction_output(22, 1);
+
+	/* USB port0 power enable, disabled at startup */
+	gpio_direction_output(41, 0);
+	/* USB port1 power enable, disabled at startup */
+	gpio_direction_output(33, 0);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* GPIO 3.0 as input for NAND Ready Busy */
+	gpio_set_altfunc(48, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* GPIO 3.1 as output for NAND Read */
+	gpio_set_altfunc(49, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* LEDC/LED_ST for LED shift register */
+	gpio_set_altfunc(4, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_D for LED shift register */
+	gpio_set_altfunc(5, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_SH for LED shift register */
+	gpio_set_altfunc(6, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* Ralink iNIC WLAN reset, low-active, asserted at startup */
+	gpio_direction_output(15, 0);
+	/* Ralink iNIC WLAN power, disabled at startup */
+	gpio_direction_output(37, 0);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init) {
+		ltq_gpio_init();
+		gpio_init();
+	}
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: unused */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC1: external Lantiq PEF7071 10/100/1000 PHY for LAN port 3/4 */
+	{ 1, 0x1, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC2: internal GPHY1 with 10/100 firmware for LAN port 1/2 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC3: internal GPHY0 with 10/100 firmware for LAN port 1/2 */
+	{ 3, 0x12, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC4: internal GPHY0 with 10/100/1000 firmware for LAN port 3/4 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: Ralink iNIC */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+	const ulong fw_fe_addr = 0x80FF0000;
+
+	ltq_gphy_phy11g_a2x_load(fw_ge_addr);
+	ltq_gphy_phy22f_a2x_load(fw_fe_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_fe_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	/* Serial flash at bus 0 (SPI) */
+	if (bus == 0 && cs == 4)
+		return 1;
+
+	/* IPAC-X 0..1 at bus 1 (USIF) */
+	if (bus == 1 && cs < 2)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4) {
+		gpio = 10;
+	} else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* IPAC-X FXS */
+			gpio = 39;
+			break;
+		case 1:		/* IPAC-X FXO */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 0);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4) {
+		gpio = 10;
+	} else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* IPAC-X FXS */
+			gpio = 39;
+			break;
+		case 1:		/* IPAC-X FXO */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 1);
+}
+
+int sas_cf_check_board(void)
+{
+	/* check if reset button is pressed */
+	return 0 == gpio_get_value(47);
+}
+
+void sas_cf_led_action(enum sas_cf_state state)
+{
+	switch (state) {
+	case CF_STARTED:
+		/* LED Power green on */
+		gpio_direction_output(3, 0);
+		break;
+	case CF_FINISHED:
+		/* LED Power green off */
+		gpio_direction_output(3, 1);
+		break;
+	case CF_FAILED:
+		/* LED Info red on */
+		gpio_direction_output(21, 0);
+		/* LED Power green off */
+		gpio_direction_output(3, 0);
+		break;
+	}
+	return;
+}
diff --git a/board/sphairon/tl7201/Makefile b/board/sphairon/tl7201/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/tl7201/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/tl7201/config.mk b/board/sphairon/tl7201/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/tl7201/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/tl7201/ddr_settings.h b/board/sphairon/tl7201/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..960a20cb112a4c299bd69b664847a51ad8acd417
--- /dev/null
+++ b/board/sphairon/tl7201/ddr_settings.h
@@ -0,0 +1,53 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define MC_DC00_VALUE	0x1B1B
+#define MC_DC01_VALUE	0x0
+#define MC_DC02_VALUE	0x0
+#define MC_DC04_VALUE	0x0
+#define MC_DC05_VALUE	0x200
+#define MC_DC06_VALUE	0x605
+#define MC_DC07_VALUE	0x303
+#define MC_DC08_VALUE	0x102
+#define MC_DC09_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03
+#define MC_DC21_VALUE	0x1600
+#define MC_DC22_VALUE	0x1616
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+#define MC_DC46_VALUE	0x0
diff --git a/board/sphairon/tl7201/tl7201.c b/board/sphairon/tl7201/tl7201.c
new file mode 100644
index 0000000000000000000000000000000000000000..0b352f4cd096db7d9d5c44ab2464c5e3102e323d
--- /dev/null
+++ b/board/sphairon/tl7201/tl7201.c
@@ -0,0 +1,111 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <switch.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/chipid.h>
+
+static void gpio_init(void)
+{
+	/* GPIO LED power green, off */
+	gpio_direction_output(7, 0);
+	/* GPIO LED power red, on */
+	gpio_direction_output(14, 1);
+	/* GPIO LED internet green (low-active), off */
+	gpio_direction_output(19, 1);
+	/* GPIO LED internet red, off */
+	gpio_direction_output(23, 0);
+	/* GPIO LED VoIP green (low-active), off */
+	gpio_direction_output(10, 1);
+	/* GPIO LED info green (low-active), off */
+	gpio_direction_output(12, 1);
+	/* GPIO LED info red (low-active), off */
+	gpio_direction_output(11, 1);
+	/* GPIO LED FXO green (low-active), off */
+	gpio_direction_output(9, 1);
+	/* GPIO LED DSL green (low-active), off */
+	gpio_direction_output(5, 1);
+
+	/* GPIO button WLAN enable */
+	gpio_direction_input(29);
+	/* GPIO button board reset */
+	gpio_direction_input(30);
+
+	/* SPI/CS output (low-active) for ISAC-SX */
+	gpio_direction_output(15, 1);
+	/* SPI/CS output (low-active) for ISAC-SX */
+	gpio_direction_output(20, 1);
+	/* SPI/CS output (low-active) for SI3050 */
+	gpio_direction_output(22, 1);
+
+	/* FL_A23 for Flash address pin A22 */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* FL_A24 for Flash address pin A23 */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/*
+	 * External hardware reset line
+	 * Low-active and not really needed because combined with lines for
+	 * Danube HRST_N and Dying Gasp. Thus the line must be always
+	 * driven high.
+	 */
+	gpio_direction_output(28, 1);
+
+	/* USB port0 power enable, disabled at startup */
+	gpio_direction_output(31, 0);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* MAC0: Lantiq Tantos Switch */
+	{ 0, 0x0, LTQ_ETH_PORT_SWITCH, PHY_INTERFACE_MODE_RMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	printf("%s\n", __func__);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+static struct switch_device psb697x_dev = {
+	.name = "psb697x",
+	.cpu_port = 5,
+	.port_mask = 0xF,
+};
+
+int board_switch_init(void)
+{
+	printf("%s\n", __func__);
+
+	ltq_reset_once(LTQ_RESET_HARD, 200000);
+	__udelay(50000);
+
+	return switch_device_register(&psb697x_dev);
+}
diff --git a/board/sphairon/vrx_g1/Makefile b/board/sphairon/vrx_g1/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..e4e01013dcee2056e9ffbaa9866d532616354372
--- /dev/null
+++ b/board/sphairon/vrx_g1/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/vrx_g1/config.mk b/board/sphairon/vrx_g1/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..8ca647efe58661faf37040e19b51f844069cdaf1
--- /dev/null
+++ b/board/sphairon/vrx_g1/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/vrx_g1/ddr_settings.h b/board/sphairon/vrx_g1/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..6e16774a6e8256acd526cd550955bd42fc094a63
--- /dev/null
+++ b/board/sphairon/vrx_g1/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x101
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x1000000
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000300
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401503
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1536b0
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x142404
+#define	MC_CCR40_VALUE	0x142604
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7C00301
+#define	MC_CCR58_VALUE	0x7C00301
+#define	MC_CCR59_VALUE	0x7C00301
+#define	MC_CCR60_VALUE	0x7C00301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/vrx_g1/vrx_g1.c b/board/sphairon/vrx_g1/vrx_g1.c
new file mode 100644
index 0000000000000000000000000000000000000000..b3143cfde49c4874d961edc1aee5bd9be2a855f0
--- /dev/null
+++ b/board/sphairon/vrx_g1/vrx_g1.c
@@ -0,0 +1,190 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/gphy.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SPL_BUILD)
+#define do_gpio_init	1
+#define do_pll_init	1
+#define do_dcdc_init	0
+#elif defined(CONFIG_SYS_BOOT_RAM)
+#define do_gpio_init	1
+#define do_pll_init	0
+#define do_dcdc_init	1
+#else
+#define do_gpio_init	0
+#define do_pll_init	0
+#define do_dcdc_init	1
+#endif
+
+static inline void gpio_init(void)
+{
+	/* GPIO button WLAN enable (low-active) */
+	gpio_direction_input(45);
+	/* GPIO button SW restart (low-active) */
+	gpio_direction_input(44);
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(46);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* xMII1.MII1_CRS connected to external KSZ8031 PHY */
+	gpio_set_altfunc(47, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+
+	/* COSIC modem reset, low-active, must be asserted at startup */
+	gpio_direction_output(14, 0);
+
+	/* USB port0 power enable, disabled at startup */
+	gpio_direction_output(41, 0);
+	/* USB port1 power enable, disabled at startup */
+	gpio_direction_output(33, 0);
+
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A24 as output for NAND ALE */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* GPIO 3.0 as input for NAND Ready Busy */
+	gpio_set_altfunc(48, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* GPIO 3.1 as output for NAND Read */
+	gpio_set_altfunc(49, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* Ralink iNIC WLAN reset, low-active, asserted at startup */
+	gpio_direction_output(15, 0);
+	/* Ralink iNIC WLAN power, disabled at startup */
+	gpio_direction_output(37, 0);
+}
+
+int board_early_init_f(void)
+{
+	if (do_gpio_init)
+		gpio_init();
+
+	if (do_pll_init)
+		ltq_pll_init();
+
+	if (do_dcdc_init)
+		ltq_dcdc_init(0x7F);
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: Ralink iNIC */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+#ifdef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	/* GMAC1: external KSZ8031 10/100 PHY for WANoE port */
+	{ 1, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RMII },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 3 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: not useable */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 1 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: not useable */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+#else
+	/* GMAC1: external KSZ8031 10/100 PHY for WANoE port */
+	{ 1, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RMII },
+	/* GMAC2: internal GPHY0 with 10/100 firmware for LAN port 4 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC3: internal GPHY0 with 10/100 firmware for LAN port 3 */
+	{ 3, 0x12, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 2 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Lantiq PEF7071 10/100/1000 PHY for LAN port 1 */
+	{ 5, 0x19, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+#endif
+
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+#ifndef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	const ulong fw_fe_addr = 0x80FF0000;
+#endif
+
+	ltq_gphy_phy11g_a1x_load(fw_ge_addr);
+#ifndef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	ltq_gphy_phy22f_a1x_load(fw_fe_addr);
+#endif
+
+	ltq_cgu_gphy_clk_src(clk);
+
+#ifdef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	ltq_rcu_gphy_boot(0, fw_ge_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+#else
+	ltq_rcu_gphy_boot(0, fw_fe_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+#endif
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+int sas_cf_check_board(void)
+{
+	/* check if reset button is pressed */
+	return 0 == gpio_get_value(46);
+}
diff --git a/boards.cfg b/boards.cfg
index 31483d623fb4a35cd54961fa07153e3192e1ef24..71d98bbb6174b247c6cbb9ab1f3c983dc27efb8d 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -469,10 +469,29 @@ dbau1500                     mips        mips32      dbau1x00            -
 dbau1550                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550
 dbau1550_el                  mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550,SYS_LITTLE_ENDIAN
 pb1000                       mips        mips32      pb1x00              -              au1x00      pb1x00:PB1000
+easy50712_nor                mips        mips32      easy50712           lantiq         danube      easy50712:SYS_BOOT_NOR
+easy50712_norspl             mips        mips32      easy50712           lantiq         danube      easy50712:SYS_BOOT_NORSPL
+easy50712_ram                mips        mips32      easy50712           lantiq         danube      easy50712:SYS_BOOT_RAM
+tl7201_nor                   mips        mips32      tl7201              sphairon       danube      tl7201:SYS_BOOT_NOR
+tl7201_ram                   mips        mips32      tl7201              sphairon       danube      tl7201:SYS_BOOT_RAM
 incaip                       mips        mips32      incaip              -              incaip
 incaip_100MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=100000000
 incaip_133MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=133000000
 incaip_150MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=150000000
+easy80920_nor                mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_NOR
+easy80920_norspl             mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_NORSPL
+easy80920_ram                mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_RAM
+easy80920_sfspl              mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_SFSPL
+isdn_sip_gw_ram              mips        mips32      isdn_sip_gw         sphairon       vrx200      isdn_sip_gw:SYS_BOOT_RAM
+isdn_sip_gw_sfspl            mips        mips32      isdn_sip_gw         sphairon       vrx200      isdn_sip_gw:SYS_BOOT_SFSPL
+sl2510_ram                   mips        mips32      sl2510              sphairon       vrx200      sl2510:SYS_BOOT_RAM
+sl2510_sfspl                 mips        mips32      sl2510              sphairon       vrx200      sl2510:SYS_BOOT_SFSPL
+sl550x_ram                   mips        mips32      sl550x              sphairon       vrx200      sl550x:SYS_BOOT_RAM
+sl550x_sfspl                 mips        mips32      sl550x              sphairon       vrx200      sl550x:SYS_BOOT_SFSPL
+sl6501_ram                   mips        mips32      sl6501              sphairon       vrx200      sl6501:SYS_BOOT_RAM
+sl6501_sfspl                 mips        mips32      sl6501              sphairon       vrx200      sl6501:SYS_BOOT_SFSPL
+vrx_g1_ram                   mips        mips32      vrx_g1              sphairon       vrx200      vrx_g1:SYS_BOOT_RAM
+vrx_g1_sfspl                 mips        mips32      vrx_g1              sphairon       vrx200      vrx_g1:SYS_BOOT_SFSPL
 qi_lb60                      mips        xburst      qi_lb60             qi
 adp-ag101                    nds32       n1213       adp-ag101           AndesTech      ag101
 adp-ag101p                   nds32       n1213       adp-ag101p          AndesTech      ag101
diff --git a/common/Makefile b/common/Makefile
index 0e0fff1ffa30a44d2ce27d91d31956916006b3e3..a8a503c15dd3da6b9619feccf2fa03f19424352e 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -143,6 +143,7 @@ COBJS-$(CONFIG_CMD_MISC) += cmd_misc.o
 COBJS-$(CONFIG_CMD_MMC) += cmd_mmc.o
 COBJS-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
 COBJS-$(CONFIG_MP) += cmd_mp.o
+COBJS-$(CONFIG_CMD_MTD) += cmd_mtd.o
 COBJS-$(CONFIG_CMD_MTDPARTS) += cmd_mtdparts.o
 COBJS-$(CONFIG_CMD_NAND) += cmd_nand.o
 COBJS-$(CONFIG_CMD_NET) += cmd_net.o
diff --git a/common/cmd_mtd.c b/common/cmd_mtd.c
new file mode 100644
index 0000000000000000000000000000000000000000..87f094c36db890bd0f93c8322767715c711638fb
--- /dev/null
+++ b/common/cmd_mtd.c
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * Command for read/write/erase via MTD layer
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/err.h>
+#include <linux/mtd/mtd.h>
+
+enum {
+	CMD_MTD_READ,
+	CMD_MTD_WRITE,
+	CMD_MTD_ERASE,
+	CMD_MTD_LOCK,
+	CMD_MTD_UNLOCK,
+};
+
+extern struct mtd_info *mtd_table[MAX_MTD_DEVICES];
+
+#define mtd_for_each_device(mtd)		\
+	for ((mtd) = mtd_table[0];		\
+		(mtd) != NULL;			\
+		(mtd) = mtd_table[(mtd)->index + 1])
+
+static int do_mtd_read_write(unsigned cmd, int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	char *endp, *mtdid;
+	ulong addr;
+	loff_t offset;
+	void *buf;
+	int ret;
+	size_t len, retlen;
+
+	if (argc < 4)
+		return -1;
+
+	mtdid = argv[2];
+	mtd = get_mtd_device_nm(mtdid);
+	if (IS_ERR(mtd)) {
+		printf("invalid MTD device: %s\n", mtdid);
+		return -1;
+	}
+
+	addr = simple_strtoul(argv[1], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	offset = simple_strtoul(argv[3], &endp, 16);
+	if (*argv[2] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	len = simple_strtoul(argv[4], &endp, 16);
+	if (*argv[3] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	buf = map_physmem(addr, len, MAP_WRBACK);
+	if (!buf) {
+		ret = 1;
+		goto done;
+	}
+
+	switch (cmd) {
+	case CMD_MTD_READ:
+		ret = mtd->read(mtd, offset, len, &retlen, buf);
+		break;
+	case CMD_MTD_WRITE:
+		ret = mtd->write(mtd, offset, len, &retlen, buf);
+		break;
+	default:
+		ret = -1;
+	}
+
+	unmap_physmem(buf, len);
+
+done:
+	put_mtd_device(mtd);
+
+	return ret;
+}
+
+/*
+ * Adopted from cmd_sf.c
+ *
+ * This function computes the length argument for the erase command.
+ * The length on which the command is to operate can be given in two forms:
+ * 1. <cmd> offset len  - operate on <'offset',  'len')
+ * 2. <cmd> offset +len - operate on <'offset',  'round_up(len)')
+ * If the second form is used and the length doesn't fall on the
+ * sector boundary, than it will be adjusted to the next sector boundary.
+ * If it isn't in the flash, the function will fail (return -1).
+ * Input:
+ *    arg: length specification (i.e. both command arguments)
+ * Output:
+ *    len: computed length for operation
+ * Return:
+ *    1: success
+ *   -1: failure (bad format, bad address).
+ */
+static int mtd_parse_len_arg(struct mtd_info *mtd, const char *arg, uint64_t *len)
+{
+	char *ep;
+	char round_up_len; /* indicates if the "+length" form used */
+	uint64_t len_arg;
+
+	round_up_len = 0;
+	if (*arg == '+') {
+		round_up_len = 1;
+		++arg;
+	}
+
+	len_arg = simple_strtoul(arg, &ep, 16);
+	if (ep == arg || *ep != 0)
+		return -1;
+
+	if (round_up_len && mtd->erasesize > 0)
+		*len = ROUND(len_arg, mtd->erasesize);
+	else
+		*len = len_arg;
+
+	return 0;
+}
+
+static int do_mtd_erase_lock_unlock(unsigned cmd, int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	struct erase_info instr;
+	char *endp, *mtdid;
+	int ret;
+
+	if (argc < 3)
+		return -1;
+
+	mtdid = argv[1];
+	mtd = get_mtd_device_nm(mtdid);
+	if (IS_ERR(mtd)) {
+		printf("invalid MTD device: %s\n", mtdid);
+		return -1;
+	}
+
+	instr.addr = simple_strtoul(argv[2], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	ret = mtd_parse_len_arg(mtd, argv[3], &instr.len);
+	if (ret)
+		goto done;
+
+	switch (cmd) {
+	case CMD_MTD_ERASE:
+		instr.mtd = mtd;
+		instr.callback = NULL;
+		ret = mtd->erase(mtd, &instr);
+		break;
+	case CMD_MTD_LOCK:
+		ret = mtd->lock(mtd, instr.addr, instr.len);
+		break;
+	case CMD_MTD_UNLOCK:
+		ret = mtd->unlock(mtd, instr.addr, instr.len);
+		break;
+	default:
+		ret = -1;
+	}
+
+done:
+	put_mtd_device(mtd);
+
+	return ret;
+}
+
+static const char mtd_type_str[][12] = {
+	"Absent",
+	"RAM",
+	"ROM",
+	"NOR flash",
+	"NAND flash",
+	"DATA flash",
+	"UBI volume"
+};
+
+static int do_mtd_info(int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	const char *str;
+
+	mtd_for_each_device(mtd) {
+		str = mtd_type_str[mtd->type];
+		printf("%-16s - %s, ", mtd->name, str);
+		print_size(mtd->size, "\n");
+	}
+
+	return 0;
+}
+
+static int do_mtd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char *cmd;
+	int ret;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	cmd = argv[1];
+	argc--;
+	argv++;
+
+	if (strcmp(cmd, "read") == 0)
+		ret = do_mtd_read_write(CMD_MTD_READ, argc, argv);
+	else if (strcmp(cmd, "write") == 0)
+		ret = do_mtd_read_write(CMD_MTD_WRITE, argc, argv);
+	else if (strcmp(cmd, "erase") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_ERASE, argc, argv);
+	else if (strcmp(cmd, "lock") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_LOCK, argc, argv);
+	else if (strcmp(cmd, "unlock") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_UNLOCK, argc, argv);
+	else if (strcmp(cmd, "info") == 0)
+		ret = do_mtd_info(argc, argv);
+	else
+		ret = -1;
+
+	if (ret != -1)
+		return ret;
+
+usage:
+	return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(
+	mtd, 6, 0, do_mtd,
+	"MTD sub-system",
+	"info\n"
+	"    - show available MTD devices\n"
+	"mtd read addr mtdid offset len\n"
+	"    - read 'len' bytes from MTD 'mtdid' starting at 'offset' "
+		"to memory at 'addr'\n"
+	"mtd write addr mtdid offset len\n"
+	"    - write 'len' bytes from memory at 'addr' to MTD 'mtdid' "
+		"at 'offset'\n"
+	"mtd erase mtdid offset [+]len\n"
+	"    - erase 'len' bytes in MTD 'mtdid' from 'offset'\n"
+	"      +len' round up 'len' to MTD erase size\n"
+	"mtd lock|unlock mtdid offset [+]len\n"
+	"    - lock/unlock 'len' bytes in MTD 'mtdid' from 'offset'\n"
+	"      +len' round up 'len' to MTD erase size"
+);
diff --git a/common/cmd_mtdparts.c b/common/cmd_mtdparts.c
index 1c35f9dd60531fd5e8918386036d4c3406a87624..641231c16b317c64eef4ddaec4387d31510b755c 100644
--- a/common/cmd_mtdparts.c
+++ b/common/cmd_mtdparts.c
@@ -106,6 +106,12 @@
 #include <onenand_uboot.h>
 #endif
 
+#if defined(CONFIG_LIB_SPHAIRON)
+#define validate_eraseblocks	0
+#else
+#define validate_eraseblocks	1
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /* special size referring to all the remaining space in a partition */
@@ -432,7 +438,10 @@ static int part_validate(struct mtdids *id, struct part_info *part)
 	 * Now we need to check if the partition starts and ends on
 	 * sector (eraseblock) regions
 	 */
-	return part_validate_eraseblock(id, part);
+	if (validate_eraseblocks)
+		return part_validate_eraseblock(id, part);
+
+	return 0;
 }
 
 /**
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 5d864b56ef1a6c534cd52cdf70fb9aeae35e389c..455de4213565b69b2b33eef4df9d53ec70b8404f 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -28,6 +28,7 @@ LIB	:= $(obj)libdma.o
 COBJS-$(CONFIG_FSLDMAFEC) += MCD_tasksInit.o MCD_dmaApi.o MCD_tasks.o
 COBJS-$(CONFIG_APBH_DMA) += apbh_dma.o
 COBJS-$(CONFIG_FSL_DMA) += fsl_dma.o
+COBJS-$(CONFIG_LANTIQ_DMA) += lantiq_dma.o
 COBJS-$(CONFIG_OMAP3_DMA) += omap3_dma.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/dma/lantiq_dma.c b/drivers/dma/lantiq_dma.c
new file mode 100644
index 0000000000000000000000000000000000000000..ef3886a77f66861fc6b44dca8496899916d6e23a
--- /dev/null
+++ b/drivers/dma/lantiq_dma.c
@@ -0,0 +1,388 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <linux/compiler.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/dma.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/soc.h>
+#include <asm/processor.h>
+
+#define DMA_CTRL_PKTARB			(1 << 31)
+#define DMA_CTRL_MBRSTARB		(1 << 30)
+#define DMA_CTRL_MBRSTCNT_SHIFT		16
+#define DMA_CTRL_MBRSTCNT_MASK		(0x3ff << DMA_CTRL_MBRSTCNT_SHIFT)
+#define DMA_CTRL_DRB			(1 << 8)
+#define DMA_CTRL_RESET			(1 << 0)
+
+#define DMA_CPOLL_EN			(1 << 31)
+#define DMA_CPOLL_CNT_SHIFT		4
+#define DMA_CPOLL_CNT_MASK		(0xFFF << DMA_CPOLL_CNT_SHIFT)
+
+#define DMA_CCTRL_TXWGT_SHIFT		16
+#define DMA_CCTRL_TXWGT_MASK		(0x3 << DMA_CCTRL_TXWGT_SHIFT)
+#define DMA_CCTRL_CLASS_SHIFT		9
+#define DMA_CCTRL_CLASS_MASK		(0x3 << DMA_CCTRL_CLASS_SHIFT)
+#define DMA_CCTRL_RST			(1 << 1)
+#define DMA_CCTRL_ONOFF			(1 << 0)
+
+#define DMA_PCTRL_TXBL_SHIFT		4
+#define DMA_PCTRL_TXBL_2WORDS		(1 << DMA_PCTRL_TXBL_SHIFT)
+#define DMA_PCTRL_TXBL_4WORDS		(2 << DMA_PCTRL_TXBL_SHIFT)
+#define DMA_PCTRL_TXBL_8WORDS		(3 << DMA_PCTRL_TXBL_SHIFT)
+#define DMA_PCTRL_RXBL_SHIFT		2
+#define DMA_PCTRL_RXBL_2WORDS		(1 << DMA_PCTRL_RXBL_SHIFT)
+#define DMA_PCTRL_RXBL_4WORDS		(2 << DMA_PCTRL_RXBL_SHIFT)
+#define DMA_PCTRL_RXBL_8WORDS		(3 << DMA_PCTRL_RXBL_SHIFT)
+#define DMA_PCTRL_TXENDI_SHIFT		10
+#define DMA_PCTRL_TXENDI_MASK		(0x3 << DMA_PCTRL_TXENDI_SHIFT)
+#define DMA_PCTRL_RXENDI_SHIFT		8
+#define DMA_PCTRL_RXENDI_MASK		(0x3 << DMA_PCTRL_RXENDI_SHIFT)
+
+#define DMA_DESC_OWN			(1 << 31)
+#define DMA_DESC_C			(1 << 30)
+#define DMA_DESC_SOP			(1 << 29)
+#define DMA_DESC_EOP			(1 << 28)
+#define DMA_DESC_TX_OFFSET(x)		((x & 0x1f) << 23)
+#define DMA_DESC_RX_OFFSET(x)		((x & 0x3) << 23)
+#define DMA_DESC_LENGTH(x)		(x & 0xffff)
+
+#define PTR_ALIGN(p, a)		((typeof(p))ALIGN((unsigned long)(p), (a)))
+
+struct ltq_dma_regs {
+	u32	clc;		/* Clock control */
+	u32	rsvd0;
+	u32	id;		/* Identification */
+	u32	rsvd1;
+	u32	ctrl;		/* Control */
+	u32	cpoll;		/* Channel polling */
+	u32	cs;		/* Channel select */
+	u32	cctrl;		/* Channel control */
+	u32	cdba;		/* Channel descriptor base address */
+	u32	cdlen;		/* Channel descriptor length */
+	u32	cis;		/* Channel interrupt status */
+	u32	cie;		/* Channel interrupt enable */
+	u32	cgbl;		/* Channel global buffer length */
+	u32	cdptnrd;	/* Current descriptor pointer */
+	u32	rsvd2[2];
+	u32	ps;		/* Port select */
+	u32	pctrl;		/* Port control */
+	u32	rsvd3[43];
+	u32	irnen;		/* Interrupt node enable */
+	u32	irncr;		/* Interrupt node control */
+	u32	irnicr;		/* Interrupt capture */
+};
+
+static struct ltq_dma_regs *ltq_dma_regs =
+	(struct ltq_dma_regs *) CKSEG1ADDR(LTQ_DMA_BASE);
+
+static inline unsigned long ltq_dma_addr_to_virt(u32 dma_addr)
+{
+	return KSEG0ADDR(dma_addr);
+}
+
+static inline u32 ltq_virt_to_dma_addr(void *addr)
+{
+	return CPHYSADDR(addr);
+}
+
+static inline int ltq_dma_burst_align(enum ltq_dma_burst_len burst_len)
+{
+	switch (burst_len) {
+	case LTQ_DMA_BURST_2WORDS:
+		return 2 * 4;
+	case LTQ_DMA_BURST_4WORDS:
+		return 4 * 4;
+	case LTQ_DMA_BURST_8WORDS:
+		return 8 * 4;
+	}
+
+	return 0;
+}
+
+static inline void ltq_dma_sync(void)
+{
+	__asm__ __volatile__("sync");
+}
+
+static inline void ltq_dma_dcache_wb_inv(const void *ptr, size_t size)
+{
+	unsigned long addr = (unsigned long) ptr;
+
+	flush_dcache_range(addr, addr + size);
+	ltq_dma_sync();
+}
+
+static inline void ltq_dma_dcache_inv(const void *ptr, size_t size)
+{
+	unsigned long addr = (unsigned long) ptr;
+
+	invalidate_dcache_range(addr, addr + size);
+}
+
+void ltq_dma_init(void)
+{
+	/* Power up DMA */
+	ltq_pm_enable(LTQ_PM_DMA);
+
+	/* Reset DMA */
+	ltq_setbits(&ltq_dma_regs->ctrl, DMA_CTRL_RESET);
+
+	/* Disable and clear all interrupts */
+	ltq_writel(&ltq_dma_regs->irnen, 0);
+	ltq_writel(&ltq_dma_regs->irncr, 0xFFFFF);
+
+#if 0
+	/* Enable packet arbitration */
+	ltq_setbits(&ltq_dma_regs->ctrl, DMA_CTRL_PKTARB);
+#endif
+
+#if 0
+	/* Enable descriptor read back */
+	ltq_setbits(&ltq_dma_regs->ctrl, DMA_CTRL_DRB);
+#endif
+
+	/* Enable polling for descriptor fetching for all channels */
+	ltq_writel(&ltq_dma_regs->cpoll, DMA_CPOLL_EN |
+		(4 << DMA_CPOLL_CNT_SHIFT));
+}
+
+static void ltq_dma_channel_reset(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_setbits(&ltq_dma_regs->cctrl, DMA_CCTRL_RST);
+}
+
+static void ltq_dma_channel_enable(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_setbits(&ltq_dma_regs->cctrl, DMA_CCTRL_ONOFF);
+}
+
+static void ltq_dma_channel_disable(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_clrbits(&ltq_dma_regs->cctrl, DMA_CCTRL_ONOFF);
+}
+
+static void ltq_dma_port_init(struct ltq_dma_device *dev)
+{
+	u32 pctrl;
+
+	pctrl = dev->tx_endian_swap << DMA_PCTRL_TXENDI_SHIFT;
+	pctrl |= dev->rx_endian_swap << DMA_PCTRL_RXENDI_SHIFT;
+	pctrl |= dev->tx_burst_len << DMA_PCTRL_TXBL_SHIFT;
+	pctrl |= dev->rx_burst_len << DMA_PCTRL_RXBL_SHIFT;
+
+	ltq_writel(&ltq_dma_regs->ps, dev->port);
+	ltq_writel(&ltq_dma_regs->pctrl, pctrl);
+}
+
+static int ltq_dma_alloc_descriptors(struct ltq_dma_device *dev,
+					struct ltq_dma_channel *chan)
+{
+	size_t size;
+	void *desc_base;
+
+	size = ALIGN(sizeof(struct ltq_dma_desc) * chan->num_desc +
+			ARCH_DMA_MINALIGN, ARCH_DMA_MINALIGN);
+
+	chan->mem_base = malloc(size);
+	if (!chan->mem_base)
+		return 1;
+
+	memset(chan->mem_base, 0, size);
+	ltq_dma_dcache_wb_inv(chan->mem_base, size);
+
+	desc_base = PTR_ALIGN(chan->mem_base, ARCH_DMA_MINALIGN);
+
+	debug("DMA: mem %p, desc %p\n", chan->mem_base, desc_base);
+
+	/* Align descriptor base to 8 bytes */
+	chan->desc_base = (void *) CKSEG1ADDR(desc_base);
+	chan->dma_addr = CPHYSADDR(desc_base);
+	chan->dev = dev;
+
+	debug("DMA: desc_base %p, size %u\n", chan->desc_base, size);
+
+	/* Configure hardware with location of descriptor list */
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_writel(&ltq_dma_regs->cdba, chan->dma_addr);
+	ltq_writel(&ltq_dma_regs->cdlen, chan->num_desc);
+	ltq_writel(&ltq_dma_regs->cctrl, (3 << DMA_CCTRL_TXWGT_SHIFT) |
+		(chan->class << DMA_CCTRL_CLASS_SHIFT));
+	ltq_writel(&ltq_dma_regs->cctrl, DMA_CCTRL_RST);
+
+	return 0;
+}
+
+static void ltq_dma_free_descriptors(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_writel(&ltq_dma_regs->cdba, 0);
+	ltq_writel(&ltq_dma_regs->cdlen, 0);
+
+	ltq_dma_channel_reset(chan);
+
+	free(chan->mem_base);
+}
+
+int ltq_dma_register(struct ltq_dma_device *dev)
+{
+	int ret;
+
+	ltq_dma_port_init(dev);
+
+	ret = ltq_dma_alloc_descriptors(dev, &dev->rx_chan);
+	if (ret)
+		return ret;
+
+	ret = ltq_dma_alloc_descriptors(dev, &dev->tx_chan);
+	if (ret) {
+		ltq_dma_free_descriptors(&dev->rx_chan);
+		return ret;
+	}
+
+	return 0;
+}
+
+void ltq_dma_reset(struct ltq_dma_device *dev)
+{
+	ltq_dma_channel_reset(&dev->rx_chan);
+	ltq_dma_channel_reset(&dev->tx_chan);
+}
+
+void ltq_dma_enable(struct ltq_dma_device *dev)
+{
+	ltq_dma_channel_enable(&dev->rx_chan);
+	ltq_dma_channel_enable(&dev->tx_chan);
+}
+
+void ltq_dma_disable(struct ltq_dma_device *dev)
+{
+	ltq_dma_channel_disable(&dev->rx_chan);
+	ltq_dma_channel_disable(&dev->tx_chan);
+}
+
+int ltq_dma_rx_map(struct ltq_dma_device *dev, int index, void *data, int len)
+{
+	struct ltq_dma_channel *chan = &dev->rx_chan;
+	struct ltq_dma_desc *desc = &chan->desc_base[index];
+	u32 dma_addr = ltq_virt_to_dma_addr(data);
+	unsigned int offset;
+
+	offset = dma_addr % ltq_dma_burst_align(dev->rx_burst_len);
+
+	ltq_dma_dcache_inv(data, len);
+
+#if 0
+	printf("%s: index %d, data %p, dma_addr %08x, offset %u, len %d\n",
+		__func__, index, data, dma_addr, offset, len);
+#endif
+
+
+	desc->addr = dma_addr - offset;
+	desc->ctl = DMA_DESC_OWN | DMA_DESC_RX_OFFSET(offset) |
+			DMA_DESC_LENGTH(len);
+
+#if 0
+	printf("%s: index %d, desc %p, desc->ctl %08x\n",
+		__func__, index, desc, desc->ctl);
+#endif
+
+	return 0;
+}
+
+int ltq_dma_rx_poll(struct ltq_dma_device *dev, int index)
+{
+	struct ltq_dma_channel *chan = &dev->rx_chan;
+	struct ltq_dma_desc *desc = &chan->desc_base[index];
+
+#if 0
+	printf("%s: index %d, desc %p, desc->ctl %08x\n",
+		__func__, index, desc, desc->ctl);
+#endif
+
+	if (desc->ctl & DMA_DESC_OWN)
+		return 0;
+
+	if (desc->ctl & DMA_DESC_C)
+		return 1;
+
+	return 0;
+}
+
+int ltq_dma_rx_length(struct ltq_dma_device *dev, int index)
+{
+	struct ltq_dma_channel *chan = &dev->rx_chan;
+	struct ltq_dma_desc *desc = &chan->desc_base[index];
+
+	return DMA_DESC_LENGTH(desc->ctl);
+}
+
+int ltq_dma_tx_map(struct ltq_dma_device *dev, int index, void *data, int len,
+			unsigned long timeout)
+{
+	struct ltq_dma_channel *chan = &dev->tx_chan;
+	struct ltq_dma_desc *desc = &chan->desc_base[index];
+	unsigned int offset;
+	unsigned long timebase = get_timer(0);
+	u32 dma_addr = ltq_virt_to_dma_addr(data);
+
+	while (desc->ctl & DMA_DESC_OWN) {
+		WATCHDOG_RESET();
+
+		if (get_timer(timebase) >= timeout) {
+#if 0
+			printf("%s: timeout: index %d, desc %p, desc->ctl %08x\n",
+				__func__, index, desc, desc->ctl);
+#endif
+			return -1;
+		}
+	}
+
+	offset = dma_addr % ltq_dma_burst_align(dev->rx_burst_len);
+
+#if 0
+	printf("%s: index %d, desc %p, data %p, dma_addr %08x, offset %u, len %d\n",
+		__func__, index, desc, data, dma_addr, offset, len);
+#endif
+
+	ltq_dma_dcache_wb_inv(data, len);
+
+	desc->addr = dma_addr - offset;
+	desc->ctl = DMA_DESC_OWN | DMA_DESC_SOP | DMA_DESC_EOP |
+			DMA_DESC_TX_OFFSET(offset) | DMA_DESC_LENGTH(len);
+
+#if 0
+	printf("%s: index %d, desc %p, desc->ctl %08x\n",
+		__func__, index, desc, desc->ctl);
+#endif
+
+	return 0;
+}
+
+int ltq_dma_tx_wait(struct ltq_dma_device *dev, int index,
+			unsigned long timeout)
+{
+	struct ltq_dma_channel *chan = &dev->tx_chan;
+	struct ltq_dma_desc *desc = &chan->desc_base[index];
+	unsigned long timebase = get_timer(0);
+
+	while ((desc->ctl & (DMA_DESC_OWN | DMA_DESC_C)) != DMA_DESC_C) {
+		WATCHDOG_RESET();
+
+		if (get_timer(timebase) >= timeout)
+			return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 9df1e2632f774805b635edd317292cb3196fa6cf..328ff016501b3fa5591969d7b31ad42f0e908385 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -28,6 +28,7 @@ LIB 	:= $(obj)libgpio.o
 COBJS-$(CONFIG_AT91_GPIO)	+= at91_gpio.o
 COBJS-$(CONFIG_INTEL_ICH6_GPIO)	+= intel_ich6_gpio.o
 COBJS-$(CONFIG_KIRKWOOD_GPIO)	+= kw_gpio.o
+COBJS-$(CONFIG_LANTIQ_GPIO)	+= lantiq_gpio.o
 COBJS-$(CONFIG_MARVELL_GPIO)	+= mvgpio.o
 COBJS-$(CONFIG_MARVELL_MFP)	+= mvmfp.o
 COBJS-$(CONFIG_MXC_GPIO)	+= mxc_gpio.o
diff --git a/drivers/gpio/lantiq_gpio.c b/drivers/gpio/lantiq_gpio.c
new file mode 100644
index 0000000000000000000000000000000000000000..822559e5fbe2ee2533fd81ac76587d53c7329403
--- /dev/null
+++ b/drivers/gpio/lantiq_gpio.c
@@ -0,0 +1,341 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gpio.h>
+#include <asm/lantiq/io.h>
+
+#define SSIO_GPIO_BASE		64
+
+#define SSIO_CON0_SWU		(1 << 31)
+#define SSIO_CON0_RZFL		(1 << 26)
+#define SSIO_CON0_GPHY1_SHIFT	27
+#define SSIO_CON0_GPHY1_CONFIG	((CONFIG_LTQ_SSIO_GPHY1_MODE & 0x7) << 27)
+
+#define SSIO_CON1_US_FPI	(2 << 30)
+#define SSIO_CON1_FPID_2HZ	(0 << 23)
+#define SSIO_CON1_FPID_4HZ	(1 << 23)
+#define SSIO_CON1_FPID_8HZ	(2 << 23)
+#define SSIO_CON1_FPID_10HZ	(3 << 23)
+#define SSIO_CON1_FPIS_1_2	(1 << 20)
+#define SSIO_CON1_FPIS_1_32	(2 << 20)
+#define SSIO_CON1_FPIS_1_64	(3 << 20)
+
+#define SSIO_CON1_GPHY2_SHIFT	15
+#define SSIO_CON1_GPHY2_CONFIG	((CONFIG_LTQ_SSIO_GPHY2_MODE & 0x7) << 15)
+
+#define SSIO_CON1_GROUP2	(1 << 2)
+#define SSIO_CON1_GROUP1	(1 << 1)
+#define SSIO_CON1_GROUP0	(1 << 0)
+
+#ifdef CONFIG_LTQ_SSIO_SHIFT_REGS
+#define enable_ssio	1
+
+#if CONFIG_LTQ_SSIO_SHIFT_REGS == 1
+#define SSIO_CON1_GROUP_CONFIG	(SSIO_CON1_GROUP0)
+#elif CONFIG_LTQ_SSIO_SHIFT_REGS == 2
+#define SSIO_CON1_GROUP_CONFIG	(SSIO_CON1_GROUP0 | SSIO_CON1_GROUP1)
+#elif CONFIG_LTQ_SSIO_SHIFT_REGS == 3
+#define SSIO_CON1_GROUP_CONFIG	(SSIO_CON1_GROUP0 | SSIO_CON1_GROUP1 | \
+				SSIO_CON1_GROUP2)
+#else
+#define SSIO_CON1_GROUP_CONFIG	0
+#endif
+#else
+#define enable_ssio	0
+
+#define CONFIG_LTQ_SSIO_GPHY1_MODE	0
+#define CONFIG_LTQ_SSIO_GPHY2_MODE	0
+#define CONFIG_LTQ_SSIO_INIT_VALUE	0
+#define SSIO_CON1_GROUP_CONFIG		0
+#endif
+
+#ifdef CONFIG_LTQ_SSIO_EDGE_FALLING
+#define SSIO_RZFL_CONFIG	SSIO_CON0_RZFL
+#else
+#define SSIO_RZFL_CONFIG	0
+#endif
+
+struct ltq_gpio_port_regs {
+	__be32	out;
+	__be32	in;
+	__be32	dir;
+	__be32	altsel0;
+	__be32	altsel1;
+	__be32	od;
+	__be32	stoff;
+	__be32	pudsel;
+	__be32	puden;
+	__be32	rsvd1[3];
+};
+
+struct ltq_gpio_regs {
+	u32				rsvd[4];
+	struct ltq_gpio_port_regs	ports[CONFIG_LTQ_GPIO_MAX_BANKS];
+};
+
+struct ltq_gpio3_regs {
+	u32	rsvd0[13];
+	__be32	od;
+	__be32	pudsel;
+	__be32	puden;
+	u32	rsvd1[9];
+	__be32	altsel1;
+	u32	rsvd2[14];
+	__be32	out;
+	__be32	in;
+	__be32	dir;
+	__be32	altsel0;
+};
+
+struct ltq_ssio_regs {
+	__be32	con0;
+	__be32	con1;
+	__be32	cpu0;
+	__be32	cpu1;
+	__be32	ar;
+};
+
+static struct ltq_gpio_regs *ltq_gpio_regs =
+	(struct ltq_gpio_regs *) CKSEG1ADDR(LTQ_GPIO_BASE);
+
+static struct ltq_gpio3_regs *ltq_gpio3_regs =
+	(struct ltq_gpio3_regs *) CKSEG1ADDR(LTQ_GPIO_BASE);
+
+static struct ltq_ssio_regs *ltq_ssio_regs =
+	(struct ltq_ssio_regs *) CKSEG1ADDR(LTQ_SSIO_BASE);
+
+static int is_gpio_bank3(unsigned int port)
+{
+#ifdef CONFIG_LTQ_HAS_GPIO_BANK3
+	return port == 3;
+#else
+	return 0;
+#endif
+}
+
+static int is_gpio_ssio(unsigned int gpio)
+{
+#ifdef CONFIG_LTQ_SSIO_SHIFT_REGS
+	return gpio >= SSIO_GPIO_BASE;
+#else
+	return 0;
+#endif
+}
+
+static inline int ssio_gpio_to_bit(unsigned gpio)
+{
+	return 1 << (gpio - SSIO_GPIO_BASE);
+}
+
+int ltq_gpio_init(void)
+{
+	ltq_writel(&ltq_ssio_regs->ar, 0);
+	ltq_writel(&ltq_ssio_regs->cpu0, CONFIG_LTQ_SSIO_INIT_VALUE);
+	ltq_writel(&ltq_ssio_regs->cpu1, 0);
+	ltq_writel(&ltq_ssio_regs->con0, SSIO_CON0_SWU);
+
+	if (enable_ssio) {
+		ltq_writel(&ltq_ssio_regs->con0, SSIO_CON0_GPHY1_CONFIG |
+			SSIO_RZFL_CONFIG);
+		ltq_writel(&ltq_ssio_regs->con1, SSIO_CON1_US_FPI |
+			SSIO_CON1_FPID_8HZ | SSIO_CON1_GPHY2_CONFIG |
+			SSIO_CON1_GROUP_CONFIG);
+	}
+
+	return 0;
+}
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+int gpio_free(unsigned gpio)
+{
+	return 0;
+}
+
+int gpio_direction_input(unsigned gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_od = &ltq_gpio_regs->ports[port].od;
+	const void *gpio_altsel0 = &ltq_gpio_regs->ports[port].altsel0;
+	const void *gpio_altsel1 = &ltq_gpio_regs->ports[port].altsel1;
+	const void *gpio_dir = &ltq_gpio_regs->ports[port].dir;
+
+	if (is_gpio_ssio(gpio))
+		return 0;
+
+	if (is_gpio_bank3(port)) {
+		gpio_od = &ltq_gpio3_regs->od;
+		gpio_altsel0 = &ltq_gpio3_regs->altsel0;
+		gpio_altsel1 = &ltq_gpio3_regs->altsel1;
+		gpio_dir = &ltq_gpio3_regs->dir;
+	}
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_clrbits(gpio_od, gpio_to_bit(gpio));
+	ltq_clrbits(gpio_altsel0, gpio_to_bit(gpio));
+	ltq_clrbits(gpio_altsel1, gpio_to_bit(gpio));
+
+	/* Switch to input */
+	ltq_clrbits(gpio_dir, gpio_to_bit(gpio));
+
+	return 0;
+}
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_od = &ltq_gpio_regs->ports[port].od;
+	const void *gpio_altsel0 = &ltq_gpio_regs->ports[port].altsel0;
+	const void *gpio_altsel1 = &ltq_gpio_regs->ports[port].altsel1;
+	const void *gpio_dir = &ltq_gpio_regs->ports[port].dir;
+	const void *gpio_out = &ltq_gpio_regs->ports[port].out;
+	u32 data = gpio_to_bit(gpio);
+
+	if (is_gpio_ssio(gpio)) {
+		data = ssio_gpio_to_bit(gpio);
+		if (value)
+			ltq_setbits(&ltq_ssio_regs->cpu0, data);
+		else
+			ltq_clrbits(&ltq_ssio_regs->cpu0, data);
+
+		return 0;
+	}
+
+	if (is_gpio_bank3(port)) {
+		gpio_od = &ltq_gpio3_regs->od;
+		gpio_altsel0 = &ltq_gpio3_regs->altsel0;
+		gpio_altsel1 = &ltq_gpio3_regs->altsel1;
+		gpio_dir = &ltq_gpio3_regs->dir;
+		gpio_out = &ltq_gpio3_regs->out;
+	}
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_setbits(gpio_od, data);
+	ltq_clrbits(gpio_altsel0, data);
+	ltq_clrbits(gpio_altsel1, data);
+
+	if (value)
+		ltq_setbits(gpio_out, data);
+	else
+		ltq_clrbits(gpio_out, data);
+
+	/* Switch to output */
+	ltq_setbits(gpio_dir, data);
+
+	return 0;
+}
+
+int gpio_get_value(unsigned gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_in = &ltq_gpio_regs->ports[port].in;
+	u32 data = gpio_to_bit(gpio);
+	u32 val;
+
+	if (is_gpio_ssio(gpio)) {
+		gpio_in = &ltq_ssio_regs->cpu0;
+		data = ssio_gpio_to_bit(gpio);
+	}
+
+	if (is_gpio_bank3(port))
+		gpio_in = &ltq_gpio3_regs->in;
+
+	val = ltq_readl(gpio_in);
+
+	return !!(val & data);
+}
+
+int gpio_set_value(unsigned gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_out = &ltq_gpio_regs->ports[port].out;
+	u32 data = gpio_to_bit(gpio);
+
+	if (is_gpio_ssio(gpio)) {
+		gpio_out = &ltq_ssio_regs->cpu0;
+		data = ssio_gpio_to_bit(gpio);
+	}
+
+	if (is_gpio_bank3(port))
+		gpio_out = &ltq_gpio3_regs->out;
+
+	if (value)
+		ltq_setbits(gpio_out, data);
+	else
+		ltq_clrbits(gpio_out, data);
+
+	return 0;
+}
+
+int gpio_set_altfunc(unsigned gpio, int altsel0, int altsel1, int dir)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_od = &ltq_gpio_regs->ports[port].od;
+	const void *gpio_altsel0 = &ltq_gpio_regs->ports[port].altsel0;
+	const void *gpio_altsel1 = &ltq_gpio_regs->ports[port].altsel1;
+	const void *gpio_dir = &ltq_gpio_regs->ports[port].dir;
+
+	if (is_gpio_ssio(gpio))
+		return 0;
+
+	if (is_gpio_bank3(port)) {
+		gpio_od = &ltq_gpio3_regs->od;
+		gpio_altsel0 = &ltq_gpio3_regs->altsel0;
+		gpio_altsel1 = &ltq_gpio3_regs->altsel1;
+		gpio_dir = &ltq_gpio3_regs->dir;
+	}
+
+	if (altsel0)
+		ltq_setbits(gpio_altsel0, gpio_to_bit(gpio));
+	else
+		ltq_clrbits(gpio_altsel0, gpio_to_bit(gpio));
+
+	if (altsel1)
+		ltq_setbits(gpio_altsel1, gpio_to_bit(gpio));
+	else
+		ltq_clrbits(gpio_altsel1, gpio_to_bit(gpio));
+
+	if (dir) {
+		ltq_setbits(gpio_od, gpio_to_bit(gpio));
+		ltq_setbits(gpio_dir, gpio_to_bit(gpio));
+	} else {
+		ltq_clrbits(gpio_od, gpio_to_bit(gpio));
+		ltq_clrbits(gpio_dir, gpio_to_bit(gpio));
+	}
+
+	return 0;
+}
+
+int gpio_set_opendrain(unsigned gpio, int od)
+{
+	unsigned port = gpio_to_port(gpio);
+	const void *gpio_od = &ltq_gpio_regs->ports[port].od;
+
+	if (is_gpio_ssio(gpio))
+		return 0;
+
+	if (is_gpio_bank3(port))
+		gpio_od = &ltq_gpio3_regs->od;
+
+	if (od)
+		ltq_setbits(gpio_od, gpio_to_bit(gpio));
+	else
+		ltq_clrbits(gpio_od, gpio_to_bit(gpio));
+
+	return 0;
+}
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 22d84407dd4a6513eaed35bb029c009c86d40536..70678265a68c88bc063b51d18f581b14c4d12e2f 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -177,6 +177,18 @@ u64 flash_read64(void *addr)__attribute__((weak, alias("__flash_read64")));
 #define flash_read64	__flash_read64
 #endif
 
+static inline void *__flash_swap_addr(unsigned long addr)
+{
+	return (void *) addr;
+}
+
+#ifdef CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+void *flash_swap_addr(unsigned long addr)
+		__attribute__((weak, alias("__flash_swap_addr")));
+#else
+#define flash_swap_addr	__flash_swap_addr
+#endif
+
 /*-----------------------------------------------------------------------
  */
 #if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
@@ -212,7 +224,7 @@ flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
 {
 	unsigned int byte_offset = offset * info->portwidth;
 
-	return (void *)(info->start[sect] + byte_offset);
+	return flash_swap_addr(info->start[sect] + byte_offset);
 }
 
 static inline void flash_unmap(flash_info_t *info, flash_sect_t sect,
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index cbfc6796c7d6a96b3c81d353c0c2a141ac80b62c..ff9e7b7bd94fcc20d3e3038faad3683a48338c88 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -19,6 +19,11 @@
 #include <linux/mtd/partitions.h>
 #include <linux/compat.h>
 
+#ifdef CONFIG_LIB_SPHAIRON
+#undef printk
+#define printk		debug
+#endif
+
 /* Our partition linked list */
 struct list_head mtd_partitions;
 
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 35769c5ea3fbcbf00d848615b1dc3ed1b524534c..fff77084dc4ee86a49aba65a10ad66f9785477ab 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -67,6 +67,7 @@ COBJS-$(CONFIG_NAND_JZ4740) += jz4740_nand.o
 COBJS-$(CONFIG_NAND_KB9202) += kb9202_nand.o
 COBJS-$(CONFIG_NAND_KIRKWOOD) += kirkwood_nand.o
 COBJS-$(CONFIG_NAND_KMETER1) += kmeter1_nand.o
+COBJS-$(CONFIG_NAND_LANTIQ) += lantiq_nand.o
 COBJS-$(CONFIG_NAND_MPC5121_NFC) += mpc5121_nfc.o
 COBJS-$(CONFIG_NAND_MXC) += mxc_nand.o
 COBJS-$(CONFIG_NAND_MXS) += mxs_nand.o
diff --git a/drivers/mtd/nand/lantiq_nand.c b/drivers/mtd/nand/lantiq_nand.c
new file mode 100644
index 0000000000000000000000000000000000000000..8d92d1058589d48edf1d8e05787eb01b173263fc
--- /dev/null
+++ b/drivers/mtd/nand/lantiq_nand.c
@@ -0,0 +1,127 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <linux/mtd/nand.h>
+#include <linux/compiler.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/nand.h>
+#include <asm/lantiq/io.h>
+
+#define NAND_CON_ECC_ON		(1 << 31)
+#define NAND_CON_LATCH_PRE	(1 << 23)
+#define NAND_CON_LATCH_WP	(1 << 22)
+#define NAND_CON_LATCH_SE	(1 << 21)
+#define NAND_CON_LATCH_CS	(1 << 20)
+#define NAND_CON_LATCH_CLE	(1 << 19)
+#define NAND_CON_LATCH_ALE	(1 << 18)
+#define NAND_CON_OUT_CS1	(1 << 10)
+#define NAND_CON_IN_CS1		(1 << 8)
+#define NAND_CON_PRE_P		(1 << 7)
+#define NAND_CON_WP_P		(1 << 6)
+#define NAND_CON_SE_P		(1 << 5)
+#define NAND_CON_CS_P		(1 << 4)
+#define NAND_CON_CLE_P		(1 << 3)
+#define NAND_CON_ALE_P		(1 << 2)
+#define NAND_CON_CSMUX		(1 << 1)
+#define NAND_CON_NANDM		(1 << 0)
+
+#define NAND_WAIT_WR_C		(1 << 3)
+#define NAND_WAIT_RDBY		(1 << 0)
+
+#define NAND_CMD_ALE		(1 << 2)
+#define NAND_CMD_CLE		(1 << 3)
+#define NAND_CMD_CS		(1 << 4)
+#define NAND_CMD_SE		(1 << 5)
+#define NAND_CMD_WP		(1 << 6)
+#define NAND_CMD_PRE		(1 << 7)
+
+struct ltq_nand_regs {
+	__be32	con;		/* NAND controller control */
+	__be32	wait;		/* NAND Flash Device RD/BY State */
+	__be32	ecc0;		/* NAND Flash ECC Register 0 */
+	__be32	ecc_ac;		/* NAND Flash ECC Register address counter */
+	__be32	ecc_cr;		/* NAND Flash ECC Comparison */
+};
+
+static struct ltq_nand_regs *ltq_nand_regs =
+	(struct ltq_nand_regs *) CKSEG1ADDR(LTQ_EBU_NAND_BASE);
+
+static void ltq_nand_wait_ready(void)
+{
+	while ((ltq_readl(&ltq_nand_regs->wait) & NAND_WAIT_WR_C) == 0)
+		;
+}
+
+static int ltq_nand_dev_ready(struct mtd_info *mtd)
+{
+	u32 data = ltq_readl(&ltq_nand_regs->wait);
+	return data & NAND_WAIT_RDBY;
+}
+
+static void ltq_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	if (chip == 0) {
+		ltq_setbits(&ltq_nand_regs->con, NAND_CON_NANDM);
+		ltq_setbits(&ltq_nand_regs->con, NAND_CON_LATCH_CS);
+	} else {
+		ltq_clrbits(&ltq_nand_regs->con, NAND_CON_LATCH_CS);
+		ltq_clrbits(&ltq_nand_regs->con, NAND_CON_NANDM);
+	}
+}
+
+static void ltq_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+	unsigned long addr = (unsigned long) chip->IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_ALE)
+			addr |= NAND_CMD_ALE;
+		else
+			addr &= ~NAND_CMD_ALE;
+
+		if (ctrl & NAND_CLE)
+			addr |= NAND_CMD_CLE;
+		else
+			addr &= ~NAND_CMD_CLE;
+
+		chip->IO_ADDR_W = (void __iomem *) addr;
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		writeb(cmd, chip->IO_ADDR_W);
+		ltq_nand_wait_ready();
+	}
+}
+
+int ltq_nand_init(struct nand_chip *nand)
+{
+	/* Enable NAND, set NAND CS to EBU CS1, enable EBU CS mux */
+	ltq_writel(&ltq_nand_regs->con, NAND_CON_OUT_CS1 | NAND_CON_IN_CS1 |
+		NAND_CON_PRE_P | NAND_CON_WP_P | NAND_CON_SE_P |
+		NAND_CON_CS_P | NAND_CON_CSMUX);
+
+	nand->dev_ready = ltq_nand_dev_ready;
+	nand->select_chip = ltq_nand_select_chip;
+	nand->cmd_ctrl = ltq_nand_cmd_ctrl;
+
+	nand->chip_delay = 30;
+	nand->options = 0;
+	nand->ecc.mode = NAND_ECC_SOFT;
+
+	/* Enable CS bit in address offset */
+	nand->IO_ADDR_R = nand->IO_ADDR_R + NAND_CMD_CS;
+	nand->IO_ADDR_W = nand->IO_ADDR_W + NAND_CMD_CS;
+
+	return 0;
+}
+
+__weak int board_nand_init(struct nand_chip *chip)
+{
+	return ltq_nand_init(chip);
+}
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index 90f83924e2bf23b9ab4c621495ca236c14a19acd..6812de330540a2d542b16651d089d2aaa1fc3be0 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -30,6 +30,7 @@ COBJS-$(CONFIG_SPL_SPI_LOAD)	+= spi_spl_load.o
 endif
 
 COBJS-$(CONFIG_SPI_FLASH)	+= spi_flash.o
+COBJS-$(CONFIG_SPI_FLASH_MTD)	+= spi_flash_mtd.o
 COBJS-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
 COBJS-$(CONFIG_SPI_FLASH_EON)	+= eon.o
 COBJS-$(CONFIG_SPI_FLASH_MACRONIX)	+= macronix.o
diff --git a/drivers/mtd/spi/atmel.c b/drivers/mtd/spi/atmel.c
index 6a92c4b774b41ff85dbb834ccc206e12b8a7017d..9fce8f8e5aacda8a7473c9eeb5bb61565d348726 100644
--- a/drivers/mtd/spi/atmel.c
+++ b/drivers/mtd/spi/atmel.c
@@ -40,18 +40,6 @@ struct atmel_spi_flash_params {
 	const char	*name;
 };
 
-/* spi_flash needs to be first so upper layers can free() it */
-struct atmel_spi_flash {
-	struct spi_flash flash;
-	const struct atmel_spi_flash_params *params;
-};
-
-static inline struct atmel_spi_flash *
-to_atmel_spi_flash(struct spi_flash *flash)
-{
-	return container_of(flash, struct atmel_spi_flash, flash);
-}
-
 static const struct atmel_spi_flash_params atmel_spi_flash_table[] = {
 	{
 		.idcode1		= 0x22,
@@ -156,7 +144,8 @@ static int at45_wait_ready(struct spi_flash *flash, unsigned long timeout)
  * Assemble the address part of a command for AT45 devices in
  * non-power-of-two page size mode.
  */
-static void at45_build_address(struct atmel_spi_flash *asf, u8 *cmd, u32 offset)
+static void at45_build_address(const struct atmel_spi_flash_params *params,
+				u8 *cmd, u32 offset)
 {
 	unsigned long page_addr;
 	unsigned long byte_addr;
@@ -167,7 +156,7 @@ static void at45_build_address(struct atmel_spi_flash *asf, u8 *cmd, u32 offset)
 	 * The "extra" space per page is the power-of-two page size
 	 * divided by 32.
 	 */
-	page_shift = asf->params->l2_page_size;
+	page_shift = params->l2_page_size;
 	page_size = (1 << page_shift) + (1 << (page_shift - 5));
 	page_shift++;
 	page_addr = offset / page_size;
@@ -181,11 +170,11 @@ static void at45_build_address(struct atmel_spi_flash *asf, u8 *cmd, u32 offset)
 static int dataflash_read_fast_at45(struct spi_flash *flash,
 		u32 offset, size_t len, void *buf)
 {
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	const struct atmel_spi_flash_params *params = flash->priv;
 	u8 cmd[5];
 
 	cmd[0] = CMD_READ_ARRAY_FAST;
-	at45_build_address(asf, cmd + 1, offset);
+	at45_build_address(params, cmd + 1, offset);
 	cmd[4] = 0x00;
 
 	return spi_flash_read_common(flash, cmd, sizeof(cmd), buf, len);
@@ -197,7 +186,7 @@ static int dataflash_read_fast_at45(struct spi_flash *flash,
 static int dataflash_write_p2(struct spi_flash *flash,
 		u32 offset, size_t len, const void *buf)
 {
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	const struct atmel_spi_flash_params *params = flash->priv;
 	unsigned long page_size;
 	u32 addr = offset;
 	size_t chunk_len;
@@ -211,7 +200,7 @@ static int dataflash_write_p2(struct spi_flash *flash,
 	 * the other is being programmed into main memory.
 	 */
 
-	page_size = (1 << asf->params->l2_page_size);
+	page_size = (1 << params->l2_page_size);
 
 	ret = spi_claim_bus(flash->spi);
 	if (ret) {
@@ -263,7 +252,7 @@ out:
 static int dataflash_write_at45(struct spi_flash *flash,
 		u32 offset, size_t len, const void *buf)
 {
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	const struct atmel_spi_flash_params *params = flash->priv;
 	unsigned long page_addr;
 	unsigned long byte_addr;
 	unsigned long page_size;
@@ -279,7 +268,7 @@ static int dataflash_write_at45(struct spi_flash *flash,
 	 * the other is being programmed into main memory.
 	 */
 
-	page_shift = asf->params->l2_page_size;
+	page_shift = params->l2_page_size;
 	page_size = (1 << page_shift) + (1 << (page_shift - 5));
 	page_shift++;
 	page_addr = offset / page_size;
@@ -338,7 +327,7 @@ out:
  */
 static int dataflash_erase_p2(struct spi_flash *flash, u32 offset, size_t len)
 {
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	const struct atmel_spi_flash_params *params = flash->priv;
 	unsigned long page_size;
 
 	size_t actual;
@@ -351,7 +340,7 @@ static int dataflash_erase_p2(struct spi_flash *flash, u32 offset, size_t len)
 	 * when possible.
 	 */
 
-	page_size = (1 << asf->params->l2_page_size);
+	page_size = (1 << params->l2_page_size);
 
 	if (offset % page_size || len % page_size) {
 		debug("SF: Erase offset/length not multiple of page size\n");
@@ -397,7 +386,7 @@ out:
 
 static int dataflash_erase_at45(struct spi_flash *flash, u32 offset, size_t len)
 {
-	struct atmel_spi_flash *asf = to_atmel_spi_flash(flash);
+	const struct atmel_spi_flash_params *params = flash->priv;
 	unsigned long page_addr;
 	unsigned long page_size;
 	unsigned int page_shift;
@@ -411,7 +400,7 @@ static int dataflash_erase_at45(struct spi_flash *flash, u32 offset, size_t len)
 	 * when possible.
 	 */
 
-	page_shift = asf->params->l2_page_size;
+	page_shift = params->l2_page_size;
 	page_size = (1 << page_shift) + (1 << (page_shift - 5));
 	page_shift++;
 	page_addr = offset / page_size;
@@ -458,12 +447,12 @@ out:
 	return ret;
 }
 
-struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode)
+int spi_flash_probe_atmel(struct spi_flash *flash, u8 *idcode)
 {
 	const struct atmel_spi_flash_params *params;
+	struct spi_slave *spi = flash->spi;
 	unsigned page_size;
 	unsigned int family;
-	struct atmel_spi_flash *asf;
 	unsigned int i;
 	int ret;
 	u8 status;
@@ -477,16 +466,11 @@ struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode)
 	if (i == ARRAY_SIZE(atmel_spi_flash_table)) {
 		debug("SF: Unsupported DataFlash ID %02x\n",
 				idcode[1]);
-		return NULL;
-	}
-
-	asf = spi_flash_alloc(struct atmel_spi_flash, spi, params->name);
-	if (!asf) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
+		return 0;
 	}
 
-	asf->params = params;
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	/* Assuming power-of-two page size initially. */
 	page_size = 1 << params->l2_page_size;
@@ -501,44 +485,40 @@ struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode)
 		 */
 		ret = spi_flash_cmd(spi, CMD_AT45_READ_STATUS, &status, 1);
 		if (ret)
-			goto err;
+			return -1;
 
 		debug("SF: AT45 status register: %02x\n", status);
 
 		if (!(status & AT45_STATUS_P2_PAGE_SIZE)) {
-			asf->flash.read = dataflash_read_fast_at45;
-			asf->flash.write = dataflash_write_at45;
-			asf->flash.erase = dataflash_erase_at45;
+			flash->read = dataflash_read_fast_at45;
+			flash->write = dataflash_write_at45;
+			flash->erase = dataflash_erase_at45;
 			page_size += 1 << (params->l2_page_size - 5);
 		} else {
-			asf->flash.write = dataflash_write_p2;
-			asf->flash.erase = dataflash_erase_p2;
+			flash->write = dataflash_write_p2;
+			flash->erase = dataflash_erase_p2;
 		}
 
-		asf->flash.page_size = page_size;
-		asf->flash.sector_size = page_size;
+		flash->page_size = page_size;
+		flash->sector_size = page_size;
 		break;
 
 	case DF_FAMILY_AT26F:
 	case DF_FAMILY_AT26DF:
-		asf->flash.page_size = page_size;
-		asf->flash.sector_size = 4096;
+		flash->page_size = page_size;
+		flash->sector_size = 4096;
 		/* clear SPRL# bit for locked flash */
-		spi_flash_cmd_write_status(&asf->flash, 0);
+		spi_flash_cmd_write_status(flash, 0);
 		break;
 
 	default:
 		debug("SF: Unsupported DataFlash family %u\n", family);
-		goto err;
+		return -1;
 	}
 
-	asf->flash.size = page_size * params->pages_per_block
+	flash->size = page_size * params->pages_per_block
 				* params->blocks_per_sector
 				* params->nr_sectors;
 
-	return &asf->flash;
-
-err:
-	free(asf);
-	return NULL;
+	return 1;
 }
diff --git a/drivers/mtd/spi/eon.c b/drivers/mtd/spi/eon.c
index b16e7ab098ea36b7d1146ad7028fe3ec910e2e85..c0563f0dd82551e9fa197fca57ea1e95bde04ebd 100644
--- a/drivers/mtd/spi/eon.c
+++ b/drivers/mtd/spi/eon.c
@@ -10,52 +10,68 @@
 
 #include "spi_flash_internal.h"
 
+#define EN25XX_EN4B		0xb7	/* Enter 4-byte mode */
+
 struct eon_spi_flash_params {
-	u8 idcode1;
+	u16 idcode;
 	u16 nr_sectors;
 	const char *name;
 };
 
 static const struct eon_spi_flash_params eon_spi_flash_table[] = {
 	{
-		.idcode1 = 0x16,
+		.idcode = 0x3016,
 		.nr_sectors = 1024,
 		.name = "EN25Q32B",
 	},
 	{
-		.idcode1 = 0x18,
+		.idcode = 0x3018,
 		.nr_sectors = 4096,
 		.name = "EN25Q128",
 	},
+	{
+		.idcode = 0x7019,
+		.nr_sectors = 8192,
+		.name = "EN25QH256",
+	},
 };
 
-struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode)
+static __maybe_unused int eon_set_4byte_mode(struct spi_flash *flash)
+{
+	struct spi_slave *spi = flash->spi;
+
+	return spi_flash_cmd(spi, EN25XX_EN4B, NULL, 0);
+}
+
+int spi_flash_probe_eon(struct spi_flash *flash, u8 *idcode)
 {
 	const struct eon_spi_flash_params *params;
-	struct spi_flash *flash;
 	unsigned int i;
+	u16 id = idcode[2] | idcode[1] << 8;
 
 	for (i = 0; i < ARRAY_SIZE(eon_spi_flash_table); ++i) {
 		params = &eon_spi_flash_table[i];
-		if (params->idcode1 == idcode[2])
+		if (params->idcode == id)
 			break;
 	}
 
 	if (i == ARRAY_SIZE(eon_spi_flash_table)) {
 		debug("SF: Unsupported EON ID %02x\n", idcode[1]);
-		return NULL;
+		return 0;
 	}
 
-	flash = spi_flash_alloc_base(spi, params->name);
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	flash->page_size = 256;
 	flash->sector_size = 256 * 16 * 16;
 	flash->size = 256 * 16
 	    * params->nr_sectors;
 
-	return flash;
+#ifdef CONFIG_SPI_FLASH_4BYTE_MODE
+	if (flash->size > (1 << 24))
+		flash->set_4byte_mode = eon_set_4byte_mode;
+#endif
+
+	return 1;
 }
diff --git a/drivers/mtd/spi/macronix.c b/drivers/mtd/spi/macronix.c
index 036c30d3beee54488de1b20b4cedd8b93b2a7d75..2472cd299aa1c1f2d0f32ed2d9811d0126a81d3f 100644
--- a/drivers/mtd/spi/macronix.c
+++ b/drivers/mtd/spi/macronix.c
@@ -35,6 +35,8 @@
 
 #include "spi_flash_internal.h"
 
+#define MX25XX_EN4B		0xb7	/* Enter 4-byte mode */
+
 struct macronix_spi_flash_params {
 	u16 idcode;
 	u16 nr_blocks;
@@ -77,12 +79,28 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.nr_blocks = 256,
 		.name = "MX25L12855E",
 	},
+	{
+		.idcode = 0x2019,
+		.nr_blocks = 512,
+		.name = "MX25L25635E",
+	},
+	{
+		.idcode = 0x201A,
+		.nr_blocks = 1024,
+		.name = "MX66L51235L",
+	},
 };
 
-struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
+static __maybe_unused int macronix_set_4byte_mode(struct spi_flash *flash)
+{
+	struct spi_slave *spi = flash->spi;
+
+	return spi_flash_cmd(spi, MX25XX_EN4B, NULL, 0);
+}
+
+int spi_flash_probe_macronix(struct spi_flash *flash, u8 *idcode)
 {
 	const struct macronix_spi_flash_params *params;
-	struct spi_flash *flash;
 	unsigned int i;
 	u16 id = idcode[2] | idcode[1] << 8;
 
@@ -94,21 +112,23 @@ struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
 
 	if (i == ARRAY_SIZE(macronix_spi_flash_table)) {
 		debug("SF: Unsupported Macronix ID %04x\n", id);
-		return NULL;
+		return 0;
 	}
 
-	flash = spi_flash_alloc_base(spi, params->name);
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	flash->page_size = 256;
 	flash->sector_size = 256 * 16 * 16;
 	flash->size = flash->sector_size * params->nr_blocks;
 
+#ifdef CONFIG_SPI_FLASH_4BYTE_MODE
+	if (flash->size > (1 << 24))
+		flash->set_4byte_mode = macronix_set_4byte_mode;
+#endif
+
 	/* Clear BP# bits for read-only flash */
 	spi_flash_cmd_write_status(flash, 0);
 
-	return flash;
+	return 1;
 }
diff --git a/drivers/mtd/spi/ramtron.c b/drivers/mtd/spi/ramtron.c
index 5299a6dbde09882e1e76ca232442d68dba698237..e0d5c55c8b5f6009641a4ec0da83fa124e4a895d 100644
--- a/drivers/mtd/spi/ramtron.c
+++ b/drivers/mtd/spi/ramtron.c
@@ -69,17 +69,6 @@ struct ramtron_spi_fram_params {
 	const char *name;	/* name for display and/or matching */
 };
 
-struct ramtron_spi_fram {
-	struct spi_flash flash;
-	const struct ramtron_spi_fram_params *params;
-};
-
-static inline struct ramtron_spi_fram *to_ramtron_spi_fram(struct spi_flash
-							     *flash)
-{
-	return container_of(flash, struct ramtron_spi_fram, flash);
-}
-
 /*
  * table describing supported FRAM chips:
  * chips without RDID command must have the values 0xff for id1 and id2
@@ -155,18 +144,18 @@ static const struct ramtron_spi_fram_params ramtron_spi_fram_table[] = {
 static int ramtron_common(struct spi_flash *flash,
 		u32 offset, size_t len, void *buf, u8 command)
 {
-	struct ramtron_spi_fram *sn = to_ramtron_spi_fram(flash);
+	const struct ramtron_spi_fram_params *params = flash->priv;
 	u8 cmd[4];
 	int cmd_len;
 	int ret;
 
-	if (sn->params->addr_len == 3 && sn->params->merge_cmd == 0) {
+	if (params->addr_len == 3 && params->merge_cmd == 0) {
 		cmd[0] = command;
 		cmd[1] = offset >> 16;
 		cmd[2] = offset >> 8;
 		cmd[3] = offset;
 		cmd_len = 4;
-	} else if (sn->params->addr_len == 2 && sn->params->merge_cmd == 0) {
+	} else if (params->addr_len == 2 && params->merge_cmd == 0) {
 		cmd[0] = command;
 		cmd[1] = offset >> 8;
 		cmd[2] = offset;
@@ -230,10 +219,9 @@ static int ramtron_erase(struct spi_flash *flash, u32 offset, size_t len)
  * nore: we are called here with idcode pointing to the first non-0x7f byte
  * already!
  */
-struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
+int spi_fram_probe_ramtron(struct spi_flash *flash, u8 *idcode)
 {
 	const struct ramtron_spi_fram_params *params;
-	struct ramtron_spi_fram *sn;
 	unsigned int i;
 #ifdef CONFIG_SPI_FRAM_RAMTRON_NON_JEDEC
 	int ret;
@@ -259,11 +247,11 @@ struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
 		 */
 		ret = spi_flash_cmd(spi, CMD_READ_STATUS, &sr, 1);
 		if (ret)
-			return NULL;
+			return 0;
 
 		/* Bits 5,4,0 are fixed 0 for all devices */
 		if ((sr & 0x31) != 0x00)
-			return NULL;
+			return 0;
 		/* now find the device */
 		for (i = 0; i < ARRAY_SIZE(ramtron_spi_fram_table); i++) {
 			params = &ramtron_spi_fram_table[i];
@@ -281,21 +269,16 @@ struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode)
 	/* arriving here means no method has found a device we can handle */
 	debug("SF/ramtron: unsupported device id0=%02x id1=%02x id2=%02x\n",
 		idcode[0], idcode[1], idcode[2]);
-	return NULL;
+	return 0;
 
 found:
-	sn = spi_flash_alloc(struct ramtron_spi_fram, spi, params->name);
-	if (!sn) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
-
-	sn->params = params;
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
-	sn->flash.write = ramtron_write;
-	sn->flash.read = ramtron_read;
-	sn->flash.erase = ramtron_erase;
-	sn->flash.size = params->size;
+	flash->write = ramtron_write;
+	flash->read = ramtron_read;
+	flash->erase = ramtron_erase;
+	flash->size = params->size;
 
-	return &sn->flash;
+	return 1;
 }
diff --git a/drivers/mtd/spi/spansion.c b/drivers/mtd/spi/spansion.c
index bc558c4c96ba317bffac1a66730bc28c2f49be32..2b4f5e17969166e3843ecb86dadf1ccb91ee546f 100644
--- a/drivers/mtd/spi/spansion.c
+++ b/drivers/mtd/spi/spansion.c
@@ -31,6 +31,10 @@
 
 #include "spi_flash_internal.h"
 
+#define S25FLXX_BRRD		0x16		/* Read Bank Register */
+#define S25FLXX_BRWR		0x17		/* Write Bank Register */
+#define S25FLXX_BAR_EXTADD	(1 << 7)	/* Extended address enable */
+
 struct spansion_spi_flash_params {
 	u16 idcode1;
 	u16 idcode2;
@@ -101,14 +105,44 @@ static const struct spansion_spi_flash_params spansion_spi_flash_table[] = {
 		.idcode2 = 0x4d01,
 		.pages_per_sector = 256,
 		.nr_sectors = 512,
-		.name = "S25FL256S",
+		.name = "S25FL256S_64K",
+	},
+	{
+		.idcode1 = 0x0219,
+		.idcode2 = 0x4d00,
+		.pages_per_sector = 1024,
+		.nr_sectors = 128,
+		.name = "S25FL256S_256K",
+	},
+	{
+		.idcode1 = 0x0220,
+		.idcode2 = 0x4d00,
+		.pages_per_sector = 1024,
+		.nr_sectors = 256,
+		.name = "S25FL512S_256K",
 	},
 };
 
-struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
+static __maybe_unused int spansion_set_4byte_mode(struct spi_flash *flash)
+{
+	struct spi_slave *spi = flash->spi;
+	u8 bar, cmd;
+	int err;
+
+	cmd = S25FLXX_BRRD;
+	err = spi_flash_cmd(spi, cmd, &bar, 1);
+	if (err)
+		return err;
+
+	bar |= S25FLXX_BAR_EXTADD;
+	cmd = S25FLXX_BRWR;
+
+	return spi_flash_cmd_write(spi, &cmd, 1, &bar, 1);
+}
+
+int spi_flash_probe_spansion(struct spi_flash *flash, u8 *idcode)
 {
 	const struct spansion_spi_flash_params *params;
-	struct spi_flash *flash;
 	unsigned int i;
 	unsigned short jedec, ext_jedec;
 
@@ -125,18 +159,20 @@ struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode)
 
 	if (i == ARRAY_SIZE(spansion_spi_flash_table)) {
 		debug("SF: Unsupported SPANSION ID %04x %04x\n", jedec, ext_jedec);
-		return NULL;
+		return 0;
 	}
 
-	flash = spi_flash_alloc_base(spi, params->name);
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	flash->page_size = 256;
 	flash->sector_size = 256 * params->pages_per_sector;
 	flash->size = flash->sector_size * params->nr_sectors;
 
-	return flash;
+#ifdef CONFIG_SPI_FLASH_4BYTE_MODE
+	if (flash->size > (1 << 24))
+		flash->set_4byte_mode = spansion_set_4byte_mode;
+#endif
+
+	return 1;
 }
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 111185af17586900b7ff447ead1e0ea9d131ecc4..5d508732900e93f949ac9376fc873fabfcb075fb 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -18,12 +18,38 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-static void spi_flash_addr(u32 addr, u8 *cmd)
+static void spi_flash_addr(struct spi_flash *flash, u32 addr, u8 *cmd, u8 *cmd_len)
 {
 	/* cmd[0] is actual command */
-	cmd[1] = addr >> 16;
-	cmd[2] = addr >> 8;
-	cmd[3] = addr >> 0;
+	if (spi_flash_use_4byte_mode(flash)) {
+		cmd[1] = addr >> 24;
+		cmd[2] = addr >> 16;
+		cmd[3] = addr >> 8;
+		cmd[4] = addr >> 0;
+		*cmd_len = 5;
+	} else {
+		cmd[1] = addr >> 16;
+		cmd[2] = addr >> 8;
+		cmd[3] = addr >> 0;
+		*cmd_len = 4;
+	}
+}
+
+static void spi_flash_page_addr(struct spi_flash *flash, u32 page_addr, u32 byte_addr, u8 *cmd, u8 *cmd_len)
+{
+	/* cmd[0] is actual command */
+	if (spi_flash_use_4byte_mode(flash)) {
+		cmd[1] = page_addr >> 16;
+		cmd[2] = page_addr >> 8;
+		cmd[3] = page_addr >> 0;
+		cmd[4] = byte_addr;
+		*cmd_len = 5;
+	} else {
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr >> 0;
+		cmd[3] = byte_addr;
+		*cmd_len = 4;
+	}
 }
 
 static int spi_flash_read_write(struct spi_slave *spi,
@@ -74,7 +100,7 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 	unsigned long page_addr, byte_addr, page_size;
 	size_t chunk_len, actual;
 	int ret;
-	u8 cmd[4];
+	u8 cmd[5], cmd_len;
 
 	page_size = flash->page_size;
 	page_addr = offset / page_size;
@@ -93,12 +119,10 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 		if (flash->spi->max_write_size)
 			chunk_len = min(chunk_len, flash->spi->max_write_size);
 
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
+		spi_flash_page_addr(flash, page_addr, byte_addr, cmd, &cmd_len);
 
-		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
-		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x%02x } chunk_len = %zu\n",
+		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], chunk_len);
 
 		ret = spi_flash_cmd_write_enable(flash);
 		if (ret < 0) {
@@ -106,7 +130,7 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 			break;
 		}
 
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len,
 					  buf + actual, chunk_len);
 		if (ret < 0) {
 			debug("SF: write failed\n");
@@ -147,17 +171,17 @@ int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 int spi_flash_cmd_read_fast(struct spi_flash *flash, u32 offset,
 		size_t len, void *data)
 {
-	u8 cmd[5];
+	u8 cmd[6], cmd_len;
 
 	/* Handle memory-mapped SPI */
 	if (flash->memory_map)
 		memcpy(data, flash->memory_map + offset, len);
 
 	cmd[0] = CMD_READ_ARRAY_FAST;
-	spi_flash_addr(offset, cmd);
-	cmd[4] = 0x00;
+	spi_flash_addr(flash, offset, cmd, &cmd_len);
+	cmd[cmd_len] = 0x00;
 
-	return spi_flash_read_common(flash, cmd, sizeof(cmd), data, len);
+	return spi_flash_read_common(flash, cmd, cmd_len + 1, data, len);
 }
 
 int spi_flash_cmd_poll_bit(struct spi_flash *flash, unsigned long timeout,
@@ -207,7 +231,7 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len)
 {
 	u32 start, end, erase_size;
 	int ret;
-	u8 cmd[4];
+	u8 cmd[5], cmd_len;
 
 	erase_size = flash->sector_size;
 	if (offset % erase_size || len % erase_size) {
@@ -229,17 +253,17 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len)
 	end = start + len;
 
 	while (offset < end) {
-		spi_flash_addr(offset, cmd);
+		spi_flash_addr(flash, offset, cmd, &cmd_len);
 		offset += erase_size;
 
-		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
-		      cmd[2], cmd[3], offset);
+		debug("SF: erase %2x %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
+		      cmd[2], cmd[3], cmd[4], offset);
 
 		ret = spi_flash_cmd_write_enable(flash);
 		if (ret)
 			goto out;
 
-		ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), NULL, 0);
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len, NULL, 0);
 		if (ret)
 			goto out;
 
@@ -337,7 +361,7 @@ int spi_flash_decode_fdt(const void *blob, struct spi_flash *flash)
 static const struct {
 	const u8 shift;
 	const u8 idcode;
-	struct spi_flash *(*probe) (struct spi_slave *spi, u8 *idcode);
+	int (*probe) (struct spi_flash *flash, u8 *idcode);
 } flashes[] = {
 	/* Keep it sorted by define name */
 #ifdef CONFIG_SPI_FLASH_ATMEL
@@ -376,18 +400,18 @@ static const struct {
 };
 #define IDCODE_LEN (IDCODE_CONT_LEN + IDCODE_PART_LEN)
 
-struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int spi_mode)
+int spi_flash_probe_spl(struct spi_flash *flash, unsigned int bus,
+			unsigned int cs, unsigned int max_hz,
+			unsigned int spi_mode)
 {
 	struct spi_slave *spi;
-	struct spi_flash *flash = NULL;
 	int ret, i, shift;
 	u8 idcode[IDCODE_LEN], *idp;
 
 	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
 	if (!spi) {
-		printf("SF: Failed to set up slave\n");
-		return NULL;
+		debug("SF: Failed to set up slave\n");
+		return -1;
 	}
 
 	ret = spi_claim_bus(spi);
@@ -406,6 +430,11 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	print_buffer(0, idcode, 1, sizeof(idcode), 0);
 #endif
 
+	flash->spi = spi;
+	flash->read = spi_flash_cmd_read_fast;
+	flash->write = spi_flash_cmd_write_multi;
+	flash->erase = spi_flash_cmd_erase;
+
 	/* count the number of continuation bytes */
 	for (shift = 0, idp = idcode;
 	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
@@ -416,13 +445,13 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	for (i = 0; i < ARRAY_SIZE(flashes); ++i)
 		if (flashes[i].shift == shift && flashes[i].idcode == *idp) {
 			/* we have a match, call probe */
-			flash = flashes[i].probe(spi, idp);
-			if (flash)
+			ret = flashes[i].probe(flash, idp);
+			if (ret)
 				break;
 		}
 
-	if (!flash) {
-		printf("SF: Unsupported manufacturer %02x\n", *idp);
+	if (ret <= 0) {
+		debug("SF: Unsupported manufacturer %02x\n", *idp);
 		goto err_manufacturer_probe;
 	}
 
@@ -432,22 +461,54 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		goto err_manufacturer_probe;
 	}
 #endif
-	printf("SF: Detected %s with page size ", flash->name);
-	print_size(flash->sector_size, ", total ");
-	print_size(flash->size, "");
-	if (flash->memory_map)
-		printf(", mapped at %p", flash->memory_map);
-	puts("\n");
+
+	ret = spi_flash_set_4byte_mode(flash);
+	if (ret) {
+		debug("SF: Failed to enable 4 byte mode: %d\n", ret);
+		goto err_manufacturer_probe;
+	}
 
 	spi_release_bus(spi);
 
-	return flash;
+	return 0;
 
 err_manufacturer_probe:
 err_read_id:
 	spi_release_bus(spi);
 err_claim_bus:
 	spi_free_slave(spi);
+
+	return ret;
+}
+
+struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_flash *flash;
+	int ret;
+
+	flash = malloc(sizeof(*flash));
+	if (!flash) {
+		debug("SF: Failed to malloc spi_flash\n");
+		return NULL;
+	}
+	memset(flash, 0, sizeof(*flash));
+
+	ret = spi_flash_probe_spl(flash, bus, cs, max_hz, spi_mode);
+	if (ret)
+		goto err_probe;
+
+	printf("SF:    %s, page size ", flash->name);
+	print_size(flash->sector_size, ", total ");
+	print_size(flash->size, "");
+	if (flash->memory_map)
+		printf(", mapped at %p", flash->memory_map);
+	puts("\n");
+
+	return flash;
+
+err_probe:
+	free(flash);
 	return NULL;
 }
 
@@ -476,8 +537,46 @@ void *spi_flash_do_alloc(int offset, int size, struct spi_slave *spi,
 	return flash;
 }
 
-void spi_flash_free(struct spi_flash *flash)
+void spi_flash_free_spl(struct spi_flash *flash)
 {
 	spi_free_slave(flash->spi);
+}
+
+void spi_flash_free(struct spi_flash *flash)
+{
+	spi_flash_free_spl(flash);
 	free(flash);
 }
+
+#ifdef CONFIG_SPI_FLASH_MTD
+static int spi_flash_mtd_register(void)
+{
+	struct spi_flash *flash;
+	int err;
+
+	flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (!flash)
+		return -1;
+
+	err = spi_flash_mtd_init(flash);
+	if (err)
+		spi_flash_free(flash);
+
+	return err;
+}
+#else
+static int spi_flash_mtd_register(void)
+{
+	return 0;
+}
+#endif
+
+int spi_flash_init(void)
+{
+	int err;
+
+	err = spi_flash_mtd_register();
+
+	return err;
+}
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
index 141cfa8b26d75e6e816c7315530854a93035b803..f30161808e69516e0af5295d5f02b315a801af91 100644
--- a/drivers/mtd/spi/spi_flash_internal.h
+++ b/drivers/mtd/spi/spi_flash_internal.h
@@ -97,12 +97,40 @@ int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout);
 /* Erase sectors. */
 int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len);
 
+#ifdef CONFIG_SPI_FLASH_4BYTE_MODE
+static inline int spi_flash_use_4byte_mode(struct spi_flash *flash)
+{
+	return NULL != flash->set_4byte_mode;
+}
+
+static inline int spi_flash_set_4byte_mode(struct spi_flash *flash)
+{
+	if (spi_flash_use_4byte_mode(flash))
+		return flash->set_4byte_mode(flash);
+
+	return 0;
+}
+#else
+static inline int spi_flash_use_4byte_mode(struct spi_flash *flash)
+{
+	return 0;
+}
+
+static inline int spi_flash_set_4byte_mode(struct spi_flash *flash)
+{
+	return 0;
+}
+#endif
+
+/* SPI flash MTD adapter init */
+int spi_flash_mtd_init(struct spi_flash *flash);
+
 /* Manufacturer-specific probe functions */
-struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_eon(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode);
-struct spi_flash *spi_fram_probe_ramtron(struct spi_slave *spi, u8 *idcode);
+int spi_flash_probe_spansion(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_atmel(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_eon(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_macronix(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_sst(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_stmicro(struct spi_flash *flash, u8 *idcode);
+int spi_flash_probe_winbond(struct spi_flash *flash, u8 *idcode);
+int spi_fram_probe_ramtron(struct spi_flash *flash, u8 *idcode);
diff --git a/drivers/mtd/spi/spi_flash_mtd.c b/drivers/mtd/spi/spi_flash_mtd.c
new file mode 100644
index 0000000000000000000000000000000000000000..815d3ad966e522480d3e22541097a1b114735018
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_mtd.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * MTD layer driver for SPI flash devices
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
+#include <spi_flash.h>
+
+static struct mtd_info sf_mtd_info;
+static char sf_mtd_name[8];
+
+static int spi_flash_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	instr->state = MTD_ERASING;
+
+	err = spi_flash_erase(flash, instr->addr, instr->len);
+	if (err) {
+		instr->state = MTD_ERASE_FAILED;
+		instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+		return -EIO;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+static int spi_flash_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	err = spi_flash_read(flash, from, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static int spi_flash_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	err = spi_flash_write(flash, to, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static void spi_flash_mtd_sync(struct mtd_info *mtd)
+{
+}
+
+static int spi_flash_mtd_number(void)
+{
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS
+	return CONFIG_SYS_MAX_FLASH_BANKS;
+#else
+	return 0;
+#endif
+}
+
+int spi_flash_mtd_init(struct spi_flash *flash)
+{
+	memset(&sf_mtd_info, 0, sizeof(sf_mtd_info));
+	sprintf(sf_mtd_name, "nor%d", spi_flash_mtd_number());
+
+	sf_mtd_info.name = sf_mtd_name;
+	sf_mtd_info.type = MTD_NORFLASH;
+	sf_mtd_info.flags = MTD_CAP_NORFLASH;
+	sf_mtd_info.writesize = 1;
+
+	sf_mtd_info.erase = spi_flash_mtd_erase;
+	sf_mtd_info.read = spi_flash_mtd_read;
+	sf_mtd_info.write = spi_flash_mtd_write;
+	sf_mtd_info.sync = spi_flash_mtd_sync;
+
+	sf_mtd_info.size = flash->size;
+	sf_mtd_info.priv = flash;
+
+	/* Only uniform flash devices for now */
+	sf_mtd_info.numeraseregions = 0;
+	sf_mtd_info.erasesize = flash->sector_size;
+
+	return add_mtd_device(&sf_mtd_info);
+}
diff --git a/drivers/mtd/spi/sst.c b/drivers/mtd/spi/sst.c
index 95f5490c350ac0f85287b518f1b2427286c30ee3..ba542ccb22bc7ee52bff5706ad654d1e95693ec6 100644
--- a/drivers/mtd/spi/sst.c
+++ b/drivers/mtd/spi/sst.c
@@ -39,11 +39,6 @@ struct sst_spi_flash_params {
 	const char *name;
 };
 
-struct sst_spi_flash {
-	struct spi_flash flash;
-	const struct sst_spi_flash_params *params;
-};
-
 static const struct sst_spi_flash_params sst_spi_flash_table[] = {
 	{
 		.idcode1 = 0x8d,
@@ -185,11 +180,9 @@ sst_write_wp(struct spi_flash *flash, u32 offset, size_t len, const void *buf)
 	return ret;
 }
 
-struct spi_flash *
-spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode)
+int spi_flash_probe_sst(struct spi_flash *flash, u8 *idcode)
 {
 	const struct sst_spi_flash_params *params;
-	struct sst_spi_flash *stm;
 	size_t i;
 
 	for (i = 0; i < ARRAY_SIZE(sst_spi_flash_table); ++i) {
@@ -200,25 +193,21 @@ spi_flash_probe_sst(struct spi_slave *spi, u8 *idcode)
 
 	if (i == ARRAY_SIZE(sst_spi_flash_table)) {
 		debug("SF: Unsupported SST ID %02x\n", idcode[1]);
-		return NULL;
+		return 0;
 	}
 
-	stm = spi_flash_alloc(struct sst_spi_flash, spi, params->name);
-	if (!stm) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
-	stm->params = params;
+	if (params->flags & SST_FEAT_WP)
+		flash->write = sst_write_wp;
 
-	if (stm->params->flags & SST_FEAT_WP)
-		stm->flash.write = sst_write_wp;
-	stm->flash.page_size = 256;
-	stm->flash.sector_size = 4096;
-	stm->flash.size = stm->flash.sector_size * params->nr_sectors;
+	flash->page_size = 256;
+	flash->sector_size = 4096;
+	flash->size = flash->sector_size * params->nr_sectors;
 
 	/* Flash powers up read-only, so clear BP# bits */
-	spi_flash_cmd_write_status(&stm->flash, 0);
+	spi_flash_cmd_write_status(flash, 0);
 
-	return &stm->flash;
+	return 1;
 }
diff --git a/drivers/mtd/spi/stmicro.c b/drivers/mtd/spi/stmicro.c
index 2a9972bd4ee519f97c67c7df3e6c0c4ac49fa49d..89adc54dbc40be60ebb73daa7cb084100f42eb09 100644
--- a/drivers/mtd/spi/stmicro.c
+++ b/drivers/mtd/spi/stmicro.c
@@ -142,10 +142,10 @@ static const struct stmicro_spi_flash_params stmicro_spi_flash_table[] = {
 	},
 };
 
-struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
+int spi_flash_probe_stmicro(struct spi_flash *flash, u8 * idcode)
 {
 	const struct stmicro_spi_flash_params *params;
-	struct spi_flash *flash;
+	struct spi_slave *spi = flash->spi;
 	unsigned int i;
 	u16 id;
 
@@ -153,13 +153,13 @@ struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
 		i = spi_flash_cmd(spi, CMD_M25PXX_RES,
 				  idcode, 4);
 		if (i)
-			return NULL;
+			return 0;
 		if ((idcode[3] & 0xf0) == 0x10) {
 			idcode[0] = 0x20;
 			idcode[1] = 0x20;
 			idcode[2] = idcode[3] + 1;
 		} else
-			return NULL;
+			return 0;
 	}
 
 	id = ((idcode[1] << 8) | idcode[2]);
@@ -173,18 +173,15 @@ struct spi_flash *spi_flash_probe_stmicro(struct spi_slave *spi, u8 * idcode)
 
 	if (i == ARRAY_SIZE(stmicro_spi_flash_table)) {
 		debug("SF: Unsupported STMicro ID %04x\n", id);
-		return NULL;
+		return 0;
 	}
 
-	flash = spi_flash_alloc_base(spi, params->name);
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	flash->page_size = 256;
 	flash->sector_size = 256 * params->pages_per_sector;
 	flash->size = flash->sector_size * params->nr_sectors;
 
-	return flash;
+	return 1;
 }
diff --git a/drivers/mtd/spi/winbond.c b/drivers/mtd/spi/winbond.c
index 27162091c5ac69e4cfe8af4fc7d4f4944391c0a5..c0899c1ad9a63da74e5b1fe605c775bb5ef0eb35 100644
--- a/drivers/mtd/spi/winbond.c
+++ b/drivers/mtd/spi/winbond.c
@@ -79,10 +79,9 @@ static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
 	},
 };
 
-struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
+int spi_flash_probe_winbond(struct spi_flash *flash, u8 *idcode)
 {
 	const struct winbond_spi_flash_params *params;
-	struct spi_flash *flash;
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(winbond_spi_flash_table); i++) {
@@ -94,18 +93,15 @@ struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
 	if (i == ARRAY_SIZE(winbond_spi_flash_table)) {
 		debug("SF: Unsupported Winbond ID %02x%02x\n",
 				idcode[1], idcode[2]);
-		return NULL;
+		return 0;
 	}
 
-	flash = spi_flash_alloc_base(spi, params->name);
-	if (!flash) {
-		debug("SF: Failed to allocate memory\n");
-		return NULL;
-	}
+	flash->priv = (void *)params;
+	flash->name = params->name;
 
 	flash->page_size = 256;
 	flash->sector_size = 4096;
 	flash->size = 4096 * 16 * params->nr_blocks;
 
-	return flash;
+	return 1;
 }
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 786a6567a5fc9ba5dbfc2c68262a789c5338a2ea..6ab6b3ce2c315a132519ec93f9193d34cd87aa17 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -51,6 +51,8 @@ COBJS-$(CONFIG_GRETH) += greth.o
 COBJS-$(CONFIG_INCA_IP_SWITCH) += inca-ip_sw.o
 COBJS-$(CONFIG_DRIVER_KS8695ETH) += ks8695eth.o
 COBJS-$(CONFIG_LAN91C96) += lan91c96.o
+COBJS-$(CONFIG_LANTIQ_DANUBE_ETOP) += lantiq_danube_etop.o
+COBJS-$(CONFIG_LANTIQ_VRX200_SWITCH) += lantiq_vrx200_switch.o
 COBJS-$(CONFIG_MACB) += macb.o
 COBJS-$(CONFIG_MCFFEC) += mcffec.o mcfmii.o
 COBJS-$(CONFIG_MPC5xxx_FEC) += mpc5xxx_fec.o
diff --git a/drivers/net/lantiq_danube_etop.c b/drivers/net/lantiq_danube_etop.c
new file mode 100644
index 0000000000000000000000000000000000000000..06cf26ba5d2585b7688893585ee0ee026b57a6a8
--- /dev/null
+++ b/drivers/net/lantiq_danube_etop.c
@@ -0,0 +1,411 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <switch.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/dma.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PPE_ETOP_MDIO_ACC_RA	(1 << 31)
+#define LTQ_PPE_ETOP_MDIO_CFG_UMM1	(1 << 2)
+#define LTQ_PPE_ETOP_MDIO_CFG_UMM0	(1 << 1)
+
+#define LTQ_PPE_ETOP_CFG_TCKINV1	(1 << 11)
+#define LTQ_PPE_ETOP_CFG_TCKINV0	(1 << 10)
+#define LTQ_PPE_ETOP_CFG_FEN1		(1 << 9)
+#define LTQ_PPE_ETOP_CFG_FEN0		(1 << 8)
+#define LTQ_PPE_ETOP_CFG_SEN1		(1 << 7)
+#define LTQ_PPE_ETOP_CFG_SEN0		(1 << 6)
+#define LTQ_PPE_ETOP_CFG_TURBO1		(1 << 5)
+#define LTQ_PPE_ETOP_CFG_REMII1		(1 << 4)
+#define LTQ_PPE_ETOP_CFG_OFF1		(1 << 3)
+#define LTQ_PPE_ETOP_CFG_TURBO0		(1 << 2)
+#define LTQ_PPE_ETOP_CFG_REMII0		(1 << 1)
+#define LTQ_PPE_ETOP_CFG_OFF0		(1 << 0)
+
+#define LTQ_PPE_ENET0_MAC_CFG_CGEN	(1 << 11)
+#define LTQ_PPE_ENET0_MAC_CFG_DUPLEX	(1 << 2)
+#define LTQ_PPE_ENET0_MAC_CFG_SPEED	(1 << 1)
+#define LTQ_PPE_ENET0_MAC_CFG_LINK	(1 << 0)
+
+#define LTQ_PPE_ENETS0_CFG_FTUC		(1 << 28)
+
+#define LTQ_ETH_RX_BUFFER_CNT		PKTBUFSRX
+#define LTQ_ETH_TX_BUFFER_CNT		8
+#define LTQ_ETH_RX_DATA_SIZE		PKTSIZE_ALIGN
+#define LTQ_ETH_IP_ALIGN		2
+
+#define LTQ_MDIO_DRV_NAME		"ltq-mdio"
+#define LTQ_ETH_DRV_NAME		"ltq-eth"
+
+struct ltq_ppe_etop_regs {
+	u32	mdio_cfg;		/* MDIO configuration */
+	u32	mdio_acc;		/* MDIO access */
+	u32	cfg;			/* ETOP configuration */
+	u32	ig_vlan_cos;		/* IG VLAN priority CoS mapping */
+	u32	ig_dscp_cos3;		/* IG DSCP CoS mapping 3 */
+	u32	ig_dscp_cos2;		/* IG DSCP CoS mapping 2 */
+	u32	ig_dscp_cos1;		/* IG DSCP CoS mapping 1 */
+	u32	ig_dscp_cos0;		/* IG DSCP CoS mapping 0 */
+	u32	ig_plen_ctrl;		/* IG frame length control */
+	u32	rsvd0[3];
+	u32	vpid;			/* VLAN protocol ID */
+};
+
+struct ltq_ppe_enet_regs {
+	u32	mac_cfg;		/* MAC configuration */
+	u32	rsvd0[3];
+	u32	ig_cfg;			/* Ingress configuration */
+	u32	ig_pgcnt;		/* Ingress buffer used page count */
+	u32	rsvd1;
+	u32	ig_buf_ctrl;		/* Ingress buffer backpressure ctrl */
+	u32	cos_cfg;		/* Classification configuration */
+	u32	ig_drop;		/* Total ingress drop frames */
+	u32	ig_err;			/* Total ingress error frames */
+	u32	mac_da0;		/* Ingress MAC address 0 */
+	u32	mac_da1;		/* Ingress MAC address 1 */
+	u32	rsvd2[22];
+	u32	pgcnt;			/* Page counter */
+	u32	rsvd3;
+	u32	hf_ctrl;		/* Half duplex control */
+	u32	tx_ctrl;		/* Transmit control */
+	u32	rsvd4;
+	u32	vlcos0;			/* VLAN insertion config CoS 0 */
+	u32	vlcos1;			/* VLAN insertion config CoS 1 */
+	u32	vlcos2;			/* VLAN insertion config CoS 2 */
+	u32	vlcos3;			/* VLAN insertion config CoS 3 */
+	u32	eg_col;			/* Total egress collision frames */
+	u32	eg_drop;		/* Total egress drop frames */
+};
+
+struct ltq_eth_priv {
+	struct ltq_dma_device dma_dev;
+	struct mii_dev *bus;
+	struct eth_device *dev;
+	int rx_num;
+	int tx_num;
+};
+
+struct ltq_mdio_access {
+	union {
+		struct {
+			unsigned ra:1;
+			unsigned rw:1;
+			unsigned rsvd:4;
+			unsigned phya:5;
+			unsigned rega:5;
+			unsigned phyd:16;
+		} reg;
+		u32 val;
+	};
+};
+
+static struct ltq_ppe_etop_regs *ltq_ppe_etop_regs =
+	(struct ltq_ppe_etop_regs *) CKSEG1ADDR(LTQ_PPE_ETOP_BASE);
+
+static struct ltq_ppe_enet_regs *ltq_ppe_enet0_regs =
+	(struct ltq_ppe_enet_regs *) CKSEG1ADDR(LTQ_PPE_ENET0_BASE);
+
+static inline int ltq_mdio_poll(void)
+{
+	struct ltq_mdio_access acc;
+	unsigned cnt = 10000;
+
+	while (likely(cnt--)) {
+		acc.val = ltq_readl(&ltq_ppe_etop_regs->mdio_acc);
+		if (!acc.reg.ra)
+			return 0;
+	}
+
+	return 1;
+}
+
+static int ltq_mdio_read(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.reg.ra = 1;
+	acc.reg.rw = 1;
+	acc.reg.phya = addr;
+	acc.reg.rega = regnum;
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	ltq_writel(&ltq_ppe_etop_regs->mdio_acc, acc.val);
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	acc.val = ltq_readl(&ltq_ppe_etop_regs->mdio_acc);
+
+	return acc.reg.phyd;
+}
+
+static int ltq_mdio_write(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum, u16 val)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.reg.ra = 1;
+	acc.reg.rw = 0;
+	acc.reg.phya = addr;
+	acc.reg.rega = regnum;
+	acc.reg.phyd = val;
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	ltq_writel(&ltq_ppe_etop_regs->mdio_acc, acc.val);
+
+	return 0;
+}
+
+static inline void ltq_eth_write_hwaddr(const struct eth_device *dev)
+{
+	u32 da0, da1;
+
+	da0 = (dev->enetaddr[0] << 24) + (dev->enetaddr[1] << 16) +
+		(dev->enetaddr[2] << 8) + dev->enetaddr[3];
+	da1 = (dev->enetaddr[4] << 24) + (dev->enetaddr[5] << 16);
+
+	ltq_writel(&ltq_ppe_enet0_regs->mac_da0, da0);
+	ltq_writel(&ltq_ppe_enet0_regs->mac_da1, da1);
+}
+
+static inline u8 *ltq_eth_rx_packet_align(int rx_num)
+{
+	u8 *packet = (u8 *) NetRxPackets[rx_num];
+
+	/*
+	 * IP header needs
+	 */
+	return packet + LTQ_ETH_IP_ALIGN;
+}
+
+static int ltq_eth_init(struct eth_device *dev, bd_t *bis)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	int i;
+
+	ltq_eth_write_hwaddr(dev);
+
+	for (i = 0; i < LTQ_ETH_RX_BUFFER_CNT; i++)
+		ltq_dma_rx_map(dma_dev, i, ltq_eth_rx_packet_align(i),
+			LTQ_ETH_RX_DATA_SIZE);
+
+	ltq_dma_enable(dma_dev);
+
+	priv->rx_num = 0;
+	priv->tx_num = 0;
+
+	return 0;
+}
+
+static void ltq_eth_halt(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+
+	ltq_dma_reset(dma_dev);
+}
+
+static int ltq_eth_send(struct eth_device *dev, void *packet, int length)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	int err;
+
+	/* Minimum payload length w/ CRC is 60 bytes */
+	if (length < 60)
+		length = 60;
+
+	err = ltq_dma_tx_map(dma_dev, priv->tx_num, packet, length, 10);
+	if (err) {
+		puts("NET: timeout on waiting for TX descriptor\n");
+		return -1;
+	}
+
+	priv->tx_num = (priv->tx_num + 1) % LTQ_ETH_TX_BUFFER_CNT;
+
+	return err;
+}
+
+static int ltq_eth_recv(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	u8 *packet;
+	int len;
+
+	if (!ltq_dma_rx_poll(dma_dev, priv->rx_num))
+		return 0;
+
+#if 0
+	printf("%s: rx_num %d\n", __func__, priv->rx_num);
+#endif
+
+	len = ltq_dma_rx_length(dma_dev, priv->rx_num);
+	packet = ltq_eth_rx_packet_align(priv->rx_num);
+
+#if 0
+	printf("%s: received: packet %p, len %u, rx_num %d\n",
+		__func__, packet, len, priv->rx_num);
+#endif
+
+	if (len)
+		NetReceive(packet, len);
+
+	ltq_dma_rx_map(dma_dev, priv->rx_num, packet,
+		LTQ_ETH_RX_DATA_SIZE);
+
+	priv->rx_num = (priv->rx_num + 1) % LTQ_ETH_RX_BUFFER_CNT;
+
+	return 0;
+}
+
+static void ltq_eth_hw_init(const struct ltq_eth_port_config *port)
+{
+	u32 data;
+
+	/* Power up ethernet subsystems */
+	ltq_pm_enable(LTQ_PM_ETH);
+
+	/* Reset ethernet subsystems */
+	ltq_reset_once(LTQ_RESET_ETH, 1);
+
+	/* Disable MDIO auto-detection */
+	ltq_clrbits(&ltq_ppe_etop_regs->mdio_cfg, LTQ_PPE_ETOP_MDIO_CFG_UMM1 |
+			LTQ_PPE_ETOP_MDIO_CFG_UMM0);
+
+	/* Enable CRC generation, Full Duplex, 100Mbps, Link up */
+	ltq_writel(&ltq_ppe_enet0_regs->mac_cfg, LTQ_PPE_ENET0_MAC_CFG_CGEN |
+			LTQ_PPE_ENET0_MAC_CFG_DUPLEX |
+			LTQ_PPE_ENET0_MAC_CFG_SPEED |
+			LTQ_PPE_ENET0_MAC_CFG_LINK);
+
+	/* Reset ETOP cfg and disable all */
+	data = LTQ_PPE_ETOP_CFG_OFF0 | LTQ_PPE_ETOP_CFG_OFF1;
+
+	/* Enable ENET0, enable store and fetch */
+	data &= ~LTQ_PPE_ETOP_CFG_OFF0;
+	data |= LTQ_PPE_ETOP_CFG_SEN0 | LTQ_PPE_ETOP_CFG_FEN0;
+
+	if (port->phy_if == PHY_INTERFACE_MODE_RMII)
+		data |= LTQ_PPE_ETOP_CFG_REMII0;
+	else
+		data &= ~LTQ_PPE_ETOP_CFG_REMII0;
+
+	ltq_writel(&ltq_ppe_etop_regs->cfg, data);
+
+	/* Set allowed packet length from 64 bytes to 1518 bytes */
+	ltq_writel(&ltq_ppe_etop_regs->ig_plen_ctrl, (64 << 16) | 1518);
+
+	/* Enable filter for unicast packets */
+	ltq_setbits(&ltq_ppe_enet0_regs->ig_cfg, LTQ_PPE_ENETS0_CFG_FTUC);
+}
+
+int ltq_eth_initialize(const struct ltq_eth_board_config *board_config)
+{
+	struct eth_device *dev;
+	struct mii_dev *bus;
+	struct ltq_eth_priv *priv;
+	struct ltq_dma_device *dma_dev;
+	const struct ltq_eth_port_config *port = &board_config->ports[0];
+	struct phy_device *phy;
+	struct switch_device *sw;
+	int ret;
+
+	ltq_dma_init();
+	ltq_eth_hw_init(port);
+
+	dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		return -1;
+
+	priv = calloc(1, sizeof(*priv));
+	if (!priv)
+		return -1;
+
+	bus = mdio_alloc();
+	if (!bus)
+		return -1;
+
+	sprintf(dev->name, LTQ_ETH_DRV_NAME);
+	dev->priv = priv;
+	dev->init = ltq_eth_init;
+	dev->halt = ltq_eth_halt;
+	dev->recv = ltq_eth_recv;
+	dev->send = ltq_eth_send;
+
+	sprintf(bus->name, LTQ_MDIO_DRV_NAME);
+	bus->read = ltq_mdio_read;
+	bus->write = ltq_mdio_write;
+	bus->priv = priv;
+
+	dma_dev = &priv->dma_dev;
+	dma_dev->port = 0;
+	dma_dev->rx_chan.chan_no = 6;
+	dma_dev->rx_chan.class = 3;
+	dma_dev->rx_chan.num_desc = LTQ_ETH_RX_BUFFER_CNT;
+	dma_dev->rx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->rx_burst_len = LTQ_DMA_BURST_2WORDS;
+	dma_dev->tx_chan.chan_no = 7;
+	dma_dev->tx_chan.class = 3;
+	dma_dev->tx_chan.num_desc = LTQ_ETH_TX_BUFFER_CNT;
+	dma_dev->tx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->tx_burst_len = LTQ_DMA_BURST_2WORDS;
+
+	priv->bus = bus;
+	priv->dev = dev;
+
+	ret = ltq_dma_register(dma_dev);
+	if (ret)
+		return ret;
+
+	ret = mdio_register(bus);
+	if (ret)
+		return ret;
+
+	ret = eth_register(dev);
+	if (ret)
+		return ret;
+
+	if (port->flags & LTQ_ETH_PORT_SWITCH) {
+		sw = switch_connect(bus);
+		if (!sw)
+			return -1;
+
+		switch_setup(sw);
+	}
+
+	if (port->flags & LTQ_ETH_PORT_PHY) {
+		phy = phy_connect(bus, port->phy_addr, dev, port->phy_if);
+		if (!phy)
+			return -1;
+
+		phy_config(phy);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/lantiq_vrx200_switch.c b/drivers/net/lantiq_vrx200_switch.c
new file mode 100644
index 0000000000000000000000000000000000000000..6ccd19b849adc9de4482d2435075edaed5e7edec
--- /dev/null
+++ b/drivers/net/lantiq_vrx200_switch.c
@@ -0,0 +1,676 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010-2011 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <linux/compiler.h>
+#include <asm/gpio.h>
+#include <asm/processor.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/dma.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/switch.h>
+
+#define LTQ_ETH_RX_BUFFER_CNT		PKTBUFSRX
+#define LTQ_ETH_TX_BUFFER_CNT		8
+#define LTQ_ETH_RX_DATA_SIZE		PKTSIZE_ALIGN
+#define LTQ_ETH_IP_ALIGN		2
+
+#define LTQ_MDIO_DRV_NAME		"ltq-mdio"
+#define LTQ_ETH_DRV_NAME		"ltq-eth"
+
+#define LTQ_ETHSW_MAX_GMAC		6
+#define LTQ_ETHSW_PMAC			6
+
+struct ltq_mdio_phy_addr_reg {
+	union {
+		struct {
+			unsigned rsvd:1;
+			unsigned lnkst:2;	/* Link status control */
+			unsigned speed:2;	/* Speed control */
+			unsigned fdup:2;	/* Full duplex control */
+			unsigned fcontx:2;	/* Flow control mode TX */
+			unsigned fconrx:2;	/* Flow control mode RX */
+			unsigned addr:5;	/* PHY address */
+		} bits;
+		u16 val;
+	};
+};
+
+enum ltq_mdio_phy_addr_lnkst {
+	LTQ_MDIO_PHY_ADDR_LNKST_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_LNKST_UP = 1,
+	LTQ_MDIO_PHY_ADDR_LNKST_DOWN = 2,
+};
+
+enum ltq_mdio_phy_addr_speed {
+	LTQ_MDIO_PHY_ADDR_SPEED_M10 = 0,
+	LTQ_MDIO_PHY_ADDR_SPEED_M100 = 1,
+	LTQ_MDIO_PHY_ADDR_SPEED_G1 = 2,
+	LTQ_MDIO_PHY_ADDR_SPEED_AUTO = 3,
+};
+
+enum ltq_mdio_phy_addr_fdup {
+	LTQ_MDIO_PHY_ADDR_FDUP_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_FDUP_ENABLE = 1,
+	LTQ_MDIO_PHY_ADDR_FDUP_DISABLE = 3,
+};
+
+enum ltq_mdio_phy_addr_fcon {
+	LTQ_MDIO_PHY_ADDR_FCON_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_FCON_ENABLE = 1,
+	LTQ_MDIO_PHY_ADDR_FCON_DISABLE = 3,
+};
+
+struct ltq_mii_mii_cfg_reg {
+	union {
+		struct {
+			unsigned res:1;		/* Hardware reset */
+			unsigned en:1;		/* xMII interface enable */
+			unsigned isol:1;	/* xMII interface isolate */
+			unsigned ldclkdis:1;	/* Link down clock disable */
+			unsigned rsvd:1;
+			unsigned crs:2;		/* CRS sensitivity config */
+			unsigned rgmii_ibs:1;	/* RGMII In Band status */
+			unsigned rmii:1;	/* RMII ref clock direction */
+			unsigned miirate:3;	/* xMII interface clock rate */
+			unsigned miimode:4;	/* xMII interface mode */
+		} bits;
+		u16 val;
+	};
+};
+
+enum ltq_mii_mii_cfg_miirate {
+	LTQ_MII_MII_CFG_MIIRATE_M2P5 = 0,
+	LTQ_MII_MII_CFG_MIIRATE_M25 = 1,
+	LTQ_MII_MII_CFG_MIIRATE_M125 = 2,
+	LTQ_MII_MII_CFG_MIIRATE_M50 = 3,
+	LTQ_MII_MII_CFG_MIIRATE_AUTO = 4,
+};
+
+enum ltq_mii_mii_cfg_miimode {
+	LTQ_MII_MII_CFG_MIIMODE_MIIP = 0,
+	LTQ_MII_MII_CFG_MIIMODE_MIIM = 1,
+	LTQ_MII_MII_CFG_MIIMODE_RMIIP = 2,
+	LTQ_MII_MII_CFG_MIIMODE_RMIIM = 3,
+	LTQ_MII_MII_CFG_MIIMODE_RGMII = 4,
+};
+
+struct ltq_eth_priv {
+	struct ltq_dma_device dma_dev;
+	struct mii_dev *bus;
+	struct eth_device *dev;
+	struct phy_device *phymap[LTQ_ETHSW_MAX_GMAC];
+	int rx_num;
+	int tx_num;
+};
+
+static struct vr9_switch_regs *switch_regs =
+	(struct vr9_switch_regs *) CKSEG1ADDR(LTQ_SWITCH_BASE);
+
+static inline void vr9_switch_sync(void)
+{
+	__asm__("sync");
+}
+
+static inline int vr9_switch_mdio_is_busy(void)
+{
+	u32 mdio_ctrl = ltq_readl(&switch_regs->mdio.mdio_ctrl);
+
+	return mdio_ctrl & MDIO_CTRL_MBUSY;
+}
+
+static inline void vr9_switch_mdio_poll(void)
+{
+	while (vr9_switch_mdio_is_busy())
+		cpu_relax();
+}
+
+static int vr9_switch_mdio_read(struct mii_dev *bus, int phyad, int devad,
+					int regad)
+{
+	u32 mdio_ctrl;
+	int retval;
+
+	mdio_ctrl = MDIO_CTRL_OP_READ |
+		((phyad << MDIO_CTRL_PHYAD_SHIFT) & MDIO_CTRL_PHYAD_MASK) |
+		(regad & MDIO_CTRL_REGAD_MASK);
+
+	vr9_switch_mdio_poll();
+	ltq_writel(&switch_regs->mdio.mdio_ctrl, mdio_ctrl);
+	vr9_switch_mdio_poll();
+	retval = ltq_readl(&switch_regs->mdio.mdio_read);
+
+	return retval;
+}
+
+static int vr9_switch_mdio_write(struct mii_dev *bus, int phyad, int devad,
+					int regad, u16 val)
+{
+	u32 mdio_ctrl;
+
+	mdio_ctrl = MDIO_CTRL_OP_WRITE |
+		((phyad << MDIO_CTRL_PHYAD_SHIFT) & MDIO_CTRL_PHYAD_MASK) |
+		(regad & MDIO_CTRL_REGAD_MASK);
+
+	vr9_switch_mdio_poll();
+	ltq_writel(&switch_regs->mdio.mdio_write, val);
+	ltq_writel(&switch_regs->mdio.mdio_ctrl, mdio_ctrl);
+
+	return 0;
+}
+
+static void ltq_eth_gmac_update(struct phy_device *phydev, int num)
+{
+	struct ltq_mdio_phy_addr_reg phy_addr_reg;
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+
+	phy_addr_reg.val = ltq_readl(to_mdio_phyaddr(switch_regs, num));
+
+	switch (num) {
+	case 0:
+	case 1:
+	case 5:
+		mii_cfg_reg.val = ltq_readl(to_mii_miicfg(switch_regs, num));
+		break;
+	default:
+		mii_cfg_reg.val = 0;
+		break;
+	}
+
+	phy_addr_reg.bits.addr = phydev->addr;
+
+	if (phydev->link)
+		phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_UP;
+	else
+		phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_DOWN;
+
+	switch (phydev->speed) {
+	case SPEED_1000:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_G1;
+		mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M125;
+		break;
+	case SPEED_100:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M100;
+		switch (mii_cfg_reg.bits.miimode) {
+		case LTQ_MII_MII_CFG_MIIMODE_RMIIM:
+		case LTQ_MII_MII_CFG_MIIMODE_RMIIP:
+			mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M50;
+			break;
+		default:
+			mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M25;
+			break;
+		}
+		break;
+	default:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M10;
+		mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M2P5;
+		break;
+	}
+
+	if (phydev->duplex == DUPLEX_FULL)
+		phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_ENABLE;
+	else
+		phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_DISABLE;
+
+	ltq_writel(to_mdio_phyaddr(switch_regs, num), phy_addr_reg.val);
+
+	switch (num) {
+	case 0:
+	case 1:
+	case 5:
+		ltq_writel(to_mii_miicfg(switch_regs, num), mii_cfg_reg.val);
+		break;
+	default:
+		break;
+	}
+}
+
+static inline u8 *ltq_eth_rx_packet_align(int rx_num)
+{
+	u8 *packet = (u8 *) NetRxPackets[rx_num];
+
+	/*
+	 * IP header needs
+	 */
+	return packet + LTQ_ETH_IP_ALIGN;
+}
+
+static int ltq_eth_init(struct eth_device *dev, bd_t * bis)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	struct phy_device *phydev;
+	int i;
+
+	for (i = 0; i < LTQ_ETHSW_MAX_GMAC; i++) {
+		phydev = priv->phymap[i];
+		if (!phydev)
+			continue;
+
+		phy_startup(phydev);
+		ltq_eth_gmac_update(phydev, i);
+	}
+
+	for (i = 0; i < LTQ_ETH_RX_BUFFER_CNT; i++)
+		ltq_dma_rx_map(dma_dev, i, ltq_eth_rx_packet_align(i),
+			LTQ_ETH_RX_DATA_SIZE);
+
+	ltq_dma_enable(dma_dev);
+
+	priv->rx_num = 0;
+	priv->tx_num = 0;
+
+	return 0;
+}
+
+static void ltq_eth_halt(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	struct phy_device *phydev;
+	int i;
+
+	ltq_dma_reset(dma_dev);
+
+	for (i = 0; i < LTQ_ETHSW_MAX_GMAC; i++) {
+		phydev = priv->phymap[i];
+		if (!phydev)
+			continue;
+
+		phy_shutdown(phydev);
+		phydev->link = 0;
+		ltq_eth_gmac_update(phydev, i);
+	}
+}
+
+static int ltq_eth_send(struct eth_device *dev, void *packet, int length)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+
+#if 0
+	printf("%s: packet %p, len %d\n", __func__, packet, length);
+#endif
+
+	ltq_dma_tx_map(dma_dev, priv->tx_num, packet, length, 10);
+	priv->tx_num = (priv->tx_num + 1) % LTQ_ETH_TX_BUFFER_CNT;
+
+	return 0;
+}
+
+static int ltq_eth_recv(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct ltq_dma_device *dma_dev = &priv->dma_dev;
+	u8 *packet;
+	int len;
+
+	if (!ltq_dma_rx_poll(dma_dev, priv->rx_num))
+		return 0;
+
+#if 0
+	printf("%s: rx_num %d\n", __func__, priv->rx_num);
+#endif
+
+	len = ltq_dma_rx_length(dma_dev, priv->rx_num);
+	packet = ltq_eth_rx_packet_align(priv->rx_num);
+
+#if 0
+	printf("%s: received: packet %p, len %u, rx_num %d\n",
+		__func__, packet, len, priv->rx_num);
+#endif
+
+	if (len)
+		NetReceive(packet, len);
+
+	ltq_dma_rx_map(dma_dev, priv->rx_num, packet,
+		LTQ_ETH_RX_DATA_SIZE);
+
+	priv->rx_num = (priv->rx_num + 1) % LTQ_ETH_RX_BUFFER_CNT;
+
+	return 0;
+}
+
+static void ltq_eth_gmac_init(int num)
+{
+	struct ltq_mdio_phy_addr_reg phy_addr_reg;
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+
+	/* Reset PHY status to link down */
+	phy_addr_reg.val = ltq_readl(to_mdio_phyaddr(switch_regs, num));
+	phy_addr_reg.bits.addr = num;
+	phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_DOWN;
+	phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M10;
+	phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_DISABLE;
+	ltq_writel(to_mdio_phyaddr(switch_regs, num), phy_addr_reg.val);
+
+	/* Reset and disable MII interface */
+	switch (num) {
+	case 0:
+	case 1:
+	case 5:
+		mii_cfg_reg.val = ltq_readl(to_mii_miicfg(switch_regs, num));
+		mii_cfg_reg.bits.en = 0;
+		mii_cfg_reg.bits.res = 1;
+		mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M2P5;
+		ltq_writel(to_mii_miicfg(switch_regs, num), mii_cfg_reg.val);
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * - enable frame checksum generation
+	 * - enable padding of short frames
+	 * - disable flow control
+	 */
+	ltq_writel(to_mac_ctrl(switch_regs, num, 0),
+		MAC_CTRL0_PADEN | MAC_CTRL0_FCS | MAC_CTRL0_FCON_NONE);
+
+	vr9_switch_sync();
+}
+
+static void ltq_eth_pmac_init(void)
+{
+	/*
+	 * WAR: buffer congestion:
+	 * - shorten preambel to 1 byte
+	 * - set TX IPG to 7 bytes
+	 */
+#if 1
+	ltq_writel(to_mac_ctrl(switch_regs, LTQ_ETHSW_PMAC, 1),
+		MAC_CTRL1_SHORTPRE | 7);
+#endif
+
+	/*
+	 * WAR: systematical concept weakness ACM bug
+	 * - set maximum number of used buffer segments to 254
+	 * - soft-reset BM FSQM
+	 */
+#if 1
+	ltq_writel(&switch_regs->bm.core.fsqm_gctrl, 253);
+	ltq_setbits(&switch_regs->bm.core.gctrl, BM_GCTRL_F_SRES);
+	ltq_clrbits(&switch_regs->bm.core.gctrl, BM_GCTRL_F_SRES);
+#endif
+
+	/*
+	 * WAR: switch MAC drop bug
+	 */
+#if 1
+	ltq_writel(to_pce_tbl_key(switch_regs, 0), 0xf);
+	ltq_writel(to_pce_tbl_value(switch_regs, 0), 0x40);
+	ltq_writel(&switch_regs->pce.core.tbl_addr, 0x3);
+	ltq_writel(&switch_regs->pce.core.tbl_ctrl, 0x902f);
+#endif
+
+	/*
+	 * Configure frame header control:
+	 * - enable flow control
+	 * - enable CRC check for packets from DMA to PMAC
+	 * - remove special tag from packets from PMAC to DMA
+	 * - add CRC for packets from DMA to PMAC
+	 */
+	ltq_writel(&switch_regs->pmac.hd_ctl, /*PMAC_HD_CTL_FC |*/
+		PMAC_HD_CTL_CCRC | PMAC_HD_CTL_RST | PMAC_HD_CTL_AC |
+		PMAC_HD_CTL_RC);
+
+#if 1
+	ltq_writel(&switch_regs->pmac.rx_ipg, 0x8b);
+#endif
+
+	/*
+	 * - enable frame checksum generation
+	 * - enable padding of short frames
+	 * - disable flow control
+	 */
+	ltq_writel(to_mac_ctrl(switch_regs, LTQ_ETHSW_PMAC, 0),
+		MAC_CTRL0_PADEN | MAC_CTRL0_FCS | MAC_CTRL0_FCON_NONE);
+
+	vr9_switch_sync();
+}
+
+static void ltq_eth_hw_init(void)
+{
+	int i;
+
+	/* Power up ethernet and switch subsystems */
+	ltq_pm_enable(LTQ_PM_ETH);
+
+	/* Reset ethernet and switch subsystems */
+#if 0
+	ltq_reset_once(LTQ_RESET_ETH, 10);
+#endif
+
+	/* Enable switch macro */
+	ltq_setbits(&switch_regs->mdio.glob_ctrl, MDIO_GLOB_CTRL_SE);
+
+	/* Disable MDIO auto-polling for all ports */
+	ltq_writel(&switch_regs->mdio.mdc_cfg_0, 0);
+
+	/*
+	 * Enable and set MDIO management clock to 2.5 MHz. This is the
+	 * maximum clock for FE PHYs.
+	 * Formula for clock is:
+	 *
+	 *      50 MHz
+	 * x = ----------- - 1
+	 *      2 * f_MDC
+	 */
+	ltq_writel(&switch_regs->mdio.mdc_cfg_1, MDIO_MDC_CFG1_RES |
+		MDIO_MDC_CFG1_MCEN | 5);
+
+	vr9_switch_sync();
+
+	/* Init MAC connected to CPU  */
+	ltq_eth_pmac_init();
+
+	/* Init MACs connected to external MII interfaces */
+	for (i = 0; i < LTQ_ETHSW_MAX_GMAC; i++)
+		ltq_eth_gmac_init(i);
+}
+
+static void ltq_eth_port_config(struct ltq_eth_priv *priv,
+					const struct ltq_eth_port_config *port)
+{
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+	struct phy_device *phydev;
+	int setup_gpio = 0;
+
+	switch (port->num) {
+	case 0:	/* xMII0 */
+	case 1:	/* xMII1 */
+		mii_cfg_reg.val = ltq_readl(to_mii_miicfg(switch_regs,
+					port->num));
+		mii_cfg_reg.bits.en = port->flags ? 1 : 0;
+
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+			if (port->flags & LTQ_ETH_PORT_PHY)
+				/* MII MAC mode, connected to external PHY */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_MIIM;
+			else
+				/* MII PHY mode, connected to external MAC */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_MIIP;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RMII:
+			if (port->flags & LTQ_ETH_PORT_PHY)
+				/* RMII MAC mode, connected to external PHY */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_RMIIM;
+			else
+				/* RMII PHY mode, connected to external MAC */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_RMIIP;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			/* RGMII MAC mode, connected to external PHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_RGMII;
+			setup_gpio = 1;
+
+			/* RGMII clock delays */
+			ltq_writel(to_mii_pcdu(switch_regs, port->num),
+				port->rgmii_rx_delay << PCDU_RXDLY_SHIFT |
+				port->rgmii_tx_delay);
+			break;
+		default:
+			break;
+		}
+
+		ltq_writel(to_mii_miicfg(switch_regs, port->num),
+			mii_cfg_reg.val);
+		break;
+	case 2:	/* internal GPHY0 */
+	case 3:	/* internal GPHY0 */
+	case 4:	/* internal GPHY1 */
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+		case PHY_INTERFACE_MODE_GMII:
+			setup_gpio = 1;
+			break;
+		default:
+			break;
+		}
+		break;
+	case 5:	/* internal GPHY1 or xMII2 */
+		mii_cfg_reg.val = ltq_readl(to_mii_miicfg(switch_regs,
+					port->num));
+		mii_cfg_reg.bits.en = port->flags ? 1 : 0;
+
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+			/* MII MAC mode, connected to internal GPHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_MIIM;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			/* RGMII MAC mode, connected to external PHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_RGMII;
+			setup_gpio = 1;
+
+			/* RGMII clock delays */
+			ltq_writel(to_mii_pcdu(switch_regs, port->num),
+				port->rgmii_rx_delay << PCDU_RXDLY_SHIFT |
+				port->rgmii_tx_delay);
+			break;
+		default:
+			break;
+		}
+
+		ltq_writel(to_mii_miicfg(switch_regs, port->num),
+			mii_cfg_reg.val);
+		break;
+	default:
+		break;
+	}
+
+	/* Setup GPIOs for MII with external PHYs/MACs */
+	if (setup_gpio) {
+		/* MII/MDIO */
+		gpio_set_altfunc(42, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR,
+					GPIO_DIR_OUT);
+		/* MII/MDC */
+		gpio_set_altfunc(43, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR,
+					GPIO_DIR_OUT);
+	}
+
+	/* Connect to internal/external PHYs */
+	if (port->flags & LTQ_ETH_PORT_PHY) {
+		phydev = phy_connect(priv->bus, port->phy_addr, priv->dev,
+					port->phy_if);
+		if (phydev)
+			phy_config(phydev);
+
+		priv->phymap[port->num] = phydev;
+	}
+}
+
+int ltq_eth_initialize(const struct ltq_eth_board_config *board_config)
+{
+	struct eth_device *dev;
+	struct mii_dev *bus;
+	struct ltq_eth_priv *priv;
+	struct ltq_dma_device *dma_dev;
+	int i, ret;
+
+	build_check_vr9_registers();
+
+	ltq_dma_init();
+	ltq_eth_hw_init();
+
+	dev = calloc(1, sizeof(struct eth_device));
+	if (!dev)
+		return -1;
+
+	priv = calloc(1, sizeof(struct ltq_eth_priv));
+	if (!priv)
+		return -1;
+
+	bus = mdio_alloc();
+	if (!bus)
+		return -1;
+
+	sprintf(dev->name, LTQ_ETH_DRV_NAME);
+	dev->priv = priv;
+	dev->init = ltq_eth_init;
+	dev->halt = ltq_eth_halt;
+	dev->recv = ltq_eth_recv;
+	dev->send = ltq_eth_send;
+
+	sprintf(bus->name, LTQ_MDIO_DRV_NAME);
+	bus->read = vr9_switch_mdio_read;
+	bus->write = vr9_switch_mdio_write;
+	bus->priv = priv;
+
+	dma_dev = &priv->dma_dev;
+	dma_dev->port = 0;
+	dma_dev->rx_chan.chan_no = 0;
+	dma_dev->rx_chan.class = 0;
+	dma_dev->rx_chan.num_desc = LTQ_ETH_RX_BUFFER_CNT;
+	dma_dev->rx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->rx_burst_len = LTQ_DMA_BURST_2WORDS;
+	dma_dev->tx_chan.chan_no = 1;
+	dma_dev->tx_chan.class = 0;
+	dma_dev->tx_chan.num_desc = LTQ_ETH_TX_BUFFER_CNT;
+	dma_dev->tx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->tx_burst_len = LTQ_DMA_BURST_2WORDS;
+
+	priv->bus = bus;
+	priv->dev = dev;
+
+	ret = ltq_dma_register(dma_dev);
+	if (ret)
+		return -1;
+
+	ret = mdio_register(bus);
+	if (ret)
+		return -1;
+
+	ret = eth_register(dev);
+	if (ret)
+		return -1;
+
+	for (i = 0; i < board_config->num_ports; i++)
+		ltq_eth_port_config(priv, &board_config->ports[i]);
+
+	return 0;
+}
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 5e90d7098db5b51ca09c303636c6fcab42d3593b..ad357391dc37995f888bf7c7c9de414168d4e3ec 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -34,6 +34,7 @@ COBJS-$(CONFIG_PHYLIB_10G) += generic_10g.o
 COBJS-$(CONFIG_PHY_ATHEROS) += atheros.o
 COBJS-$(CONFIG_PHY_BROADCOM) += broadcom.o
 COBJS-$(CONFIG_PHY_DAVICOM) += davicom.o
+COBJS-$(CONFIG_PHY_LANTIQ) += lantiq.o
 COBJS-$(CONFIG_PHY_LXT) += lxt.o
 COBJS-$(CONFIG_PHY_MARVELL) += marvell.o
 COBJS-$(CONFIG_PHY_MICREL) += micrel.o
diff --git a/drivers/net/phy/lantiq.c b/drivers/net/phy/lantiq.c
new file mode 100644
index 0000000000000000000000000000000000000000..f32b99e62aacb3caee1b8dbf40cf632ec34399e5
--- /dev/null
+++ b/drivers/net/phy/lantiq.c
@@ -0,0 +1,239 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <miiphy.h>
+
+#define ADVERTIZE_MPD		(1 << 10)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Update link status.
+ *
+ * Based on genphy_update_link in phylib.c
+ */
+static int ltq_phy_update_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	/*
+	 * If we already saw the link up, and it hasn't gone down, then
+	 * we don't need to wait for autoneg again
+	 */
+	if (phydev->link && mii_reg & BMSR_LSTATUS)
+		return 0;
+
+	if ((mii_reg & BMSR_ANEGCAPABLE) && !(mii_reg & BMSR_ANEGCOMPLETE)) {
+		phydev->link = 0;
+		return 0;
+	} else {
+		/* Read the link a second time to clear the latched state */
+		mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+		if (mii_reg & BMSR_LSTATUS)
+			phydev->link = 1;
+		else
+			phydev->link = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Update speed and duplex.
+ *
+ * Based on genphy_parse_link in phylib.c
+ */
+static int ltq_phy_parse_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	/* We're using autonegotiation */
+	if (mii_reg & BMSR_ANEGCAPABLE) {
+		u32 lpa = 0;
+		u32 gblpa = 0;
+
+		/* Check for gigabit capability */
+		if (mii_reg & BMSR_ERCAP) {
+			/* We want a list of states supported by
+			 * both PHYs in the link
+			 */
+			gblpa = phy_read(phydev, MDIO_DEVAD_NONE, MII_STAT1000);
+			gblpa &= phy_read(phydev,
+					MDIO_DEVAD_NONE, MII_CTRL1000) << 2;
+		}
+
+		/* Set the baseline so we only have to set them
+		 * if they're different
+		 */
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_HALF;
+
+		/* Check the gigabit fields */
+		if (gblpa & (PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD)) {
+			phydev->speed = SPEED_1000;
+
+			if (gblpa & PHY_1000BTSR_1000FD)
+				phydev->duplex = DUPLEX_FULL;
+
+			/* We're done! */
+			return 0;
+		}
+
+		lpa = phy_read(phydev, MDIO_DEVAD_NONE, MII_ADVERTISE);
+		lpa &= phy_read(phydev, MDIO_DEVAD_NONE, MII_LPA);
+
+		if (lpa & (LPA_100FULL | LPA_100HALF)) {
+			phydev->speed = SPEED_100;
+
+			if (lpa & LPA_100FULL)
+				phydev->duplex = DUPLEX_FULL;
+
+		} else if (lpa & LPA_10FULL)
+			phydev->duplex = DUPLEX_FULL;
+	} else {
+		u32 bmcr = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
+
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_HALF;
+
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
+
+		if (bmcr & BMCR_SPEED1000)
+			phydev->speed = SPEED_1000;
+		else if (bmcr & BMCR_SPEED100)
+			phydev->speed = SPEED_100;
+	}
+
+	return 0;
+}
+
+static int ltq_phy_config(struct phy_device *phydev)
+{
+	u16 val;
+
+	/* Advertise as Multi-port device */
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MII_CTRL1000);
+	val |= ADVERTIZE_MPD;
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, val);
+
+	genphy_config_aneg(phydev);
+
+	return 0;
+}
+
+static int ltq_phy_startup(struct phy_device *phydev)
+{
+	/*
+	 * Update PHY status immediately without any delays as genphy_startup
+	 * does because VRX200 switch needs to be configured dependent
+	 * on this information.
+	 */
+	ltq_phy_update_link(phydev);
+	ltq_phy_parse_link(phydev);
+
+	debug("ltq_phy: addr %d, link %d, speed %d, duplex %d\n",
+		phydev->addr, phydev->link, phydev->speed, phydev->duplex);
+
+	return 0;
+}
+
+static struct phy_driver xrx_11g_13_driver = {
+	.name = "Lantiq XWAY XRX PHY11G v1.3 and earlier",
+	.uid = 0x030260D0,
+	.mask = 0xFFFFFFF0,
+	.features = PHY_GBIT_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver xrx_11g_14_driver = {
+	.name = "Lantiq XWAY XRX PHY11G v1.4 and later",
+	.uid = 0xd565a408,
+	.mask = 0xFFFFFFF8,
+	.features = PHY_GBIT_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver xrx_22f_14_driver = {
+	.name = "Lantiq XWAY XRX PHY22F v1.4 and later",
+	.uid = 0xd565a418,
+	.mask = 0xFFFFFFF8,
+	.features = PHY_BASIC_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver pef7071_driver = {
+	.name = "Lantiq XWAY PEF7071",
+	.uid = 0xd565a400,
+	.mask = 0xFFFFFFF8,
+	.features = PHY_GBIT_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver xrx_genphy_driver = {
+	.name = "Generic PHY at Lantiq XWAY XRX switch",
+	.uid = 0,
+	.mask = 0,
+	.features = 0,
+	.config = genphy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+int phy_lantiq_init(void)
+{
+#ifdef CONFIG_NEEDS_MANUAL_RELOC
+	xrx_11g_13_driver.config = ltq_phy_config;
+	xrx_11g_13_driver.startup = ltq_phy_startup;
+	xrx_11g_13_driver.shutdown = genphy_shutdown;
+	xrx_11g_13_driver.name += gd->reloc_off;
+
+	xrx_11g_14_driver.config = ltq_phy_config;
+	xrx_11g_14_driver.startup = ltq_phy_startup;
+	xrx_11g_14_driver.shutdown = genphy_shutdown;
+	xrx_11g_14_driver.name += gd->reloc_off;
+
+	xrx_22f_14_driver.config = ltq_phy_config;
+	xrx_22f_14_driver.startup = ltq_phy_startup;
+	xrx_22f_14_driver.shutdown = genphy_shutdown;
+	xrx_22f_14_driver.name += gd->reloc_off;
+
+	pef7071_driver.config = ltq_phy_config;
+	pef7071_driver.startup = ltq_phy_startup;
+	pef7071_driver.shutdown = genphy_shutdown;
+	pef7071_driver.name += gd->reloc_off;
+
+	xrx_genphy_driver.config = genphy_config;
+	xrx_genphy_driver.startup = ltq_phy_startup;
+	xrx_genphy_driver.shutdown = genphy_shutdown;
+	xrx_genphy_driver.name += gd->reloc_off;
+#endif
+
+	phy_register(&xrx_11g_13_driver);
+	phy_register(&xrx_11g_14_driver);
+	phy_register(&xrx_22f_14_driver);
+	phy_register(&pef7071_driver);
+	phy_register(&xrx_genphy_driver);
+
+	return 0;
+}
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index d0ed7666ed98cbeccee364b38dc31f77cd6ce0d5..567fc508d0af03d3a5454d0aa90ba4c190f5d8c9 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -30,9 +30,10 @@
 #include <command.h>
 #include <miiphy.h>
 #include <phy.h>
-#include <errno.h>
 #include <linux/err.h>
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /* Generic PHY support and helper functions */
 
 /**
@@ -421,6 +422,16 @@ static LIST_HEAD(phy_drivers);
 
 int phy_init(void)
 {
+#ifdef CONFIG_NEEDS_MANUAL_RELOC
+	INIT_LIST_HEAD(&phy_drivers);
+
+	genphy_driver.config = genphy_config;
+	genphy_driver.startup = genphy_startup;
+	genphy_driver.shutdown = genphy_shutdown;
+
+	genphy_driver.name += gd->reloc_off;
+#endif
+
 #ifdef CONFIG_PHY_ATHEROS
 	phy_atheros_init();
 #endif
@@ -430,6 +441,9 @@ int phy_init(void)
 #ifdef CONFIG_PHY_DAVICOM
 	phy_davicom_init();
 #endif
+#ifdef CONFIG_PHY_LANTIQ
+	phy_lantiq_init();
+#endif
 #ifdef CONFIG_PHY_LXT
 	phy_lxt_init();
 #endif
diff --git a/drivers/net/switch/Makefile b/drivers/net/switch/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..3e3852fdd7c2ddba64ea47bd2959179bda6f3f2d
--- /dev/null
+++ b/drivers/net/switch/Makefile
@@ -0,0 +1,34 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libswitch.o
+
+COBJS-$(CONFIG_SWITCH_MULTI) += switch.o
+COBJS-$(CONFIG_SWITCH_PSB697X) += psb697x.o
+COBJS-$(CONFIG_SWITCH_ADM6996I) += adm6996i.o
+COBJS-$(CONFIG_SWITCH_AR8216) += ar8216.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/net/switch/adm6996i.c b/drivers/net/switch/adm6996i.c
new file mode 100644
index 0000000000000000000000000000000000000000..7a9e7cdee12fcd910fc46d69d83595cb5b25c455
--- /dev/null
+++ b/drivers/net/switch/adm6996i.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <switch.h>
+#include <miiphy.h>
+
+#define ADM6996I_CHIPID0	0x1020
+#define ADM6996I_CHIPID1	0x0007
+#define ADM6996I_PORT_COUNT	6
+
+#define ADM6996I_REG_P0BC	0x001	/* P0 Basic Control */
+#define ADM6996I_REG_P1BC	0x003	/* P1 Basic Control */
+#define ADM6996I_REG_P2BC	0x005	/* P2 Basic Control */
+#define ADM6996I_REG_P3BC	0x007	/* P3 Basic Control */
+#define ADM6996I_REG_P4BC	0x008	/* P4 Basic Control */
+#define ADM6996I_REG_P5BC	0x009	/* P5 Basic Control */
+
+#define ADM6996I_REG_P0EC	0x002	/* P0 Extended Control */
+#define ADM6996I_REG_P1EC	0x002	/* P1 Extended Control */
+#define ADM6996I_REG_P2EC	0x004	/* P2 Extended Control */
+#define ADM6996I_REG_P3EC	0x004	/* P3 Extended Control */
+#define ADM6996I_REG_P4EC	0x006	/* P4 Extended Control */
+#define ADM6996I_REG_P5EC	0x006	/* P5 Extended Control */
+
+#define ADM6996I_REG_SC4	0x012	/* System Control 4 */
+
+#define ADM6996I_REG_CI0	0xA0	/* Chip Identifier 0 */
+#define ADM6996I_REG_CI1	0xA1	/* Chip Identifier 1 */
+
+#define ADM6996I_REG_PXBC_DEFAULT	0x040F
+#define ADM6996I_REG_PXBC_CROSS_EE	(1 << 15)
+#define ADM6996I_REG_PXBC_PD		(1 << 5)
+
+#define ADM6996I_REG_SC4_DEFAULT	0x3600
+#define ADM6996I_REG_SC4_LED_ENABLE	(1 << 1)
+
+#define ADM6996I_REG_CI0_PC_MASK	0xFFF0
+#define ADM6996I_REG_CI0_VN_MASK	0xF
+#define ADM6996I_REG_CI1_PC_MASK	0xF
+
+
+static inline int adm6996i_mii_read(struct mii_dev *bus, u16 reg)
+{
+	int ret;
+
+	ret = bus->read(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE, reg & 0x1f);
+
+	return ret;
+}
+
+static inline int adm6996i_mii_write(struct mii_dev *bus, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = bus->write(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE,
+		reg & 0x1f, val);
+
+	return ret;
+}
+
+static int adm6996i_probe(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	u16 ci0, ci1;
+
+	ci0 = adm6996i_mii_read(bus, ADM6996I_REG_CI0);
+	ci1 = adm6996i_mii_read(bus, ADM6996I_REG_CI1);
+
+	ci0 &= ADM6996I_REG_CI0_PC_MASK;
+	ci1 &= ADM6996I_REG_CI1_PC_MASK;
+
+	if (ci0 == ADM6996I_CHIPID0 && ci1 == ADM6996I_CHIPID1)
+		return 0;
+
+	return 1;
+}
+
+static void adm6996i_setup(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	u16 val;
+
+	/*
+	 * Write default values (Port enable, 100 Mbps, Full Duplex,
+	 * Auto negotiation, Flow control) and enable crossover auto-detect
+	 */
+	val = ADM6996I_REG_PXBC_DEFAULT | ADM6996I_REG_PXBC_CROSS_EE;
+	adm6996i_mii_write(bus, ADM6996I_REG_P0BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P1BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P2BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P3BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P4BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P5BC, val);
+
+	val = ADM6996I_REG_SC4_DEFAULT | ADM6996I_REG_SC4_LED_ENABLE;
+	adm6996i_mii_write(bus, ADM6996I_REG_SC4, val);
+}
+
+static struct switch_driver adm6996i_drv = {
+	.name = "adm6996i",
+};
+
+void switch_adm6996i_init(void)
+{
+	/* For archs with manual relocation */
+	adm6996i_drv.probe = adm6996i_probe;
+	adm6996i_drv.setup = adm6996i_setup;
+
+	switch_driver_register(&adm6996i_drv);
+}
diff --git a/drivers/net/switch/ar8216.c b/drivers/net/switch/ar8216.c
new file mode 100644
index 0000000000000000000000000000000000000000..01ca7572ca9c8fd51e591799cd3586d88e276a13
--- /dev/null
+++ b/drivers/net/switch/ar8216.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2012 Luka Perkov <luka@openwrt.org>
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <switch.h>
+#include <netdev.h>
+
+#define BITS(_s, _n)  (((1UL << (_n)) - 1) << _s)
+
+#define AR8216_REG_CTRL			0x0000
+#define   AR8216_CTRL_REVISION		BITS(0, 8)
+#define   AR8216_CTRL_VERSION		BITS(8, 8)
+
+#define AR8216_PROBE_RETRIES		10
+
+static void split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
+{
+	regaddr >>= 1;
+	*r1 = regaddr & 0x1e;
+
+	regaddr >>= 5;
+	*r2 = regaddr & 0x7;
+
+	regaddr >>= 3;
+	*page = regaddr & 0x1ff;
+}
+
+static int ar8216_mii_read(struct mii_dev *bus, u32 reg)
+{
+	u16 r1, r2, page;
+	u16 lo, hi;
+
+	split_addr(reg, &r1, &r2, &page);
+
+	bus->write(bus, 0x18, MDIO_DEVAD_NONE, 0, page);
+	__udelay(1000);
+
+	lo = bus->read(bus, 0x10 | r2, MDIO_DEVAD_NONE, r1);
+	hi = bus->read(bus, 0x10 | r2, MDIO_DEVAD_NONE, r1 + 1);
+
+	return (hi << 16) | lo;
+}
+
+static void ar8216_mii_write(struct mii_dev *bus, u16 reg, u32 val)
+{
+	u16 r1, r2, r3;
+	u16 lo, hi;
+
+	split_addr((u32) reg, &r1, &r2, &r3);
+
+	bus->write(bus, 0x18, MDIO_DEVAD_NONE, 0, r3);
+	__udelay(1000);
+
+	lo = val & 0xffff;
+	hi = (u16) (val >> 16);
+	bus->write(bus, 0x10 | r2, MDIO_DEVAD_NONE, r1 + 1, hi);
+	bus->write(bus, 0x10 | r2, MDIO_DEVAD_NONE, r1, lo);
+}
+
+static int ar8216_probe(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	u32 val;
+	u16 id;
+
+	val = ar8216_mii_read(bus, AR8216_REG_CTRL);
+	if (val == ~0)
+		return 1;
+
+	id = val & (AR8216_CTRL_REVISION | AR8216_CTRL_VERSION);
+
+	switch (id) {
+		case 0x0101:
+			return 0;
+		default:
+			return 1;
+	}
+}
+
+static void ar8216_setup(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+
+	ar8216_mii_write(bus, 0x200, 0x200);
+	ar8216_mii_write(bus, 0x300, 0x200);
+	ar8216_mii_write(bus, 0x400, 0x200);
+	ar8216_mii_write(bus, 0x500, 0x200);
+	ar8216_mii_write(bus, 0x600, 0x7d);
+	ar8216_mii_write(bus, 0x38, 0xc000050e);
+	ar8216_mii_write(bus, 0x104, 0x4004);
+	ar8216_mii_write(bus, 0x60, 0xffffffff);
+	ar8216_mii_write(bus, 0x64, 0xaaaaaaaa);
+	ar8216_mii_write(bus, 0x68, 0x55555555);
+	ar8216_mii_write(bus, 0x6c, 0x0);
+	ar8216_mii_write(bus, 0x70, 0x41af);
+}
+
+static struct switch_driver ar8216_drv = {
+	.name = "ar8216",
+};
+
+void switch_ar8216_init(void)
+{
+	/* for archs with manual relocation */
+	ar8216_drv.probe = ar8216_probe;
+	ar8216_drv.setup = ar8216_setup;
+
+	switch_driver_register(&ar8216_drv);
+}
diff --git a/drivers/net/switch/psb697x.c b/drivers/net/switch/psb697x.c
new file mode 100644
index 0000000000000000000000000000000000000000..c8116e312afb9d620ef78014acdedc74131be95c
--- /dev/null
+++ b/drivers/net/switch/psb697x.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <switch.h>
+#include <miiphy.h>
+
+#define PSB697X_CHIPID1		0x2599
+#define PSB697X_PORT_COUNT	7
+
+#define PSB697X_PORT_BASE(p)	(p * 0x20)
+#define PSB697X_REG_PS(p)	(PSB697X_PORT_BASE(p) + 0x00)
+#define PSB697X_REG_PBC(p)	(PSB697X_PORT_BASE(p) + 0x01)
+#define PSB697X_REG_PEC(p)	(PSB697X_PORT_BASE(p) + 0x02)
+
+#define PSB697X_REG_SGC1	0x0E0	/* Switch Global Control Register 1 */
+#define PSB697X_REG_SGC2	0x0E1	/* Switch Global Control Register 2 */
+#define PSB697X_REG_CMH		0x0E2	/* CPU Port & Mirror Control */
+#define PSB697X_REG_MIICR	0x0F5	/* MII Port Control */
+#define PSB697X_REG_CI0		0x100	/* Chip Identifier 0 */
+#define PSB697X_REG_CI1		0x101	/* Chip Identifier 1 */
+#define PSB697X_REG_MIIAC	0x120	/* MII Indirect Access Control */
+#define PSB697X_REG_MIIWD	0x121	/* MII Indirect Write Data */
+#define PSB697X_REG_MIIRD	0x122	/* MII Indirect Read Data */
+
+#define PSB697X_REG_PORT_FLP	(1 << 2)	/* Force link up */
+#define PSB697X_REG_PORT_FLD	(1 << 1)	/* Force link down */
+
+#define PSB697X_REG_SGC2_SE	(1 << 15)	/* Switch enable */
+
+#define PSB697X_REG_CMH_CPN_MASK	0x7
+#define PSB697X_REG_CMH_CPN_SHIFT	5
+
+
+static inline int psb697x_mii_read(struct mii_dev *bus, u16 reg)
+{
+	int ret;
+
+	ret = bus->read(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE, reg & 0x1f);
+
+	return ret;
+}
+
+static inline int psb697x_mii_write(struct mii_dev *bus, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = bus->write(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE,
+		reg & 0x1f, val);
+
+	return ret;
+}
+
+static int psb697x_probe(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	int ci1;
+
+	ci1 = psb697x_mii_read(bus, PSB697X_REG_CI1);
+
+	if (ci1 == PSB697X_CHIPID1)
+		return 0;
+
+	return 1;
+}
+
+static void psb697x_setup(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	int i, state;
+
+	/* Enable switch */
+	psb697x_mii_write(bus, PSB697X_REG_SGC2, PSB697X_REG_SGC2_SE);
+
+	/*
+	 * Force 100 Mbps as default value for CPU ports 5 and 6 to get
+	 * full speed.
+	 */
+	psb697x_mii_write(bus, PSB697X_REG_MIICR, 0x0773);
+
+	for (i = 0; i < PSB697X_PORT_COUNT; i++) {
+		state = dev->port_mask & (1 << i);
+
+		/*
+		 * Software workaround from Errata Sheet:
+		 * Force link down and reset internal PHY, keep that state
+		 * for all unconnected ports and disable force link down
+		 * for all connected ports
+		 */
+		psb697x_mii_write(bus, PSB697X_REG_PBC(i),
+			PSB697X_REG_PORT_FLD);
+
+		if (i == dev->cpu_port)
+			/* Force link up for CPU port */
+			psb697x_mii_write(bus, PSB697X_REG_PBC(i),
+				PSB697X_REG_PORT_FLP);
+		else if (state)
+			/* Disable force link down for active LAN ports */
+			psb697x_mii_write(bus, PSB697X_REG_PBC(i), 0);
+	}
+}
+
+static struct switch_driver psb697x_drv = {
+	.name = "psb697x",
+};
+
+void switch_psb697x_init(void)
+{
+	/* For archs with manual relocation */
+	psb697x_drv.probe = psb697x_probe;
+	psb697x_drv.setup = psb697x_setup;
+
+	switch_driver_register(&psb697x_drv);
+}
diff --git a/drivers/net/switch/switch.c b/drivers/net/switch/switch.c
new file mode 100644
index 0000000000000000000000000000000000000000..021d40c52e92f3b235be61b8b868972079f08cbc
--- /dev/null
+++ b/drivers/net/switch/switch.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <switch.h>
+
+static struct list_head switch_drivers;
+static struct list_head switch_devices;
+
+void switch_init(void)
+{
+	INIT_LIST_HEAD(&switch_drivers);
+	INIT_LIST_HEAD(&switch_devices);
+
+#if defined(CONFIG_SWITCH_PSB697X)
+	switch_psb697x_init();
+#endif
+#if defined(CONFIG_SWITCH_ADM6996I)
+	switch_adm6996i_init();
+#endif
+#if defined(CONFIG_SWITCH_AR8216)
+	switch_ar8216_init();
+#endif
+
+	board_switch_init();
+}
+
+void switch_driver_register(struct switch_driver *drv)
+{
+	INIT_LIST_HEAD(&drv->list);
+	list_add_tail(&drv->list, &switch_drivers);
+}
+
+int switch_device_register(struct switch_device *dev)
+{
+	struct switch_driver *drv;
+
+	/* Add switch device only, if an adequate driver is registered */
+	list_for_each_entry(drv, &switch_drivers, list) {
+		if (!strcmp(drv->name, dev->name)) {
+			dev->drv = drv;
+
+			INIT_LIST_HEAD(&dev->list);
+			list_add_tail(&dev->list, &switch_devices);
+
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+struct switch_device *switch_connect(struct mii_dev *bus)
+{
+	struct switch_device *sw;
+	int err;
+
+	list_for_each_entry(sw, &switch_devices, list) {
+		sw->bus = bus;
+
+		err = sw->drv->probe(sw);
+		if (!err)
+			return sw;
+	}
+
+	return NULL;
+}
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index fbc4e97e983fd2bbd8085acdcf71e04fe34743f3..3a585a335a8946091a927d159e7c48ab8780f061 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -40,6 +40,7 @@ COBJS-$(CONFIG_SYS_NS16550_SERIAL) += serial_ns16550.o
 COBJS-$(CONFIG_IMX_SERIAL) += serial_imx.o
 COBJS-$(CONFIG_IXP_SERIAL) += serial_ixp.o
 COBJS-$(CONFIG_KS8695_SERIAL) += serial_ks8695.o
+COBJS-$(CONFIG_LANTIQ_SERIAL) += serial_lantiq.o
 COBJS-$(CONFIG_MAX3100_SERIAL) += serial_max3100.o
 COBJS-$(CONFIG_MXC_UART) += serial_mxc.o
 COBJS-$(CONFIG_PL010_SERIAL) += serial_pl01x.o
diff --git a/drivers/serial/serial_lantiq.c b/drivers/serial/serial_lantiq.c
new file mode 100644
index 0000000000000000000000000000000000000000..6696fca89c6505dadefebbad842fa6b9f20e9df0
--- /dev/null
+++ b/drivers/serial/serial_lantiq.c
@@ -0,0 +1,264 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <serial.h>
+#include <asm/errno.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#if CONFIG_CONSOLE_ASC == 0
+#define LTQ_ASC_BASE			LTQ_ASC0_BASE
+#else
+#define LTQ_ASC_BASE			LTQ_ASC1_BASE
+#endif
+
+#define LTQ_ASC_ID_TXFS_SHIFT		24
+#define LTQ_ASC_ID_TXFS_MASK		(0x3F << LTQ_ASC_ID_TXFS_SHIFT)
+#define LTQ_ASC_ID_RXFS_SHIFT		16
+#define LTQ_ASC_ID_RXFS_MASK		(0x3F << LTQ_ASC_ID_RXFS_SHIFT)
+
+#define LTQ_ASC_MCON_R			(1 << 15)
+#define LTQ_ASC_MCON_FDE		(1 << 9)
+
+#define LTQ_ASC_WHBSTATE_SETREN		(1 << 1)
+#define LTQ_ASC_WHBSTATE_CLRREN		(1 << 0)
+
+#define LTQ_ASC_RXFCON_RXFITL_SHIFT	8
+#define LTQ_ASC_RXFCON_RXFITL_MASK	(0x3F << LTQ_ASC_RXFCON_RXFITL_SHIFT)
+#define LTQ_ASC_RXFCON_RXFITL_RXFFLU	(1 << 1)
+#define LTQ_ASC_RXFCON_RXFITL_RXFEN	(1 << 0)
+
+#define LTQ_ASC_TXFCON_TXFITL_SHIFT	8
+#define LTQ_ASC_TXFCON_TXFITL_MASK	(0x3F << LTQ_ASC_TXFCON_TXFITL_SHIFT)
+#define LTQ_ASC_TXFCON_TXFITL_TXFFLU	(1 << 1)
+#define LTQ_ASC_TXFCON_TXFITL_TXFEN	(1 << 0)
+
+#define LTQ_ASC_FSTAT_TXFREE_SHIFT	24
+#define LTQ_ASC_FSTAT_TXFREE_MASK	(0x3F << LTQ_ASC_FSTAT_TXFREE_SHIFT)
+#define LTQ_ASC_FSTAT_RXFREE_SHIFT	16
+#define LTQ_ASC_FSTAT_RXFREE_MASK	(0x3F << LTQ_ASC_FSTAT_RXFREE_SHIFT)
+#define LTQ_ASC_FSTAT_TXFFL_SHIFT	8
+#define LTQ_ASC_FSTAT_TXFFL_MASK	(0x3F << LTQ_ASC_FSTAT_TXFFL_SHIFT)
+#define LTQ_ASC_FSTAT_RXFFL_MASK	0x3F
+
+#ifdef __BIG_ENDIAN
+#define LTQ_ASC_RBUF_OFFSET		3
+#define LTQ_ASC_TBUF_OFFSET		3
+#else
+#define LTQ_ASC_RBUF_OFFSET		0
+#define LTQ_ASC_TBUF_OFFSET		0
+#endif
+
+struct ltq_asc_regs {
+	u32	clc;
+	u32	pisel;
+	u32	id;
+	u32	rsvd0;
+	u32	mcon;
+	u32	state;
+	u32	whbstate;
+	u32	rsvd1;
+	u8	tbuf[4];
+	u8	rbuf[4];
+	u32	rsvd2[2];
+	u32	abcon;
+	u32	abstat;
+	u32	whbabcon;
+	u32	whbabstat;
+	u32	rxfcon;
+	u32	txfcon;
+	u32	fstat;
+	u32	rsvd3;
+	u32	bg;
+	u32	bg_timer;
+	u32	fdv;
+	u32	pmw;
+	u32	modcon;
+	u32	modstat;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct ltq_asc_regs *ltq_asc_regs =
+	(struct ltq_asc_regs *) CKSEG1ADDR(LTQ_ASC_BASE);
+
+static int ltq_serial_init(void)
+{
+	/* Set clock divider for normal run mode to 1 and enable module */
+	ltq_writel(&ltq_asc_regs->clc, 0x100);
+
+	/* Reset MCON register */
+	ltq_writel(&ltq_asc_regs->mcon, 0);
+
+	/* Use Port A as receiver input */
+	ltq_writel(&ltq_asc_regs->pisel, 0);
+
+	/* Enable and flush RX/TX FIFOs */
+	ltq_setbits(&ltq_asc_regs->rxfcon,
+		LTQ_ASC_RXFCON_RXFITL_RXFFLU | LTQ_ASC_RXFCON_RXFITL_RXFEN);
+	ltq_setbits(&ltq_asc_regs->txfcon,
+		LTQ_ASC_TXFCON_TXFITL_TXFFLU | LTQ_ASC_TXFCON_TXFITL_TXFEN);
+
+	serial_setbrg();
+
+	/* Disable error flags, enable receiver */
+	ltq_writel(&ltq_asc_regs->whbstate, LTQ_ASC_WHBSTATE_SETREN);
+
+	return 0;
+}
+
+/*
+ *             fdv       asc_clk
+ * Baudrate = ----- * -------------
+ *             512    16 * (bg + 1)
+ */
+static void ltq_serial_calc_br_fdv(unsigned long asc_clk,
+					unsigned long baudrate, u16 *fdv,
+					u16 *bg)
+{
+	const u32 c = asc_clk / (16 * 512);
+	u32 diff1, diff2;
+	u32 bg_calc, br_calc, i;
+
+	diff1 = baudrate;
+	for (i = 512; i > 0; i--) {
+		/* Calc bg for current fdv value */
+		bg_calc = i * c / baudrate;
+
+		/* Impossible baudrate */
+		if (!bg_calc)
+			return;
+
+		/*
+		 * Calc diff to target baudrate dependent on current
+		 * bg and fdv values
+		 */
+		br_calc = i * c / bg_calc;
+		if (br_calc > baudrate)
+			diff2 = br_calc - baudrate;
+		else
+			diff2 = baudrate - br_calc;
+
+		/* Perfect values found */
+		if (diff2 == 0) {
+			*fdv = i;
+			*bg = bg_calc - 1;
+			return;
+		}
+
+		if (diff2 < diff1) {
+			*fdv = i;
+			*bg = bg_calc - 1;
+			diff1 = diff2;
+		}
+	}
+}
+
+static void ltq_serial_setbrg(void)
+{
+	unsigned long asc_clk, baudrate;
+	u16 bg = 0;
+	u16 fdv = 511;
+
+	/* ASC clock is same as FPI clock with CLC.RMS = 1 */
+	asc_clk = ltq_get_bus_clock();
+	baudrate = gd->baudrate;
+
+	/* Calculate FDV and BG values */
+	ltq_serial_calc_br_fdv(asc_clk, baudrate, &fdv, &bg);
+
+	/* Disable baudrate generator */
+	ltq_clrbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_R);
+
+	/* Enable fractional divider */
+	ltq_setbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_FDE);
+
+	/* Set fdv and bg values */
+	ltq_writel(&ltq_asc_regs->fdv, fdv);
+	ltq_writel(&ltq_asc_regs->bg, bg);
+
+	/* Enable baudrate generator */
+	ltq_setbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_R);
+}
+
+static unsigned int ltq_serial_tx_free(void)
+{
+	unsigned int txfree;
+
+	txfree = (ltq_readl(&ltq_asc_regs->fstat) &
+			LTQ_ASC_FSTAT_TXFREE_MASK) >>
+			LTQ_ASC_FSTAT_TXFREE_SHIFT;
+
+	return txfree;
+}
+
+static unsigned int ltq_serial_rx_fill(void)
+{
+	unsigned int rxffl;
+
+	rxffl = ltq_readl(&ltq_asc_regs->fstat) & LTQ_ASC_FSTAT_RXFFL_MASK;
+
+	return rxffl;
+}
+
+static void ltq_serial_tx(const char c)
+{
+	ltq_writeb(&ltq_asc_regs->tbuf[LTQ_ASC_TBUF_OFFSET], c);
+}
+
+static u8 ltq_serial_rx(void)
+{
+	return ltq_readb(&ltq_asc_regs->rbuf[LTQ_ASC_RBUF_OFFSET]);
+}
+
+static void ltq_serial_putc(const char c)
+{
+	if (c == '\n')
+		ltq_serial_putc('\r');
+
+	while (!ltq_serial_tx_free())
+		;
+
+	ltq_serial_tx(c);
+}
+
+static int ltq_serial_getc(void)
+{
+	while (!ltq_serial_rx_fill())
+		;
+
+	return ltq_serial_rx();
+}
+
+static int ltq_serial_tstc(void)
+{
+	return (0 != ltq_serial_rx_fill());
+}
+
+static struct serial_device ltq_serial_drv = {
+	.name	= "ixp_serial",
+	.start	= ltq_serial_init,
+	.stop	= NULL,
+	.setbrg	= ltq_serial_setbrg,
+	.putc	= ltq_serial_putc,
+	.puts	= default_serial_puts,
+	.getc	= ltq_serial_getc,
+	.tstc	= ltq_serial_tstc,
+};
+
+void ixp_serial_initialize(void)
+{
+	serial_register(&ltq_serial_drv);
+}
+
+__weak struct serial_device *default_serial_console(void)
+{
+	return &ltq_serial_drv;
+}
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index d08609effe1ace437a87c06a9dd66744d7a3a642..6e572f1aa73010c48ceb26fb628aa747f306697d 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -41,6 +41,7 @@ COBJS-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 COBJS-$(CONFIG_EXYNOS_SPI) += exynos_spi.o
 COBJS-$(CONFIG_ICH_SPI) +=  ich.o
 COBJS-$(CONFIG_KIRKWOOD_SPI) += kirkwood_spi.o
+COBJS-$(CONFIG_LANTIQ_SPI) += lantiq_spi.o
 COBJS-$(CONFIG_MPC52XX_SPI) += mpc52xx_spi.o
 COBJS-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
 COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
diff --git a/drivers/spi/lantiq_spi.c b/drivers/spi/lantiq_spi.c
new file mode 100644
index 0000000000000000000000000000000000000000..f9c45af7eddcfca7c418c4b1d2e8933aa45e61f8
--- /dev/null
+++ b/drivers/spi/lantiq_spi.c
@@ -0,0 +1,667 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_SPI_CLC_RMC_SHIFT		8
+#define LTQ_SPI_CLC_RMC_MASK		(0xFF << LTQ_SPI_CLC_RMC_SHIFT)
+#define LTQ_SPI_CLC_DISS		(1 << 1)
+#define LTQ_SPI_CLC_DISR		1
+
+#define LTQ_SPI_ID_TXFS_SHIFT		24
+#define LTQ_SPI_ID_TXFS_MASK		(0x3F << LTQ_SPI_ID_TXFS_SHIFT)
+#define LTQ_SPI_ID_RXFS_SHIFT		16
+#define LTQ_SPI_ID_RXFS_MASK		(0x3F << LTQ_SPI_ID_RXFS_SHIFT)
+
+#define LTQ_SPI_CON_ENBV		(1 << 22)
+#define LTQ_SPI_CON_BM_SHIFT		16
+#define LTQ_SPI_CON_BM_MASK		(0x1F << LTQ_SPI_CON_BM_SHIFT)
+#define LTQ_SPI_CON_IDLE		(1 << 23)
+#define LTQ_SPI_CON_RUEN		(1 << 12)
+#define LTQ_SPI_CON_AEN			(1 << 10)
+#define LTQ_SPI_CON_REN			(1 << 9)
+#define LTQ_SPI_CON_TEN			(1 << 8)
+#define LTQ_SPI_CON_LB			(1 << 7)
+#define LTQ_SPI_CON_PO			(1 << 6)
+#define LTQ_SPI_CON_PH			(1 << 5)
+#define LTQ_SPI_CON_HB			(1 << 4)
+#define LTQ_SPI_CON_RXOFF		(1 << 1)
+#define LTQ_SPI_CON_TXOFF		1
+
+#define LTQ_SPI_STAT_RXBV_SHIFT		28
+#define LTQ_SPI_STAT_RXBV_MASK		(0x7 << LTQ_SPI_STAT_RXBV_SHIFT)
+#define LTQ_SPI_STAT_BSY		(1 << 13)
+
+#define LTQ_SPI_WHBSTATE_SETMS		(1 << 3)
+#define LTQ_SPI_WHBSTATE_CLRMS		(1 << 2)
+#define LTQ_SPI_WHBSTATE_SETEN		(1 << 1)
+#define LTQ_SPI_WHBSTATE_CLREN		1
+#define LTQ_SPI_WHBSTATE_CLR_ERRORS	0x0F50
+
+#define LTQ_SPI_TXFCON_TXFLU		(1 << 1)
+#define LTQ_SPI_TXFCON_TXFEN		1
+
+#define LTQ_SPI_RXFCON_RXFLU		(1 << 1)
+#define LTQ_SPI_RXFCON_RXFEN		1
+
+#define LTQ_SPI_FSTAT_RXFFL_MASK	0x3f
+#define LTQ_SPI_FSTAT_TXFFL_SHIFT	8
+#define LTQ_SPI_FSTAT_TXFFL_MASK	(0x3f << LTQ_SPI_FSTAT_TXFFL_SHIFT)
+
+#define LTQ_SPI_RXREQ_RXCNT_MASK	0xFFFF
+#define LTQ_SPI_RXCNT_TODO_MASK		0xFFFF
+
+#define LTQ_SPI_GPIO_DIN		16
+#define LTQ_SPI_GPIO_DOUT		17
+#define LTQ_SPI_GPIO_CLK		18
+
+struct ltq_spi_regs {
+	__be32	clc;		/* Clock control */
+	__be32	pisel;		/* Port input select */
+	__be32	id;		/* Identification */
+	__be32	rsvd0;
+	__be32	con;		/* Control */
+	__be32	stat;		/* Status */
+	__be32	whbstate;	/* Write HW modified state */
+	__be32	rsvd1;
+	__be32	tb;		/* Transmit buffer */
+	__be32	rb;		/* Receive buffer */
+	__be32	rsvd2[2];
+	__be32	rxfcon;		/* Recevie FIFO control */
+	__be32	txfcon;		/* Transmit FIFO control */
+	__be32	fstat;		/* FIFO status */
+	__be32	rsvd3;
+	__be32	brt;		/* Baudrate timer */
+	__be32	brstat;		/* Baudrate timer status */
+	__be32	rsvd4[6];
+	__be32	sfcon;		/* Serial frame control */
+	__be32	sfstat;		/* Serial frame status */
+	__be32	rsvd5[2];
+	__be32	gpocon;		/* General purpose output control */
+	__be32	gpostat;	/* General purpose output status */
+	__be32	fgpo;		/* Force general purpose output */
+	__be32	rsvd6;
+	__be32	rxreq;		/* Receive request */
+	__be32	rxcnt;		/* Receive count */
+	__be32	rsvd7[25];
+	__be32	dmacon;		/* DMA control */
+	__be32	rsvd8;
+	__be32	irnen;		/* Interrupt node enable */
+	__be32	irnicr;		/* Interrupt node interrupt capture */
+	__be32	irncr;		/* Interrupt node control */
+};
+
+struct ltq_spi_drv_data {
+	struct ltq_spi_regs __iomem *regs;
+
+	struct spi_slave slave;
+	unsigned int max_hz;
+	unsigned int mode;
+	unsigned int tx_todo;
+	unsigned int rx_todo;
+	unsigned int rx_req;
+	unsigned int bits_per_word;
+	unsigned int speed_hz;
+	const u8 *tx;
+	u8 *rx;
+	int status;
+};
+
+static struct ltq_spi_drv_data *to_ltq_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct ltq_spi_drv_data, slave);
+}
+
+#ifdef CONFIG_SPL_BUILD
+/*
+ * We do not have or want malloc in a SPI flash SPL.
+ * Neither we have to support multiple SPI slaves. Thus we put the
+ * SPI slave context in BSS for SPL builds.
+ */
+static struct ltq_spi_drv_data ltq_spi_slave;
+
+static struct ltq_spi_drv_data *ltq_spi_slave_alloc(unsigned int bus,
+							unsigned int cs)
+{
+	ltq_spi_slave.slave.bus = bus;
+	ltq_spi_slave.slave.cs = cs;
+
+	return &ltq_spi_slave;
+}
+
+static void ltq_spi_slave_free(struct spi_slave *slave)
+{
+}
+#else
+static struct ltq_spi_drv_data *ltq_spi_slave_alloc(unsigned int bus,
+							unsigned int cs)
+{
+	return spi_alloc_slave(struct ltq_spi_drv_data, bus, cs);
+}
+
+static void ltq_spi_slave_free(struct spi_slave *slave)
+{
+	struct ltq_spi_drv_data *drv;
+
+	if (slave) {
+		drv = to_ltq_spi_slave(slave);
+		free(drv);
+	}
+}
+#endif
+
+static unsigned int tx_fifo_size(struct ltq_spi_drv_data *drv)
+{
+	u32 id = ltq_readl(&drv->regs->id);
+
+	return (id & LTQ_SPI_ID_TXFS_MASK) >> LTQ_SPI_ID_TXFS_SHIFT;
+}
+
+static unsigned int rx_fifo_size(struct ltq_spi_drv_data *drv)
+{
+	u32 id = ltq_readl(&drv->regs->id);
+
+	return (id & LTQ_SPI_ID_RXFS_MASK) >> LTQ_SPI_ID_RXFS_SHIFT;
+}
+
+static unsigned int tx_fifo_level(struct ltq_spi_drv_data *drv)
+{
+	u32 fstat = ltq_readl(&drv->regs->fstat);
+
+	return (fstat & LTQ_SPI_FSTAT_TXFFL_MASK) >> LTQ_SPI_FSTAT_TXFFL_SHIFT;
+}
+
+static unsigned int rx_fifo_level(struct ltq_spi_drv_data *drv)
+{
+	u32 fstat = ltq_readl(&drv->regs->fstat);
+
+	return fstat & LTQ_SPI_FSTAT_RXFFL_MASK;
+}
+
+static unsigned int tx_fifo_free(struct ltq_spi_drv_data *drv)
+{
+	return tx_fifo_size(drv) - tx_fifo_level(drv);
+}
+
+static void hw_power_on(struct ltq_spi_drv_data *drv)
+{
+	u32 clc;
+
+	/* Power-up mdule */
+	ltq_pm_enable(LTQ_PM_SPI);
+
+	/*
+	 * Set clock divider for run mode to 1 to
+	 * run at same frequency as FPI bus
+	 */
+	clc = (1 << LTQ_SPI_CLC_RMC_SHIFT);
+	ltq_writel(&drv->regs->clc, clc);
+}
+
+static void hw_reset_fifos(struct ltq_spi_drv_data *drv)
+{
+	u32 val;
+
+	val = LTQ_SPI_TXFCON_TXFEN | LTQ_SPI_TXFCON_TXFLU;
+	ltq_writel(&drv->regs->txfcon, val);
+
+	val = LTQ_SPI_RXFCON_RXFEN | LTQ_SPI_RXFCON_RXFLU;
+	ltq_writel(&drv->regs->rxfcon, val);
+}
+
+static int hw_is_busy(struct ltq_spi_drv_data *drv)
+{
+	u32 stat = ltq_readl(&drv->regs->stat);
+
+	return stat & LTQ_SPI_STAT_BSY;
+}
+
+static void hw_enter_config_mode(struct ltq_spi_drv_data *drv)
+{
+	ltq_writel(&drv->regs->whbstate, LTQ_SPI_WHBSTATE_CLREN);
+}
+
+static void hw_enter_active_mode(struct ltq_spi_drv_data *drv)
+{
+	ltq_writel(&drv->regs->whbstate, LTQ_SPI_WHBSTATE_SETEN);
+}
+
+static void hw_setup_speed_hz(struct ltq_spi_drv_data *drv,
+				unsigned int max_speed_hz)
+{
+	unsigned int spi_hz, speed_hz, brt;
+
+	/*
+	 * SPI module clock is derived from FPI bus clock dependent on
+	 * divider value in CLC.RMS which is always set to 1.
+	 *
+	 *                 f_SPI
+	 * baudrate = --------------
+	 *             2 * (BR + 1)
+	 */
+	spi_hz = ltq_get_bus_clock() / 2;
+
+	/* TODO: optimize baudrate calculation */
+	for (brt = 0; brt < 0xFFFF; brt++) {
+		speed_hz = spi_hz / (brt + 1);
+		if (speed_hz <= max_speed_hz)
+			break;
+	}
+
+	ltq_writel(&drv->regs->brt, brt);
+}
+
+static void hw_setup_bits_per_word(struct ltq_spi_drv_data *drv,
+					unsigned int bits_per_word)
+{
+	u32 bm;
+
+	/* CON.BM value = bits_per_word - 1 */
+	bm = (bits_per_word - 1) << LTQ_SPI_CON_BM_SHIFT;
+
+	ltq_clrsetbits(&drv->regs->con, LTQ_SPI_CON_BM_MASK, bm);
+}
+
+static void hw_setup_clock_mode(struct ltq_spi_drv_data *drv, unsigned int mode)
+{
+	u32 con_set = 0, con_clr = 0;
+
+	/*
+	 * SPI mode mapping in CON register:
+	 * Mode CPOL CPHA CON.PO CON.PH
+	 *  0    0    0      0      1
+	 *  1    0    1      0      0
+	 *  2    1    0      1      1
+	 *  3    1    1      1      0
+	 */
+	if (mode & SPI_CPHA)
+		con_clr |= LTQ_SPI_CON_PH;
+	else
+		con_set |= LTQ_SPI_CON_PH;
+
+	if (mode & SPI_CPOL)
+		con_set |= LTQ_SPI_CON_PO | LTQ_SPI_CON_IDLE;
+	else
+		con_clr |= LTQ_SPI_CON_PO | LTQ_SPI_CON_IDLE;
+
+	/* Set heading control */
+	if (mode & SPI_LSB_FIRST)
+		con_clr |= LTQ_SPI_CON_HB;
+	else
+		con_set |= LTQ_SPI_CON_HB;
+
+	/* Set loopback mode */
+	if (mode & SPI_LOOP)
+		con_set |= LTQ_SPI_CON_LB;
+	else
+		con_clr |= LTQ_SPI_CON_LB;
+
+	ltq_clrsetbits(&drv->regs->con, con_clr, con_set);
+}
+
+static void hw_set_rxtx(struct ltq_spi_drv_data *drv)
+{
+	u32 con;
+
+	/* Configure transmitter and receiver */
+	con = ltq_readl(&drv->regs->con);
+	if (drv->tx)
+		con &= ~LTQ_SPI_CON_TXOFF;
+	else
+		con |= LTQ_SPI_CON_TXOFF;
+
+	if (drv->rx)
+		con &= ~LTQ_SPI_CON_RXOFF;
+	else
+		con |= LTQ_SPI_CON_RXOFF;
+
+	ltq_writel(&drv->regs->con, con);
+}
+
+static void hw_init(struct ltq_spi_drv_data *drv)
+{
+	hw_power_on(drv);
+
+	/* Put controller into config mode */
+	hw_enter_config_mode(drv);
+
+	/* Disable all interrupts */
+	ltq_writel(&drv->regs->irnen, 0);
+
+	/* Clear error flags */
+	ltq_clrsetbits(&drv->regs->whbstate, 0, LTQ_SPI_WHBSTATE_CLR_ERRORS);
+
+	/* Enable error checking, disable TX/RX */
+	ltq_writel(&drv->regs->con, LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
+			LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN | LTQ_SPI_CON_TXOFF |
+			LTQ_SPI_CON_RXOFF);
+
+	/* Setup default SPI mode */
+	drv->bits_per_word = 8;
+	drv->speed_hz = 0;
+	hw_setup_bits_per_word(drv, drv->bits_per_word);
+	hw_setup_clock_mode(drv, SPI_MODE_0);
+
+	/* Enable master mode and clear error flags */
+	ltq_writel(&drv->regs->whbstate, LTQ_SPI_WHBSTATE_SETMS |
+			LTQ_SPI_WHBSTATE_CLR_ERRORS);
+
+	/* Reset GPIO/CS registers */
+	ltq_writel(&drv->regs->gpocon, 0);
+	ltq_writel(&drv->regs->fgpo, 0xFF00);
+
+	/* Enable and flush FIFOs */
+	hw_reset_fifos(drv);
+
+	/* SPI/DIN input */
+	gpio_set_altfunc(16, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* SPI/DOUT output */
+	gpio_set_altfunc(17, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* SPI/CLK output */
+	gpio_set_altfunc(18, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+}
+
+static void tx_fifo_write(struct ltq_spi_drv_data *drv)
+{
+	const u8 *tx8;
+	const u16 *tx16;
+	const u32 *tx32;
+	u32 data;
+	unsigned int tx_free = tx_fifo_free(drv);
+
+	while (drv->tx_todo && tx_free) {
+		switch (drv->bits_per_word) {
+		case 8:
+			tx8 = drv->tx;
+			data = *tx8;
+			drv->tx_todo--;
+			drv->tx++;
+			break;
+		case 16:
+			tx16 = (u16 *) drv->tx;
+			data = *tx16;
+			drv->tx_todo -= 2;
+			drv->tx += 2;
+			break;
+		case 32:
+			tx32 = (u32 *) drv->tx;
+			data = *tx32;
+			drv->tx_todo -= 4;
+			drv->tx += 4;
+			break;
+		default:
+			return;
+		}
+
+		ltq_writel(&drv->regs->tb, data);
+		tx_free--;
+	}
+}
+
+static void rx_fifo_read_full_duplex(struct ltq_spi_drv_data *drv)
+{
+	u8 *rx8;
+	u16 *rx16;
+	u32 *rx32;
+	u32 data;
+	unsigned int rx_fill = rx_fifo_level(drv);
+
+	while (rx_fill) {
+		data = ltq_readl(&drv->regs->rb);
+
+		switch (drv->bits_per_word) {
+		case 8:
+			rx8 = drv->rx;
+			*rx8 = data;
+			drv->rx_todo--;
+			drv->rx++;
+			break;
+		case 16:
+			rx16 = (u16 *) drv->rx;
+			*rx16 = data;
+			drv->rx_todo -= 2;
+			drv->rx += 2;
+			break;
+		case 32:
+			rx32 = (u32 *) drv->rx;
+			*rx32 = data;
+			drv->rx_todo -= 4;
+			drv->rx += 4;
+			break;
+		default:
+			return;
+		}
+
+		rx_fill--;
+	}
+}
+
+static void rx_fifo_read_half_duplex(struct ltq_spi_drv_data *drv)
+{
+	u32 data, *rx32;
+	u8 *rx8;
+	unsigned int rxbv, shift;
+	unsigned int rx_fill = rx_fifo_level(drv);
+
+	/*
+	 * In RX-only mode the bits per word value is ignored by HW. A value
+	 * of 32 is used instead. Thus all 4 bytes per FIFO must be read.
+	 * If remaining RX bytes are less than 4, the FIFO must be read
+	 * differently. The amount of received and valid bytes is indicated
+	 * by STAT.RXBV register value.
+	 */
+	while (rx_fill) {
+		if (drv->rx_todo < 4) {
+			rxbv = (ltq_readl(&drv->regs->stat) &
+				LTQ_SPI_STAT_RXBV_MASK) >>
+				LTQ_SPI_STAT_RXBV_SHIFT;
+			data = ltq_readl(&drv->regs->rb);
+
+			shift = (rxbv - 1) * 8;
+			rx8 = drv->rx;
+
+			while (rxbv) {
+				*rx8++ = (data >> shift) & 0xFF;
+				rxbv--;
+				shift -= 8;
+				drv->rx_todo--;
+				drv->rx++;
+
+				if (drv->rx_req)
+					drv->rx_req --;
+			}
+		} else {
+			data = ltq_readl(&drv->regs->rb);
+			rx32 = (u32 *) drv->rx;
+
+			*rx32++ = data;
+			drv->rx_todo -= 4;
+			drv->rx += 4;
+
+			if (drv->rx_req >= 4)
+				drv->rx_req -= 4;
+		}
+		rx_fill--;
+	}
+}
+
+static void rx_request(struct ltq_spi_drv_data *drv)
+{
+	unsigned int rxreq, rxreq_max;
+
+	if (drv->rx_req)
+		return;
+
+	/*
+	 * To avoid receive overflows at high clocks it is better to request
+	 * only the amount of bytes that fits into all FIFOs. This value
+	 * depends on the FIFO size implemented in hardware.
+	 */
+	rxreq = drv->rx_todo;
+	rxreq_max = rx_fifo_size(drv) * 4;
+	if (rxreq > rxreq_max)
+		rxreq = rxreq_max;
+
+	drv->rx_req = rxreq;
+	ltq_writel(&drv->regs->rxreq, rxreq);
+}
+
+void spi_init(void)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	struct ltq_spi_drv_data *drv;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	drv = ltq_spi_slave_alloc(bus, cs);
+	if (!drv)
+		return NULL;
+
+	drv->regs = (struct ltq_spi_regs *) CKSEG1ADDR(LTQ_SPI_BASE);
+
+	hw_init(drv);
+
+	drv->max_hz = max_hz;
+	drv->mode = mode;
+
+	return &drv->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	ltq_spi_slave_free(slave);
+}
+
+static int ltq_spi_wait_ready(struct ltq_spi_drv_data *drv)
+{
+	const unsigned long timeout = 20000;
+	unsigned long timebase;
+
+	timebase = get_timer(0);
+
+	do {
+		WATCHDOG_RESET();
+
+		if (!hw_is_busy(drv))
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ltq_spi_drv_data *drv = to_ltq_spi_slave(slave);
+	int ret;
+
+	ret = ltq_spi_wait_ready(drv);
+	if (ret) {
+		debug("cannot claim bus\n");
+		return ret;
+	}
+
+	hw_enter_config_mode(drv);
+	hw_setup_clock_mode(drv, drv->mode);
+	hw_setup_speed_hz(drv, drv->max_hz);
+	hw_setup_bits_per_word(drv, drv->bits_per_word);
+	hw_enter_active_mode(drv);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	struct ltq_spi_drv_data *drv = to_ltq_spi_slave(slave);
+
+	hw_enter_config_mode(drv);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
+{
+
+	struct ltq_spi_drv_data *drv = to_ltq_spi_slave(slave);
+	int ret = 0;
+
+	if (bitlen % 8)
+		return 1;
+
+	if (!bitlen) {
+		ret = 0;
+		goto done;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	drv->tx = dout;
+	drv->tx_todo = 0;
+	drv->rx = din;
+	drv->rx_todo = 0;
+	hw_set_rxtx(drv);
+
+	if (drv->tx) {
+		drv->tx_todo = bitlen / 8;
+
+		tx_fifo_write(drv);
+	}
+
+	if (drv->rx) {
+		drv->rx_todo = bitlen / 8;
+
+		if (!drv->tx)
+			rx_request(drv);
+	}
+
+	for (;;) {
+		if (drv->tx) {
+			if (drv->rx && drv->rx_todo)
+				rx_fifo_read_full_duplex(drv);
+
+			if (drv->tx_todo)
+				tx_fifo_write(drv);
+			else
+				goto done;
+		} else if (drv->rx) {
+			if (drv->rx_todo) {
+				rx_fifo_read_half_duplex(drv);
+
+				if (drv->rx_todo)
+					rx_request(drv);
+				else
+					goto done;
+			} else {
+				goto done;
+			}
+		}
+	}
+
+done:
+	ret = ltq_spi_wait_ready(drv);
+
+	drv->rx = NULL;
+	drv->tx = NULL;
+	hw_set_rxtx(drv);
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
diff --git a/include/configs/easy50712.h b/include/configs/easy50712.h
new file mode 100644
index 0000000000000000000000000000000000000000..7b70404dbc92e2d8d4e0d5aecb4ab77bed6cb2f1
--- /dev/null
+++ b/include/configs/easy50712.h
@@ -0,0 +1,80 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"EASY50712"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Lantiq EASY50712 Danube Reference Board"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL		/* Have an AT45DB321D serial flash */
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_NOR_FLASH	/* Build NOR flash SPL */
+
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+/* Switch devices */
+#define CONFIG_SWITCH_MULTI
+#define CONFIG_SWITCH_ADM6996I
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		2
+#define CONFIG_ENV_SPI_MAX_HZ		20000000
+#define CONFIG_ENV_SPI_MODE		0
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#elif defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(128 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY Danube */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_NOR					\
+	"update-uboot-nor=run load-uboot-norspl-lzo write-uboot-nor\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_NOR
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/easy80920.h b/include/configs/easy80920.h
new file mode 100644
index 0000000000000000000000000000000000000000..3800a283acc9e0aec800f44b9ab1219e15cd9b39
--- /dev/null
+++ b/include/configs/easy80920.h
@@ -0,0 +1,93 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"EASY80920"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Lantiq EASY80920 VRX200 Family Board"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Have a MX29LV620 serial flash */
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+
+#define CONFIG_LTQ_SUPPORT_SPL_NOR_FLASH	/* Build NOR flash SPL */
+
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(384 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#elif defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#elif defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_NOR					\
+	"update-uboot-nor=run load-uboot-norspl-lzo write-uboot-nor\0"
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_NOR	\
+	CONFIG_ENV_UPDATE_UBOOT_SF
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/isdn_sip_gw.h b/include/configs/isdn_sip_gw.h
new file mode 100644
index 0000000000000000000000000000000000000000..da19932ba25bd0addbeeaa4479a72804e59e2bf8
--- /dev/null
+++ b/include/configs/isdn_sip_gw.h
@@ -0,0 +1,103 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"SPHISDNSIPGW"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Sphairon ISDN SIP Gateway"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SSIO_SHIFT_REGS	2
+#define CONFIG_LTQ_SSIO_EDGE_FALLING
+#define CONFIG_LTQ_SSIO_GPHY1_MODE	0x3
+#define CONFIG_LTQ_SSIO_GPHY2_MODE	0x3
+#define CONFIG_LTQ_SSIO_INIT_VALUE	0xff03
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Supports MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_SPANSION	/* Supports SF25FL256S serial flash */
+#define CONFIG_SPI_FLASH_EON		/* Supports EN25QH256 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_MODE
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=spi0.4,nand0=nand-xway"
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(512 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(256 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=spi0.4:512k(uboot_fix),256k(uboot_cfg)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+#define CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/sl2510.h b/include/configs/sl2510.h
new file mode 100644
index 0000000000000000000000000000000000000000..7ddfe628fab97a9f577c868e9d2de199ba03f16e
--- /dev/null
+++ b/include/configs/sl2510.h
@@ -0,0 +1,95 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"SPHSL2510"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Sphairon Speedlink 2510 Modem"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Supports MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_SPANSION	/* Supports SF25FL256S serial flash */
+#define CONFIG_SPI_FLASH_EON		/* Supports EN25QH256 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_MODE
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=spi0.4"
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(128 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=spi0.4:256k(uboot_fix),128k(uboot_cfg)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+#define CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/sl550x.h b/include/configs/sl550x.h
new file mode 100644
index 0000000000000000000000000000000000000000..1a04f64cf73645317b34afe52aafa83fd7e80ef7
--- /dev/null
+++ b/include/configs/sl550x.h
@@ -0,0 +1,103 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"SPHSL550X"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Sphairon Speedlink 550x IAD"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SSIO_SHIFT_REGS	1
+#define CONFIG_LTQ_SSIO_EDGE_FALLING
+#define CONFIG_LTQ_SSIO_GPHY1_MODE	0x3
+#define CONFIG_LTQ_SSIO_GPHY2_MODE	0x3
+#define CONFIG_LTQ_SSIO_INIT_VALUE	0x0
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Supports MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_SPANSION	/* Supports SF25FL256S serial flash */
+#define CONFIG_SPI_FLASH_EON		/* Supports EN25QH256 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_MODE
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=spi0.4,nand0=nand-xway"
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(512 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(256 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=spi0.4:512k(uboot_fix),256k(uboot_cfg)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+#define CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/sl6501.h b/include/configs/sl6501.h
new file mode 100644
index 0000000000000000000000000000000000000000..fa6fb3e3582bb0986c434865e45068ff7f5a2227
--- /dev/null
+++ b/include/configs/sl6501.h
@@ -0,0 +1,103 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2012-2014 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"SPHSL6501"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Sphairon Speedlink 6501 IAD"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SSIO_SHIFT_REGS	1
+#define CONFIG_LTQ_SSIO_EDGE_FALLING
+#define CONFIG_LTQ_SSIO_GPHY1_MODE	0x3
+#define CONFIG_LTQ_SSIO_GPHY2_MODE	0x3
+#define CONFIG_LTQ_SSIO_INIT_VALUE	0x0
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Supports MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_SPANSION	/* Supports SF25FL256S serial flash */
+#define CONFIG_SPI_FLASH_EON		/* Supports EN25QH256 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_MODE
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=spi0.4,nand0=nand-xway"
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(512 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(256 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=spi0.4:512k(uboot_fix),256k(uboot_cfg)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+#define CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/sphairon_env.h b/include/configs/sphairon_env.h
new file mode 100644
index 0000000000000000000000000000000000000000..405d66a95a05ba0bdb761f34a1c72a1026858d10
--- /dev/null
+++ b/include/configs/sphairon_env.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef _SPHAIRON_ENV_H_
+#define _SPHAIRON_ENV_H_
+
+/* Enable library for Sphairon extensions */
+#define CONFIG_LIB_SPHAIRON
+#define CONFIG_LZMA
+
+#define CONFIG_CMD_GPIO
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_MISC
+#define CONFIG_CMD_ECHO
+#define CONFIG_CMD_MTDPARTS
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_CMD_SPI
+#endif
+
+#define CONFIG_CMD_UBI
+#define CONFIG_RBTREE
+
+#define CONFIG_FIT
+
+/* Image booting */
+#define CONFIG_SPHAIRON_SCAN_STEP_SIZE		0x2000
+#define CONFIG_BOOTDELAY			3
+
+/* Environment */
+#define CONFIG_IPADDR				192.168.100.1
+#define CONFIG_SERVERIP				192.168.100.100
+#define CONFIG_ETHADDR				00:1c:28:ff:00:10
+#define CONFIG_LOADADDR				CONFIG_SYS_LOAD_ADDR
+
+#define CONFIG_ENV_SPHAIRON_GENERIC
+
+#endif /* _SPHAIRON_ENV_H_ */
diff --git a/include/configs/tl7201.h b/include/configs/tl7201.h
new file mode 100644
index 0000000000000000000000000000000000000000..74d0d1020dfb0c2213772cfbf062fc747ca2eef4
--- /dev/null
+++ b/include/configs/tl7201.h
@@ -0,0 +1,76 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"SPHTL7201"
+#define CONFIG_BOARD_NAME	"Sphairon Turbolink 7201"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_SPHAIRON_TL7201
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+/* Switch devices */
+#define CONFIG_SWITCH_MULTI
+#define CONFIG_SWITCH_PSB697X
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=bank0"
+
+/* Environment */
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(128 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=bank0:256k(uboot_fix),128k(uboot_cfg)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY Danube */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/vrx_g1.h b/include/configs/vrx_g1.h
new file mode 100644
index 0000000000000000000000000000000000000000..642f26f2bb7908cdca8cc5b2621f2c2cecde64a5
--- /dev/null
+++ b/include/configs/vrx_g1.h
@@ -0,0 +1,97 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MACH_TYPE	"SPHVRXG1"
+#define CONFIG_IDENT_STRING	" "CONFIG_MACH_TYPE
+#define CONFIG_BOARD_NAME	"Sphairon VRX288 G1 Board"
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Supports MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_MODE
+
+#define CONFIG_LTQ_SUPPORT_NAND_FLASH
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+#define CONFIG_LTQ_SPL_CONSOLE
+
+#define CONFIG_SYS_DRAM_PROBE
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+#define MTDIDS_DEFAULT			"nor0=spi0.4,nand0=ifx_nand"
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(256 * 1024)
+
+#define MTDPARTS_DEFAULT		\
+	"mtdparts=spi0.4:256k(uboot_fix),256k(uboot_cfg),256k(uboot_update)"
+#else
+#define CONFIG_ENV_IS_NOWHERE
+
+#define MTDPARTS_DEFAULT		"mtdparts="
+#endif
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Swap FW for each GPHY due to wrong MII lines on G1 board */
+#define CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=run load-uboot-sfspl-lzo write-uboot-sf\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/phy.h b/include/phy.h
index 58ca2730c84eac4419b384954f3f8b2c50a503cf..3ce2333ef87e739612be568337f700a7c96a2da5 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -223,6 +223,7 @@ int gen10g_discover_mmds(struct phy_device *phydev);
 int phy_atheros_init(void);
 int phy_broadcom_init(void);
 int phy_davicom_init(void);
+int phy_lantiq_init(void);
 int phy_lxt_init(void);
 int phy_marvell_init(void);
 int phy_micrel_init(void);
diff --git a/include/sas/boot.h b/include/sas/boot.h
new file mode 100644
index 0000000000000000000000000000000000000000..14ccb9885fa13cc2e9238780dd391f93fbd0148d
--- /dev/null
+++ b/include/sas/boot.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_BOOT_H__
+#define __SAS_BOOT_H__
+
+#include <linux/list.h>
+#include <sas/image.h>
+#include <sas/flashlayout.h>
+
+enum sas_boot_state
+{
+	SAS_BOOT_NOTAVAILABLE = 0,
+	SAS_BOOT_AVAILABLE,
+	SAS_BOOT_ACTIVEWORKING,
+	SAS_BOOT_INACTIVEWORKING,
+	SAS_BOOT_NOTWORKING,
+	SAS_BOOT_IGNORED,
+	SAS_BOOT_INVALID
+};
+
+struct mtd_info;
+struct sas_flash_partition;
+
+void sas_boot_init(void);
+
+int sas_boot_scan_images(int *save_env);
+
+int sas_boot_has_platform_images(const struct sas_flash_partition *part);
+
+int sas_boot_has_service_images(const struct sas_flash_partition *part);
+
+void sas_boot_invalidate_image_state(unsigned int active_image);
+
+int sas_boot_invalidate_platform_images(const struct sas_flash_partition *part);
+
+int sas_boot_invalidate_service_images(const struct sas_flash_partition *part);
+
+int sas_boot_layout_platform(const struct sas_flash_partition *part,
+				size_t uimage_size, size_t rootfs_size,
+				ulong *uimage_addr, ulong *rootfs_addr,
+				size_t *erase_len);
+
+int sas_boot_layout_service(const struct sas_flash_partition *part,
+				size_t servicefs_size, size_t configfs_size,
+				ulong *servicefs_addr, ulong *configfs_addr,
+				size_t *erase_len);
+
+int sas_boot_init_platform_mtdparts(int active_image,
+					enum sas_flash_layout_type layout);
+
+int sas_boot_init_service_mtdparts(int active_image,
+					enum sas_flash_layout_type layout);
+
+int sas_boot_init_sysconfig_mtdparts(int active_image,
+					enum sas_flash_layout_type layout);
+
+int sas_boot_find_working_image(enum sas_flash_layout_type layout);
+
+int sas_boot_update_states(int active_image, int *retry, int *save_env);
+
+int sas_boot_load_image(const struct sas_flash_partition *part,
+				sas_image_type_t type, ulong addr);
+
+void sas_boot_print(void);
+
+const char* sas_boot_state_str(enum sas_boot_state state);
+
+#endif /* __SAS_BOOT_H__ */
diff --git a/include/sas/cd_user.h b/include/sas/cd_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..ddb30c6269da6ae62f26b6a44190ef4faae544cc
--- /dev/null
+++ b/include/sas/cd_user.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_CD_USER_H__
+#define __SAS_CD_USER_H__
+
+#define SAS_CDIH_BASE_UBOOT_VARIABLE_STRING	"cald_addr"
+
+#endif /* __SAS_CD_USER_H__ */
diff --git a/include/sas/controlfile.h b/include/sas/controlfile.h
new file mode 100644
index 0000000000000000000000000000000000000000..6ba14f548af9534dc928c49919a605567e1a38ff
--- /dev/null
+++ b/include/sas/controlfile.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_CONTROLFILE_H__
+#define __SAS_CONTROLFILE_H__
+
+enum sas_cf_state {
+	CF_STARTED,
+	CF_FINISHED,
+	CF_FAILED,
+};
+
+int sas_cf_check_board(void);
+void sas_cf_status_board(enum sas_cf_state state);
+void sas_cf_run(void);
+int sas_cf_is_active(void);
+void sas_cf_led_action(enum sas_cf_state state);
+
+#endif /* __SAS_CONTROLFILE_H__ */
diff --git a/include/sas/etl.h b/include/sas/etl.h
new file mode 100644
index 0000000000000000000000000000000000000000..f9a3321ffa9578757b379e8c6883592a8175cab4
--- /dev/null
+++ b/include/sas/etl.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_ETL_H__
+#define __SAS_ETL_H__
+
+#include <sas/etl_user.h>
+#include <sas/flashlayout.h>
+
+/**
+ * sas_etl_init - initialize ETL subsystem
+ */
+int sas_etl_init(void);
+
+int sas_etl_flash_read(unsigned long addr);
+int sas_etl_flash_write(unsigned long addr);
+int sas_etl_flash_erase(void);
+int sas_etl_import(unsigned long addr);
+int sas_etl_export(unsigned long addr);
+
+void sas_etl_env_set_ethaddr(int *save_env);
+void sas_etl_env_save(int *save_env);
+
+const char *sas_etl_get_string(enum sas_etl_id idx);
+int sas_etl_get_integer(enum sas_etl_id idx);
+unsigned long sas_etl_get_hex(enum sas_etl_id idx, unsigned int len);
+void sas_etl_set_string(enum sas_etl_id idx, const char *val);
+void sas_etl_set_integer(enum sas_etl_id idx, int val);
+void sas_etl_set_hex(enum sas_etl_id idx, unsigned int len, unsigned long val);
+
+void sas_etl_print(void);
+void sas_etl_dump(void);
+
+int sas_etl_version(void);
+enum sas_flash_layout_type sas_etl_flash_layout(void);
+size_t sas_etl_data_part_size(void);
+enum sas_data_part_loc sas_etl_data_part_loc(void);
+
+const char *sas_etl_id_str(enum sas_etl_id idx);
+enum sas_etl_id sas_etl_id_parse(const char *str);
+
+#endif /* __SAS_ETL_H__ */
diff --git a/include/sas/etl_user.h b/include/sas/etl_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..e7d8f1faf2fd07d01ef43a291fa444c6c296b3f8
--- /dev/null
+++ b/include/sas/etl_user.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_ETL_USER_H__
+#define __SAS_ETL_USER_H__
+
+enum sas_etl_id
+{
+	SAS_ETL_HW_VERSION		= 1,
+	SAS_ETL_SERIAL			= 2,
+	SAS_ETL_PROD_DATE		= 3,
+	SAS_ETL_WLAN_MODULE		= 4,
+	SAS_ETL_WLAN_KEY		= 5,
+	SAS_ETL_TRIV_NAME		= 6,
+	SAS_ETL_MAC_ADDR		= 7,
+	SAS_ETL_HW_CFG			= 8,
+	SAS_ETL_HW_CFG2			= 9,
+	SAS_ETL_IDENT_NO		= 10,
+	SAS_ETL_CUSTOMER		= 11,
+	SAS_ETL_BASE_PLATFORM		= 12,
+	SAS_ETL_WPS_PIN			= 13,
+	SAS_ETL_LEDCFG			= 14,
+	SAS_ETL_WLANCFG			= 15,
+	SAS_ETL_WLAN_SSID		= 16,
+	SAS_ETL_FLASH_LAYOUT		= 17,
+	SAS_ETL_EXTRA_SPACE_SIZE	= 18,
+	SAS_ETL_JFFS_IMAGES		= 19,
+	SAS_ETL_SERIAL_EXTRA		= 20,
+	SAS_ETL_SHDSL_LINES		= 21,
+	SAS_ETL_MAC_ADDR_POOL		= 22,
+	SAS_ETL_DATA_PART_SIZE		= 23,
+	SAS_ETL_DATA_PART_LOC		= 24,
+	SAS_ETL_ACS_AUTH		= 25,
+	SAS_ETL_WLAN_SSID_EXTRA		= 26,
+	SAS_ETL_ID_LAST,
+};
+
+typedef enum sas_etl_id sas_etl_id_t;
+
+struct sas_hw_cfg
+{
+	unsigned FXO : 1;
+	unsigned S0_ext : 1;
+	unsigned S0_int : 1;
+	unsigned ab_count : 2;
+	unsigned switch_ic : 1;
+	unsigned USB : 1;
+	unsigned metering_hw : 1;
+};
+
+struct sas_hw_cfg2
+{
+	unsigned reserved0 : 4;
+	unsigned fxs_ringvoltage : 4;
+	unsigned S0_int_count : 7;
+	unsigned reserved1 : 1;
+};
+
+struct sas_led_cfg
+{
+	unsigned l01 : 1;
+	unsigned l02 : 1;
+	unsigned l03 : 1;
+	unsigned l04 : 1;
+	unsigned l05 : 1;
+	unsigned l06 : 1;
+	unsigned l07 : 1;
+	unsigned l08 : 1;
+	unsigned l09 : 1;
+	unsigned l10 : 1;
+	unsigned l11 : 1;
+	unsigned l12 : 1;
+	unsigned l13 : 1;
+	unsigned l14 : 1;
+	unsigned rsvd : 2;
+};
+
+enum sas_data_part_loc {
+	DATA_PART_LOC_AUTO	= 0,
+	DATA_PART_LOC_BOOT	= 1,
+	DATA_PART_LOC_NAND	= 2,
+	DATA_PART_LOC_INVALID,
+};
+
+static inline int sas_etl_is_string(enum sas_etl_id idx)
+{
+	switch (idx) {
+	case SAS_ETL_HW_VERSION:
+	case SAS_ETL_SERIAL:
+	case SAS_ETL_PROD_DATE:
+	case SAS_ETL_WLAN_MODULE:
+	case SAS_ETL_WLAN_KEY:
+	case SAS_ETL_TRIV_NAME:
+	case SAS_ETL_MAC_ADDR:
+	case SAS_ETL_CUSTOMER:
+	case SAS_ETL_WPS_PIN:
+	case SAS_ETL_WLAN_SSID:
+	case SAS_ETL_FLASH_LAYOUT:
+	case SAS_ETL_SERIAL_EXTRA:
+	case SAS_ETL_ACS_AUTH:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int sas_etl_is_integer(enum sas_etl_id idx)
+{
+	switch (idx) {
+	case SAS_ETL_IDENT_NO:
+	case SAS_ETL_BASE_PLATFORM:
+	case SAS_ETL_EXTRA_SPACE_SIZE:
+	case SAS_ETL_JFFS_IMAGES:
+	case SAS_ETL_SHDSL_LINES:
+	case SAS_ETL_DATA_PART_SIZE:
+	case SAS_ETL_DATA_PART_LOC:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int sas_etl_is_hex(enum sas_etl_id idx)
+{
+	switch (idx) {
+	case SAS_ETL_HW_CFG:
+	case SAS_ETL_HW_CFG2:
+	case SAS_ETL_LEDCFG:
+	case SAS_ETL_WLANCFG:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline size_t sas_etl_hex_size(enum sas_etl_id idx)
+{
+	switch (idx) {
+	case SAS_ETL_HW_CFG:
+		return 1;
+	case SAS_ETL_HW_CFG2:
+	case SAS_ETL_LEDCFG:
+		return 2;
+	case SAS_ETL_WLANCFG:
+		return 4;
+	default:
+		return 0;
+	}
+}
+
+#define SAS_ETL_AREA_SIZE		256
+#define SAS_ETL_VARIABLE_EMPTY_CHAR	0x78
+#define SAS_ETL_MAX_VALUE_CHARS		40
+#define SAS_ETL_V2_SIZE			256
+#define SAS_ETL_DATA_PART_LOC_DEFAULT	DATA_PART_LOC_AUTO
+#define SAS_ETL_DATA_PART_SIZE_DEFAULT	10
+
+#endif /* __SAS_ETL_USER_H__ */
diff --git a/include/sas/flash.h b/include/sas/flash.h
new file mode 100644
index 0000000000000000000000000000000000000000..755ae6cf307601d3408020877acc35f1f0db8a6d
--- /dev/null
+++ b/include/sas/flash.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASH_H__
+#define __SAS_FLASH_H__
+
+#include <linux/list.h>
+#include <sas/flash_user.h>
+
+enum sas_flash_part_type {
+	SAS_PART_UBOOT_FIX,
+	SAS_PART_UBOOT_CFG,
+	SAS_PART_UBOOT_UPDATE,
+	SAS_PART_SYSCFG1,
+	SAS_PART_SYSCFG2,
+	SAS_PART_IMAGES1,
+	SAS_PART_IMAGES2,
+	SAS_PART_IMAGES3,
+	SAS_PART_DEVICE,
+	SAS_PART_DATA,
+	SAS_PART_INVALID
+};
+
+struct mtd_info;
+struct part_info;
+struct ubi_device;
+
+struct sas_flash_partition {
+	struct list_head link;
+	struct mtd_info *mtd;
+	struct part_info *pinfo;
+	struct ubi_device *ubi;
+	enum sas_flash_part_type type;
+	size_t offset;
+	size_t size;
+	u8 pnum;
+	u8 locked;
+};
+
+/**
+ * sas_flash_init - init the flash subsystem
+ */
+int sas_flash_init(void);
+
+/**
+ * sas_flash_verbose_set - set verbosity of flash subsystem
+ */
+void sas_flash_verbose_set(int v);
+
+/**
+ * sas_flash_part_create - create a new partition instance
+ *
+ * @type: partition type
+ */
+struct sas_flash_partition *
+sas_flash_part_create(enum sas_flash_part_type type);
+
+/**
+ * sas_flash_part_destroy - destroy a partition instance
+ *
+ * @part partition
+ */
+void sas_flash_part_destroy(struct sas_flash_partition *part);
+
+/**
+ * sas_flash_part_add - register a partition
+ *
+ * @part partition
+ */
+void sas_flash_part_add(struct sas_flash_partition *part);
+
+/**
+ * sas_flash_part_del - unregister a partition
+ *
+ * @part partition
+ */
+void sas_flash_part_del(struct sas_flash_partition *part);
+
+/**
+ * sas_flash_part_find - find a partition by its type
+ *
+ * @type: partition type
+ */
+struct sas_flash_partition *
+sas_flash_part_find(enum sas_flash_part_type type);
+
+/**
+ * sas_flash_part_mtdparts_sync - sync a partition info with its according
+ * mtdparts values
+ *
+ * @part partition
+ */
+int sas_flash_part_mtdparts_sync(struct sas_flash_partition *part);
+
+/**
+ * sas_flash_part_mtdparts_add - add a partition to mtdparts
+ *
+ * @mtd parent mtd device
+ * @part partition
+ */
+int sas_flash_part_mtdparts_add(const struct mtd_info *mtd,
+				struct sas_flash_partition *part,
+				size_t size, size_t offset);
+
+/**
+ * sas_flash_part_mtd_parent - get MTD parent device of given partition
+ *
+ * @part partition
+ */
+struct mtd_info *
+sas_flash_part_mtd_parent(const struct sas_flash_partition *part);
+
+/**
+ * sas_flash_part_mtd_register - register a MTD device for given partition
+ *
+ * @part partition
+ */
+int sas_flash_part_mtd_register(struct mtd_info *mtd,
+				struct sas_flash_partition *part);
+
+int sas_flash_part_ubi_attach(struct sas_flash_partition *part);
+
+struct ubi_volume *sas_flash_ubi_volume_find(struct sas_flash_partition *part,
+						const char *volume);
+
+struct mtd_info *sas_flash_boot_device(void);
+struct mtd_info *sas_flash_nand_device(void);
+
+void sas_flash_partition_print(void);
+
+size_t sas_flash_roundb(const struct sas_flash_partition *part, size_t len);
+
+int sas_flash_read(const struct sas_flash_partition *part,
+			ulong from, size_t len, void *buf);
+
+int sas_flash_write(const struct sas_flash_partition *part,
+			ulong to, size_t len, const void *buf);
+
+int sas_flash_lock(const struct sas_flash_partition *part,
+			ulong off, size_t len);
+
+int sas_flash_unlock(const struct sas_flash_partition *part,
+			ulong off, size_t len);
+
+int sas_flash_erase(const struct sas_flash_partition *part,
+			ulong off, size_t len);
+
+int sas_flash_partial_erase(const struct sas_flash_partition *part,
+				ulong off, size_t len);
+
+int sas_flash_complete_write(const struct sas_flash_partition *part,
+				ulong to, size_t write_len, size_t erase_len,
+				const void *buf, int partial_erase);
+
+static inline size_t sas_flash_cd_size(void)
+{
+	return 1 * 1024;
+}
+
+static inline size_t sas_flash_etl_size(void)
+{
+	return 1 * 1024;
+}
+
+static inline ulong sas_flash_cd_offset(const struct sas_flash_partition *part)
+{
+	return part->size - 8 * 1024;
+}
+
+static inline ulong sas_flash_etl_offset(const struct sas_flash_partition *part)
+{
+	return part->size - 7 * 1024;
+}
+
+const char* sas_flash_partition_str(enum sas_flash_part_type type);
+
+#endif /* __SAS_FLASH_H__ */
diff --git a/include/sas/flash_user.h b/include/sas/flash_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..66d870c971c2fb108e546a7f9dc020c332cdbda8
--- /dev/null
+++ b/include/sas/flash_user.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASH_USER_H__
+#define __SAS_FLASH_USER_H__
+
+#define SAS_FLASH_DATA_SIZE		(8 * 1024)
+#define SAS_FLASH_CD_SIZE		(1 * 1024)
+#define SAS_FLASH_ETL_SIZE		(1 * 1024)
+#define SAS_FLASH_ENV_SIZE		(8 * 1024)
+
+#endif /* __SAS_FLASH_USER_H__ */
diff --git a/include/sas/flashlayout.h b/include/sas/flashlayout.h
new file mode 100644
index 0000000000000000000000000000000000000000..99cd120ce7f7f03bbe6c0283b7848354dcf47b27
--- /dev/null
+++ b/include/sas/flashlayout.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASHLAYOUT_H__
+#define __SAS_FLASHLAYOUT_H__
+
+enum sas_flash_layout_type {
+	SAS_LAYOUT_BASIC = 0,
+	SAS_LAYOUT_PLATFORM_ONLY_SINGLE,
+	SAS_LAYOUT_PLATFORM_ONLY_MIRRORED,
+	SAS_LAYOUT_PLATFORM_SERVICE_SINGLE,
+	SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED,
+	SAS_LAYOUT_PLATFORM_ONLY_SINGLE_DATA,
+	SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA,
+	SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA,
+	SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA,
+	SAS_LAYOUT_INVALID
+};
+
+struct mtd_info;
+
+int sas_flash_layout_static_init(void);
+
+int sas_flash_layout_dynamic_init(struct mtd_info *boot_mtd,
+					struct mtd_info *nand_mtd,
+					enum sas_flash_layout_type layout);
+
+void sas_flash_layout_print(void);
+
+unsigned long sas_flash_layout_dynamic_offset(void);
+
+static inline int
+sas_flash_layout_is_bootable(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_BASIC:
+	case SAS_LAYOUT_INVALID:
+		return 0;
+	default:
+		return 1;
+	}
+}
+
+static inline int
+sas_flash_layout_is_mirrored(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int
+sas_flash_layout_has_uboot_update_part(void)
+{
+#ifdef CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+static inline int
+sas_flash_layout_has_image_parts(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int
+sas_flash_layout_image_part_cnt(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA:
+		return 1;
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 2;
+	default:
+		return 0;
+	}
+}
+
+static inline int sas_flash_layout_max_image_parts(void)
+{
+	return 3;
+}
+
+static inline int
+sas_flash_layout_has_sysconfig_part(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int
+sas_flash_layout_has_platform_images(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int
+sas_flash_layout_has_service_images(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static inline int
+sas_flash_layout_has_data_part(enum sas_flash_layout_type layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE_DATA:
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED_DATA:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED_DATA:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+struct sas_flash_partition *
+sas_flash_layout_image_partition(unsigned int index);
+
+enum sas_flash_layout_type sas_flash_layout_current(void);
+
+const char* sas_flash_layout_name(enum sas_flash_layout_type layout);
+
+const char* sas_flash_layout_str(enum sas_flash_layout_type layout);
+
+enum sas_flash_layout_type sas_flash_layout_parse(const char *str);
+
+#endif /* __SAS_FLASHLAYOUT_H__ */
diff --git a/include/sas/image.h b/include/sas/image.h
new file mode 100644
index 0000000000000000000000000000000000000000..120cd292d7096ebbe59e9d31dee74d6dc287e6df
--- /dev/null
+++ b/include/sas/image.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_IMAGE_H__
+#define __SAS_IMAGE_H__
+
+#include <image.h>
+
+typedef enum
+{
+	SAS_IMG_FDT = 0,
+	SAS_IMG_KERNEL,
+	SAS_IMG_ROOTFS,
+	SAS_IMG_SERVICEFS,
+	SAS_IMG_DEFCONFIG,
+	SAS_IMG_UNSPECIFIED,
+	SAS_IMG_INVALID,
+} sas_image_type_t;
+
+#define SAS_UBOOT_BIN		"u-boot.bin"
+#define SAS_UBOOT_IMAGE		"u-boot.img"
+#define SAS_UBOOT_LZO_IMAGE	"u-boot.lzo.img"
+#define SAS_UBOOT_LZMA_IMAGE	"u-boot.lzma.img"
+#define SAS_UBOOT_SFSPL		"u-boot.ltq.sfspl"
+#define SAS_UBOOT_LZO_SFSPL	"u-boot.ltq.lzo.sfspl"
+#define SAS_UBOOT_LZMA_SFSPL	"u-boot.ltq.lzma.sfspl"
+#define SAS_TYPELABEL_BIN	"typelabel.bin"
+#define SAS_KERNEL_IMAGE	"uImage"
+#define SAS_ROOTFS_IMAGE	"rootfs.img"
+#define SAS_SERVICEFS_IMAGE	"servicefs.img"
+#define SAS_CONFIGFS_IMAGE	"configfs.img"
+
+int sas_image_header_check(const image_header_t *hdr);
+
+int sas_image_data_check(const image_header_t *hdr);
+
+const char* sas_image_type_str(sas_image_type_t type);
+
+sas_image_type_t sas_image_type(const image_header_t *hdr);
+
+size_t sas_image_size(const image_header_t *hdr);
+
+void sas_image_name(const image_header_t *hdr, char *buf);
+
+#endif /* __SAS_IMAGE_H__ */
diff --git a/include/sas/init.h b/include/sas/init.h
new file mode 100644
index 0000000000000000000000000000000000000000..92bf7a0ab204641720c20e5fbbe60b0b545b25ee
--- /dev/null
+++ b/include/sas/init.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_INIT_H__
+#define __SAS_INIT_H__
+
+#ifdef CONFIG_LIB_SPHAIRON
+int sas_init_f(void);
+
+int sas_init_r(void);
+#else
+static inline int sas_init_f(void)
+{
+	return 0;
+}
+
+static inline int sas_init_r(void)
+{
+	return 0;
+}
+#endif
+
+int sas_board_init_f(void);
+int sas_board_init_r(void);
+
+#endif /* __SAS_INIT_H__ */
diff --git a/include/sas/util.h b/include/sas/util.h
new file mode 100644
index 0000000000000000000000000000000000000000..3ea77cbb7f9b2d4ec6915144149cf96aa39c812a
--- /dev/null
+++ b/include/sas/util.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_UTIL_H__
+#define __SAS_UTIL_H__
+
+int sas_setenv(const char *name, const char *value, int *saveenv);
+
+int sas_setenv_num(const char *name, int value, int *saveenv);
+
+int sas_setenv_hex(const char *name, int value, int *saveenv);
+
+void sas_saveenv(void);
+
+int sas_run_command(const char* fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+size_t sas_run_tftpboot(ulong loadaddr, const char *file);
+
+int sas_confirm(const char *message);
+
+void sas_banner_header_print(const char *fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+void sas_banner_content_print(const char *fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+void sas_banner_footer_print(void);
+
+void sas_banner_line_print(void);
+
+#endif /* __SAS_UTIL_H__ */
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 3b6a44edcef6a1e8707ecd20572f191c9f05da46..5781a91a7015edd5501d2f06ba3dbd480f87e196 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -31,6 +31,7 @@ struct spi_flash {
 	struct spi_slave *spi;
 
 	const char	*name;
+	void		*priv;
 
 	/* Total flash size */
 	u32		size;
@@ -46,6 +47,9 @@ struct spi_flash {
 				size_t len, const void *buf);
 	int		(*erase)(struct spi_flash *flash, u32 offset,
 				size_t len);
+#ifdef CONFIG_SPI_FLASH_4BYTE_MODE
+	int		(*set_4byte_mode)(struct spi_flash *flash);
+#endif
 };
 
 /**
@@ -86,10 +90,17 @@ void *spi_flash_do_alloc(int offset, int size, struct spi_slave *spi,
 #define spi_flash_alloc_base(spi, name) \
 	spi_flash_do_alloc(0, sizeof(struct spi_flash), spi, name)
 
+int spi_flash_init(void);
+
 struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode);
 void spi_flash_free(struct spi_flash *flash);
 
+int spi_flash_probe_spl(struct spi_flash *flash, unsigned int bus,
+			unsigned int cs, unsigned int max_hz,
+			unsigned int spi_mode);
+void spi_flash_free_spl(struct spi_flash *flash);
+
 static inline int spi_flash_read(struct spi_flash *flash, u32 offset,
 		size_t len, void *buf)
 {
diff --git a/include/switch.h b/include/switch.h
new file mode 100644
index 0000000000000000000000000000000000000000..3bb3e2347ff8f3789471997d1431094781ae9b6e
--- /dev/null
+++ b/include/switch.h
@@ -0,0 +1,98 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#ifndef __SWITCH_H
+#define __SWITCH_H
+
+#include <linux/list.h>
+
+#define SWITCH_NAME_SIZE	32
+
+struct switch_device;
+struct mii_dev;
+
+struct switch_driver {
+	struct list_head list;
+
+	/* Switch device name */
+	const char name[SWITCH_NAME_SIZE];
+
+	/*
+	 * Called to probe the switch chip. Must return 0 if the switch
+	 * chip matches the given switch device/driver combination. Otherwise
+	 * 1 must be returned.
+	 */
+	int (*probe) (struct switch_device *dev);
+
+	/*
+	 * Called to initialize the switch chip.
+	 */
+	void (*setup) (struct switch_device *dev);
+};
+
+struct switch_device {
+	struct list_head list;
+	struct switch_driver *drv;
+
+	/* MII bus the switch chip is connected to */
+	struct mii_dev *bus;
+
+	/* Switch device name */
+	const char name[SWITCH_NAME_SIZE];
+
+	/* Bitmask for board specific setup of used switch ports */
+	u16 port_mask;
+
+	/* Number of switch port that is connected to host CPU */
+	u16 cpu_port;
+};
+
+/*
+ * Board specific switch initialization.
+ *
+ * Called from switch_init to register the board specific switch_device
+ * structure.
+ */
+extern int board_switch_init(void);
+
+/* Initialize switch subsystem */
+#ifdef CONFIG_SWITCH_MULTI
+extern void switch_init(void);
+#else
+static inline void switch_init(void)
+{
+}
+#endif
+
+/* Register a switch driver */
+extern void switch_driver_register(struct switch_driver *drv);
+
+/* Register a switch device */
+extern int switch_device_register(struct switch_device *dev);
+
+/*
+ * Probe the available switch chips and connect the found one
+ * with the given MII bus
+ */
+extern struct switch_device *switch_connect(struct mii_dev *bus);
+
+/*
+ * Setup the given switch device
+ */
+static inline void switch_setup(struct switch_device *dev)
+{
+	if (dev->drv->setup)
+		dev->drv->setup(dev);
+}
+
+/* Init functions for supported Switch drivers */
+extern void switch_psb697x_init(void);
+extern void switch_adm6996i_init(void);
+extern void switch_ar8216_init(void);
+
+#endif /* __SWITCH_H */
+
diff --git a/lib/sphairon/Makefile b/lib/sphairon/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..1c8ba93b84d6ef2dc497174ade0bccc5efa393e5
--- /dev/null
+++ b/lib/sphairon/Makefile
@@ -0,0 +1,46 @@
+#
+# Copyright (C) 2011-2013 Sphairon Technologies GmbH
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+
+include $(TOPDIR)/config.mk
+
+CFLAGS	+= -Werror
+
+LIB	= $(obj)libsphairon.o
+
+COBJS-y	+= util.o
+COBJS-y	+= flash.o flashlayout.o
+COBJS-y	+= etl.o
+COBJS-y	+= boot.o image.o
+COBJS-y	+= init.o
+COBJS-y	+= controlfile.o
+ifneq ($(CONFIG_SYS_BOOT_RAM),y)
+COBJS-y	+= cmd_sas_boot.o
+COBJS-y	+= cmd_sas_upgrade.o
+endif
+COBJS-$(CONFIG_SPI_FLASH) += cmd_sas_test_sf.o
+COBJS-y	+= cmd_sas_controlfile.o
+COBJS-y	+= cmd_sas_etl.o
+SOBJS-y	+=
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/lib/sphairon/boot.c b/lib/sphairon/boot.c
new file mode 100644
index 0000000000000000000000000000000000000000..6bc48d823641b964f4e3707e76892799f671b8bd
--- /dev/null
+++ b/lib/sphairon/boot.c
@@ -0,0 +1,738 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/boot.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+
+struct sas_boot_image {
+	struct list_head link;
+	sas_image_type_t type;
+	size_t size;
+	size_t offset;
+	const struct sas_flash_partition *part;
+	char name[IH_NMLEN];
+};
+
+static struct list_head sas_boot_images;
+
+void sas_boot_init(void)
+{
+	INIT_LIST_HEAD(&sas_boot_images);
+}
+
+static int sas_boot_image_add(const struct sas_flash_partition *part,
+				const image_header_t *hdr,
+				sas_image_type_t type, size_t size,
+				ulong offset)
+{
+	struct sas_boot_image *image;
+
+	image = malloc(sizeof(*image));
+	if (!image)
+		return 1;
+
+	INIT_LIST_HEAD(&image->link);
+	image->type = type;
+	image->size = size;
+	image->offset = offset;
+	image->part = part;
+	sas_image_name(hdr, image->name);
+
+	list_add_tail(&image->link, &sas_boot_images);
+
+	return 0;
+}
+
+/*
+ * Scan for boot images.
+ *
+ * - with PSH layout we expect a kernel image or servicefs image
+ *   at partition begin
+ * - with all other layouts we expect only a kernel image at
+ *   partition begin
+ * - if kernel image or servicefs image could not found we can abort
+ *   the scan for this partition
+ */
+static int sas_boot_image_part_scan(const struct sas_flash_partition *part,
+					enum sas_flash_layout_type flash_layout)
+{
+	size_t size;
+	int ret;
+	image_header_t hdr;
+	sas_image_type_t type;
+	unsigned long offset;
+
+	debug("%s: mtd->name %s, mtd->size %llx, mtd->erasesize %x\n",
+		__func__, part->mtd->name, part->mtd->size, part->mtd->erasesize);
+
+	offset = 0;
+	do {
+		ret = sas_flash_read(part, offset, sizeof(hdr), &hdr);
+		if (ret)
+			return ret;
+
+		ret = sas_image_header_check(&hdr);
+		if (ret)
+			type = sas_image_type(&hdr);
+		else
+			type = SAS_IMG_INVALID;
+
+		if (type != SAS_IMG_INVALID) {
+			size = sas_image_size(&hdr);
+
+			/*
+			 * Skip image and abort scan if image size exceeds
+			 * remaining gap between current offset and MTD size.
+			 * This situation can occur after changes on
+			 * flash layout.
+			 */
+			if (size >= part->mtd->size - offset)
+				return 0;
+
+			ret = sas_boot_image_add(part, &hdr, type, size,
+						 offset);
+			if (ret)
+				return ret;
+
+			offset += size;
+			offset = ALIGN(offset, CONFIG_SPHAIRON_SCAN_STEP_SIZE);
+		} else
+			offset += CONFIG_SPHAIRON_SCAN_STEP_SIZE;
+	} while (offset < part->mtd->size);
+
+	return 0;
+}
+
+static void sas_boot_content_set(unsigned int index, int has_platform,
+					int has_service, int *save_env)
+{
+	unsigned int content = (has_platform | (has_service << 1));
+	char buf[32];
+
+	sprintf(buf, "image_content%u", index);
+	printf("Setting content of image %u to %u\n",
+		index, content);
+
+	sas_setenv_num(buf, content, save_env);
+}
+
+static enum sas_boot_state sas_boot_state_get(unsigned int index)
+{
+	char buf[32];
+	int state;
+
+	sprintf(buf, "image_state%u", index);
+
+	state = getenv_ulong(buf, 10, SAS_BOOT_NOTAVAILABLE);
+	if (state > SAS_BOOT_IGNORED)
+		state = SAS_BOOT_NOTAVAILABLE;
+
+	return state;
+}
+
+static void sas_boot_state_set(unsigned int index, enum sas_boot_state state,
+				int *save_env)
+{
+	char buf[32];
+
+	sprintf(buf, "image_state%u", index);
+	printf("Setting state of image %u to '%s'\n",
+		index, sas_boot_state_str(state));
+
+	sas_setenv_num(buf, state, save_env);
+}
+
+static int sas_boot_bootcount_get(void)
+{
+	return getenv_ulong("boot_count", 10, 0);
+}
+
+static int sas_boot_bootcountmax_get(void)
+{
+	return getenv_ulong("boot_count_max", 10, 3);
+}
+
+static void sas_boot_bootcount_set(int value, int *save_env)
+{
+	printf("Setting boot_count to %d\n", value);
+	sas_setenv_num("boot_count", value, save_env);
+}
+
+static int sas_boot_boottry_get(void)
+{
+	return getenv_ulong("boot_try", 10, 0);
+}
+
+static void sas_boot_boottry_set(int value, int *save_env)
+{
+	printf("Setting boot_try to %d\n", value);
+	sas_setenv_num("boot_try", value, save_env);
+}
+
+static void sas_boot_flush_images(void)
+{
+	struct sas_boot_image *image;
+
+	while (!list_empty(&sas_boot_images)) {
+		image = list_first_entry(&sas_boot_images,
+					 struct sas_boot_image, link);
+		list_del(&image->link);
+		free(image);
+	}
+}
+
+int sas_boot_scan_images(int *save_env)
+{
+	const struct sas_flash_partition *part;
+	enum sas_flash_layout_type flash_layout;
+	enum sas_boot_state state_new, state_cur;
+	int ret, image_cnt, i;
+	int has_platformfs, has_servicefs;
+
+	debug("sas_boot: scanning\n");
+
+	flash_layout = sas_flash_layout_current();
+	if (!sas_flash_layout_has_image_parts(flash_layout))
+		return 0;
+
+	sas_boot_flush_images();
+
+	image_cnt = sas_flash_layout_image_part_cnt(flash_layout);
+
+	for (i = 0; i < sas_flash_layout_max_image_parts(); i++) {
+		if (i >= image_cnt) {
+			sas_boot_state_set(i + 1, SAS_BOOT_NOTAVAILABLE,
+				save_env);
+			sas_boot_content_set(i + 1, 0, 0, save_env);
+			continue;
+		}
+
+		part = sas_flash_layout_image_partition(i);
+
+		ret = sas_boot_image_part_scan(part, flash_layout);
+		if (ret)
+			return ret;
+
+		has_platformfs = sas_boot_has_platform_images(part);
+		has_servicefs = sas_boot_has_service_images(part);
+
+		sas_boot_content_set(i + 1, has_platformfs, has_servicefs,
+			save_env);
+
+		state_cur = sas_boot_state_get(i + 1);
+		state_new = SAS_BOOT_NOTAVAILABLE;
+
+		if (has_platformfs)
+			state_new = SAS_BOOT_AVAILABLE;
+
+		if (state_new == SAS_BOOT_AVAILABLE &&
+			state_cur != SAS_BOOT_NOTAVAILABLE)
+			state_new = state_cur;
+
+		sas_boot_state_set(i + 1, state_new, save_env);
+	}
+
+	return 0;
+}
+
+static struct sas_boot_image *
+sas_boot_image_find(sas_image_type_t type,
+			const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part == image->part && type == image->type)
+			return image;
+	}
+
+	return NULL;
+}
+
+static int sas_boot_fs_part_add(const struct sas_flash_partition *part,
+				sas_image_type_t type, const char *name)
+{
+	struct sas_boot_image *image;
+	struct mtd_info *mtd;
+	int err;
+	size_t size;
+	unsigned long offset;
+
+	debug("%s: part %d, name %s\n", __func__, part->type, name);
+
+	image = sas_boot_image_find(type, part);
+	if (!image)
+		return 1;
+
+	mtd = sas_flash_part_mtd_parent(part);
+	if (!mtd)
+		return 1;
+
+	size = image->size - sizeof(image_header_t);
+	offset = image->offset + part->offset + sizeof(image_header_t);
+
+	err = sas_run_command("mtdparts add %s %zu@%lu %s ro", mtd->name,
+		size, offset, name);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+int sas_boot_init_platform_mtdparts(int active_image,
+					enum sas_flash_layout_type layout)
+{
+	const struct sas_flash_partition *part;
+
+	if (!active_image)
+		return 1;
+
+	part = sas_flash_layout_image_partition(active_image - 1);
+	if (!part)
+		return 1;
+
+	return sas_boot_fs_part_add(part, SAS_IMG_ROOTFS, "rootfs");
+}
+
+int sas_boot_init_service_mtdparts(int active_image,
+					enum sas_flash_layout_type layout)
+{
+	const struct sas_flash_partition *part;
+	int ret;
+
+	if (!active_image)
+		return 1;
+
+	part = sas_flash_layout_image_partition(active_image - 1);
+	if (!part)
+		return 1;
+
+	ret = sas_boot_fs_part_add(part, SAS_IMG_SERVICEFS, "servicefs");
+	if (ret)
+		return ret;
+
+	ret = sas_boot_fs_part_add(part, SAS_IMG_DEFCONFIG, "defconfig");
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int sas_boot_sysconfig_part_add(enum sas_flash_part_type type,
+					const char *name)
+{
+	const struct sas_flash_partition *part;
+	struct mtd_info *mtd;
+	int ret;
+
+	debug("%s: type %d, name %s\n", __func__, type, name);
+
+	part = sas_flash_part_find(type);
+	if (!part)
+		return 1;
+
+	mtd = sas_flash_part_mtd_parent(part);
+	if (!mtd)
+		return 1;
+
+	ret = sas_run_command("mtdparts add %s %zu@%zu %s", mtd->name,
+		part->size, part->offset, name);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int sas_boot_init_sysconfig_mtdparts(int active_image,
+					enum sas_flash_layout_type layout)
+{
+	enum sas_flash_part_type cfg_active, cfg_backup;
+	int ret;
+
+	if (!active_image)
+		active_image = sas_boot_boottry_get();
+
+	if (!active_image)
+		active_image = 1;
+
+	if (sas_flash_layout_is_mirrored(layout)) {
+		if (active_image == 2) {
+			cfg_active = SAS_PART_SYSCFG2;
+			cfg_backup = SAS_PART_SYSCFG1;
+		} else {
+			cfg_active = SAS_PART_SYSCFG1;
+			cfg_backup = SAS_PART_SYSCFG2;
+		}
+	} else {
+		cfg_active = SAS_PART_SYSCFG1;
+		cfg_backup = SAS_PART_INVALID;
+	}
+
+	ret = sas_boot_sysconfig_part_add(cfg_active, "cfg_active");
+	if (ret)
+		return ret;
+
+	if (cfg_backup != SAS_PART_INVALID) {
+		ret = sas_boot_sysconfig_part_add(cfg_backup, "cfg_backup");
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int sas_boot_find_working_image(enum sas_flash_layout_type layout)
+{
+	unsigned int first_active_working = 0;
+	unsigned int first_inactive_working = 0;
+	unsigned int first_available = 0;
+	unsigned int part_cnt = sas_flash_layout_image_part_cnt(layout);
+	unsigned int i, image_index;
+	enum sas_boot_state state;
+
+	/*
+	 * Boot image selection strategy:
+	 * 1) use first active,working image if available
+	 * 2) prefer first available image over inactive,working
+	 *    -> firmware update case
+	 * 3) use first inactive,working image
+	 */
+
+	for (i = 0; i < part_cnt; i++) {
+		image_index = i + 1;
+		state = sas_boot_state_get(image_index);
+
+		switch (state) {
+		case SAS_BOOT_ACTIVEWORKING:
+			if (!first_active_working)
+				first_active_working = image_index;
+			break;
+		case SAS_BOOT_INACTIVEWORKING:
+			if (!first_inactive_working)
+				first_inactive_working = image_index;
+			break;
+		case SAS_BOOT_AVAILABLE:
+			if (!first_available)
+				first_available = image_index;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (first_active_working) {
+		printf("Using first active,working image %u\n",
+			first_active_working);
+		return first_active_working;
+	}
+
+	if (first_available) {
+		printf("Using first available image %u\n",
+			first_available);
+		return first_available;
+	}
+
+	if (first_inactive_working) {
+		printf("Using first inactive,working image %u\n",
+			first_inactive_working);
+		return first_inactive_working;
+	}
+
+	puts("No active image found\n");
+
+	return 0;
+}
+
+int sas_boot_update_states(int active_image, int *retry, int *save_env)
+{
+	unsigned int boot_try = sas_boot_boottry_get();
+	unsigned int boot_cnt = sas_boot_bootcount_get();
+	unsigned int boot_cnt_max = sas_boot_bootcountmax_get();
+	enum sas_boot_state state_cur, state_new;
+	int can_boot = 0;
+
+	if (active_image)
+		state_cur = sas_boot_state_get(active_image);
+	else
+		state_cur = SAS_BOOT_NOTWORKING;
+
+	state_new = state_cur;
+
+	*retry = 0;
+
+	switch (state_cur) {
+	case SAS_BOOT_AVAILABLE:
+		if (boot_cnt < boot_cnt_max) {
+			boot_cnt++;
+			boot_try = active_image;
+			can_boot = 1;
+		} else {
+			printf("Boot retry count exceeded for image %u\n",
+				active_image);
+			state_new = SAS_BOOT_NOTWORKING;
+			boot_cnt = 0;
+			*retry = 1;
+		}
+		break;
+	case SAS_BOOT_ACTIVEWORKING:
+		boot_try = active_image;
+		can_boot = 1;
+		break;
+	case SAS_BOOT_INACTIVEWORKING:
+		state_new = SAS_BOOT_ACTIVEWORKING;
+		boot_try = active_image;
+		can_boot = 1;
+		break;
+	case SAS_BOOT_NOTWORKING:
+		boot_try = 0;
+		break;
+	default:
+		break;
+	}
+
+	if (state_new != state_cur) {
+		printf("Changing image state %u: %s -> %s\n", active_image,
+			sas_boot_state_str(state_cur),
+			sas_boot_state_str(state_new));
+	}
+
+	sas_boot_state_set(active_image, state_new, save_env);
+	sas_boot_bootcount_set(boot_cnt, save_env);
+	sas_boot_boottry_set(boot_try, save_env);
+
+	return can_boot;
+}
+
+int sas_boot_has_platform_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+	int has_kernel = 0, has_rootfs = 0;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part != image->part)
+			continue;
+
+		if (SAS_IMG_KERNEL == image->type)
+			has_kernel = 1;
+
+		if (SAS_IMG_ROOTFS == image->type)
+			has_rootfs = 1;
+	}
+
+	return has_kernel && has_rootfs;
+}
+
+int sas_boot_has_service_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+	int has_servicefs = 0, has_defconfig = 0;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part != image->part)
+			continue;
+
+		if (SAS_IMG_SERVICEFS == image->type)
+			has_servicefs = 1;
+
+		if (SAS_IMG_DEFCONFIG == image->type)
+			has_defconfig = 1;
+	}
+
+	return has_servicefs && has_defconfig;
+}
+
+void sas_boot_invalidate_image_state(unsigned int active_image)
+{
+	int save_env = 0;
+
+	sas_boot_state_set(active_image, SAS_BOOT_NOTAVAILABLE, &save_env);
+
+	if (save_env)
+		sas_saveenv();
+}
+
+int sas_boot_invalidate_platform_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+	ulong data = 0;
+	int ret;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part != image->part || (SAS_IMG_KERNEL != image->type &&
+			SAS_IMG_ROOTFS != image->type))
+			continue;
+
+		printf("Invalidating image %s @ %x on %s\n",
+			image->name, image->offset, part->mtd->name);
+
+		ret = sas_flash_write(part, image->offset, sizeof(data), &data);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int sas_boot_invalidate_service_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+	ulong data = 0;
+	int ret;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part != image->part || (SAS_IMG_SERVICEFS != image->type &&
+			SAS_IMG_DEFCONFIG != image->type))
+			continue;
+
+		printf("Invalidating image %s @ %x on %s\n",
+			image->name, image->offset, part->mtd->name);
+
+		ret = sas_flash_write(part, image->offset, sizeof(data), &data);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int sas_boot_layout_platform(const struct sas_flash_partition *part,
+				size_t uimage_size, size_t rootfs_size,
+				ulong *uimage_addr, ulong *rootfs_addr,
+				size_t *erase_len)
+{
+	ulong uimage_srcaddr, rootfs_srcaddr;
+
+	debug("%s: part %s, uimage_size %zu, rootfs_size %zu\n",
+		__func__, part->mtd->name, uimage_size, rootfs_size);
+
+	uimage_srcaddr = 0;
+	rootfs_srcaddr = uimage_srcaddr + uimage_size;
+
+	debug("%s: uimage_srcaddr %08lx, rootfs_srcaddr %08lx\n",
+		__func__, uimage_srcaddr, rootfs_srcaddr);
+
+	*uimage_addr = uimage_srcaddr;
+	*rootfs_addr = ALIGN(rootfs_srcaddr, CONFIG_SPHAIRON_SCAN_STEP_SIZE);
+
+	*erase_len = *rootfs_addr + rootfs_size;
+	*erase_len = sas_flash_roundb(part, *erase_len);
+
+	if (*erase_len > part->size) {
+		puts("Size of images exceeds partition size\n");
+		return 1;
+	}
+
+	debug("%s: uimage_addr %08lx, rootfs_addr %08lx, erase_len %zu\n",
+		__func__, *uimage_addr, *rootfs_addr, *erase_len);
+
+	return 0;
+}
+
+int sas_boot_layout_service(const struct sas_flash_partition *part,
+				size_t servicefs_size, size_t configfs_size,
+				ulong *servicefs_addr, ulong *configfs_addr,
+				size_t *erase_len)
+{
+	struct sas_boot_image *image;
+	ulong servicefs_srcaddr, configfs_srcaddr;
+	ulong rootfs_endaddr = 0;
+
+	debug("%s: part %s, servicefs_size %zu, configfs_size %zu\n",
+		__func__, part->mtd->name, servicefs_size, configfs_size);
+
+	image = sas_boot_image_find(SAS_IMG_ROOTFS, part);
+	if (image)
+		rootfs_endaddr = image->offset + image->size;
+
+	servicefs_srcaddr = ALIGN(rootfs_endaddr, part->mtd->erasesize);
+	configfs_srcaddr = servicefs_srcaddr + servicefs_size;
+
+	debug("%s: rootfs_endaddr %08lx, servicefs_srcaddr %08lx, configfs_srcaddr %08lx\n",
+		__func__, rootfs_endaddr, servicefs_srcaddr, configfs_srcaddr);
+
+	*servicefs_addr = servicefs_srcaddr;
+	*configfs_addr = ALIGN(configfs_srcaddr, part->mtd->erasesize);
+
+	*erase_len = *configfs_addr + configfs_size - *servicefs_addr;
+	*erase_len = sas_flash_roundb(part, *erase_len);
+
+	if (*erase_len > part->size) {
+		puts("Size of images exceeds partition size\n");
+		return 1;
+	}
+
+	debug("%s: rootfs_endaddr %08lx, servicefs_addr %08lx, configfs_addr %08lx, erase_len %zu\n",
+		__func__, rootfs_endaddr, *servicefs_addr, *configfs_addr,
+		*erase_len);
+
+	return 0;
+}
+
+int sas_boot_load_image(const struct sas_flash_partition *part,
+			sas_image_type_t type, ulong addr)
+{
+	struct sas_boot_image *image;
+
+	image = sas_boot_image_find(type, part);
+	if (!image)
+		return 1;
+
+	return sas_flash_read(part, image->offset, image->size, (void *) addr);
+}
+
+void sas_boot_print(void)
+{
+	struct sas_boot_image *image;
+	enum sas_boot_state state;
+	unsigned int i;
+	enum sas_flash_layout_type layout = sas_flash_layout_current();
+	unsigned int images_max = sas_flash_layout_image_part_cnt(layout);
+
+	sas_banner_header_print("Boot info");
+
+	list_for_each_entry(image, &sas_boot_images, link)
+		sas_banner_content_print("%-8s @ %08x      %-32s",
+					sas_flash_partition_str(image->part->type),
+					image->offset, image->name);
+
+	sas_banner_line_print();
+
+	for (i = 1; i <= images_max; i++) {
+		state = sas_boot_state_get(i);
+		sas_banner_content_print("Boot image %d%13s%-32s", i, "",
+						sas_boot_state_str(state));
+	}
+
+	sas_banner_content_print("%-25s%-u ", "Boot count",
+					sas_boot_bootcount_get());
+	sas_banner_content_print("%-25s%-u ", "Boot try",
+					sas_boot_boottry_get());
+
+	sas_banner_footer_print();
+}
+
+static const char sas_boot_state_strings[][20] = {
+	"not available",
+	"available",
+	"active,working",
+	"inactive,working",
+	"not working",
+	"ignored",
+	"invalid"
+};
+
+const char* sas_boot_state_str(enum sas_boot_state state)
+{
+	assert(state <= SAS_BOOT_INVALID);
+
+	return sas_boot_state_strings[state];
+}
diff --git a/lib/sphairon/cmd_sas_boot.c b/lib/sphairon/cmd_sas_boot.c
new file mode 100644
index 0000000000000000000000000000000000000000..6c82adaf8d1d9cec1e5d66b3c180f8c216c325b7
--- /dev/null
+++ b/lib/sphairon/cmd_sas_boot.c
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <generated/timestamp_autogenerated.h>
+#include <generated/version_autogenerated.h>
+
+#include <sas/util.h>
+#include <sas/boot.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+#include <sas/etl.h>
+
+/* Alternate console devices needed for Lantiq UGW kernels */
+static const char *sas_consoledev_fixup(void)
+{
+#if defined(CONFIG_SOC_XWAY_VRX200)
+	return "ttyS0";
+#else
+	return "ttyS1";
+#endif
+}
+
+static const char *sas_consoledev_configured(void)
+{
+	return CONFIG_CONSOLE_DEV;
+}
+
+enum sas_image_src_type {
+	SAS_FLASH,
+	SAS_TFTP,
+	SAS_NFS,
+	SAS_NONE,
+	SAS_PTEST,
+	SAS_INVALID,
+};
+
+static const char sas_image_src_strings[][10] = {
+	"flash",
+	"tftp",
+	"nfs",
+	"none",
+	"ptest",
+	"invalid"
+};
+
+static const char * sas_image_src_str(enum sas_image_src_type image)
+{
+	assert(image <= SAS_INVALID);
+
+	return sas_image_src_strings[image];
+}
+
+static int sas_image_src_set(const char *name, enum sas_image_src_type image,
+				int *saveenv)
+{
+	assert(image <= SAS_INVALID);
+
+	return sas_setenv(name, sas_image_src_strings[image], saveenv);
+}
+
+static enum sas_image_src_type
+sas_parse_image_src(const char *image, enum sas_image_src_type def_image)
+{
+	int i, ret;
+
+	if (!image)
+		return def_image;
+
+	for (i = 0; i < ARRAY_SIZE(sas_image_src_strings); i++) {
+		ret = strcmp(image, sas_image_src_str(i));
+		if (!ret)
+			return i;
+	}
+
+	printf("sas_boot: invalid image src: %s\n",
+		image ? image : "");
+
+	return SAS_INVALID;
+}
+
+static const char *sas_image_str(sas_image_type_t type)
+{
+	switch (type) {
+	case SAS_IMG_ROOTFS:
+		return "rootfs";
+	case SAS_IMG_SERVICEFS:
+		return "servicefs";
+	case SAS_IMG_DEFCONFIG:
+		return "defconfig";
+	default:
+		return NULL;
+	}
+}
+
+static int sas_kernel_load(int active_image, enum sas_image_src_type src,
+				ulong loadaddr)
+{
+	int ret;
+	size_t size;
+	const struct sas_flash_partition *part;
+
+	switch (src) {
+	case SAS_TFTP:
+		size = sas_run_tftpboot(loadaddr, SAS_KERNEL_IMAGE);
+		if (!size)
+			goto err;
+		break;
+	case SAS_FLASH:
+		if (!active_image)
+			goto err;
+
+		part = sas_flash_layout_image_partition(active_image - 1);
+		ret = sas_boot_load_image(part, SAS_IMG_KERNEL, loadaddr);
+		if (ret)
+			goto err;
+		break;
+	default:
+		goto err;
+	}
+
+	return 0;
+
+err:
+	puts("Failed to load kernel image\n");
+
+	return 1;
+}
+
+static int sas_servicefs_load(enum sas_flash_layout_type layout,
+				int active_image, enum sas_image_src_type src)
+{
+	const struct sas_flash_partition *part;
+	int ret;
+
+	if (!sas_flash_layout_has_service_images(layout))
+		return 0;
+
+	if (src != SAS_FLASH)
+		return 0;
+
+	if (!active_image)
+		goto err;
+
+	part = sas_flash_layout_image_partition(active_image - 1);
+	if (!part)
+		goto err;
+
+	ret = sas_boot_has_service_images(part);
+	if (ret)
+		return 0;
+
+err:
+	puts("Failed to load service images\n");
+
+	return 1;
+}
+
+static int sas_mtdparts_update(enum sas_flash_layout_type layout,
+				int active_image,
+				enum sas_image_src_type rootfs_src,
+				enum sas_image_src_type servicefs_src)
+{
+	int ret;
+
+	if (sas_flash_layout_has_sysconfig_part(layout)) {
+		ret = sas_boot_init_sysconfig_mtdparts(active_image, layout);
+		if (ret)
+			return ret;
+	}
+
+	if (sas_flash_layout_has_platform_images(layout) &&
+		rootfs_src == SAS_FLASH) {
+		ret = sas_boot_init_platform_mtdparts(active_image, layout);
+		if (ret)
+			return ret;
+	}
+
+	if (sas_flash_layout_has_service_images(layout) &&
+		servicefs_src == SAS_FLASH) {
+		ret = sas_boot_init_service_mtdparts(active_image, layout);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void sas_env_fs_arg_set(const char *name, enum sas_image_src_type src)
+{
+	char buf[48];
+
+	sprintf(buf, "%s=%s", name, sas_image_src_str(src));
+	setenv(name, buf);
+}
+
+static void sas_env_fs_args_init(int active_image,
+				enum sas_image_src_type rootfs_src,
+				enum sas_image_src_type servicefs_src)
+{
+	sas_env_fs_arg_set("rootfs", rootfs_src);
+	sas_env_fs_arg_set("servicefs", servicefs_src);
+	sas_env_fs_arg_set("defconfig", servicefs_src);
+}
+
+static void sas_env_console_init(ulong loadaddr)
+{
+	const image_header_t *hdr = (const image_header_t *)loadaddr;
+	const char *consoledev;
+	char name[IH_NMLEN + 1];
+
+	sas_image_name(hdr, name);
+
+	if (!strncmp(name, "kernel#Linux-2.6.32", 19))
+		consoledev = sas_consoledev_fixup();
+	else
+		consoledev = sas_consoledev_configured();
+
+	printf("Fixup console device to %s\n", consoledev);
+
+	setenv("consoledev", consoledev);
+}
+
+static void sas_env_bootargs_clear(void)
+{
+	setenv("bootargs", NULL);
+	setenv("ptest", NULL);
+	setenv(sas_image_str(SAS_IMG_ROOTFS), NULL);
+	setenv(sas_image_str(SAS_IMG_SERVICEFS), NULL);
+	setenv(sas_image_str(SAS_IMG_DEFCONFIG), NULL);
+}
+
+static void sas_env_flashlayout_set(enum sas_flash_layout_type layout,
+					int *save_env)
+{
+	const char flash_layout[] = "flash_layout";
+	char buf[24];
+
+	sprintf(buf, "%s=%s", flash_layout, sas_flash_layout_name(layout));
+	sas_setenv(flash_layout, buf, save_env);
+}
+
+static void sas_env_compat_set(int *save_env)
+{
+	sas_setenv("cfg_version", "20", save_env);
+	sas_setenv("uboot_name", CONFIG_IDENT_STRING, save_env);
+	sas_setenv("uboot_version", PLAIN_VERSION, save_env);
+	sas_setenv("uboot_builddate", U_BOOT_DATE " " U_BOOT_TIME, save_env);
+}
+
+static void sas_env_bootargs_add(const char *value)
+{
+	sas_run_command("setenv bootargs $bootargs %s", value);
+}
+
+static void sas_env_bootargs_init(int ptest_mode)
+{
+	sas_env_bootargs_add("console=$consoledev,$baudrate");
+	sas_env_bootargs_add("ip=$ipaddr:$serverip::::$netdev:off");
+	sas_env_bootargs_add("ethaddr=$ethaddr");
+	sas_env_bootargs_add("machtype=" CONFIG_MACH_TYPE);
+	sas_env_bootargs_add("$kernelcmdline $mtdparts $flash_layout");
+	sas_env_bootargs_add("$rootfs $servicefs $defconfig");
+
+	if (ptest_mode)
+		sas_env_bootargs_add("ptest=1");
+}
+
+static void sas_env_save(int status)
+{
+#if 1
+	if (status | getenv_ulong("sas_saveenv", 10, 0))
+		sas_saveenv();
+#endif
+}
+
+static int sas_bootm(ulong addr)
+{
+#if 0
+	printf("\nbootm start %08lx\n", addr);
+	puts("bootm loados\n");
+	puts("bootm ramdisk\n");
+	puts("bootm cmdline\n");
+	puts("bootm prep\n");
+	puts("bootm go\n");
+	return 0;
+#else
+	int ret;
+
+	ret = sas_run_command("bootm start %08lx", addr);
+	if (ret)
+		return ret;
+
+	ret = sas_run_command("bootm loados");
+	if (ret)
+		return ret;
+
+	ret = sas_run_command("bootm ramdisk");
+	if (ret)
+		return ret;
+
+	sas_run_command("bootm cmdline");
+	sas_run_command("bootm prep");
+	sas_run_command("bootm go");
+
+	return 0;
+#endif
+}
+
+static int sas_check_ptest(enum sas_flash_layout_type flash_layout,
+				enum sas_image_src_type kernel,
+				enum sas_image_src_type rootfs,
+				enum sas_image_src_type servicefs)
+{
+	const char *etl_serial_no, *ethaddr;
+
+	/* Enable PTEST if requested by user */
+	if (servicefs == SAS_PTEST)
+		return 1;
+
+	/* Auto-detect PTEST mode only if all images are booted from flash */
+	if (kernel != SAS_FLASH)
+		return 0;
+
+	if (rootfs != SAS_FLASH)
+		return 0;
+
+	/* no PTEST if flash layout is not bootable */
+	if (!sas_flash_layout_is_bootable(flash_layout))
+		return 0;
+
+	/* no PTEST if servicefs is not booted from flash */
+	if (sas_flash_layout_has_service_images(flash_layout) &&
+		servicefs != SAS_FLASH)
+		return 0;
+
+	/*
+	 * No PTEST if serial number is already set or first char is
+	 * different from SAS_ETL_VARIABLE_EMPTY_CHAR
+	 */
+	etl_serial_no = sas_etl_get_string(SAS_ETL_SERIAL);
+	if (etl_serial_no && strlen(etl_serial_no))
+		return 0;
+
+	/* No PTEST if current ethaddr does not differ from default ethaddr */
+	ethaddr = getenv("ethaddr");
+	if (strncmp(ethaddr, __stringify(CONFIG_ETHADDR), 17))
+		return 0;
+
+	return 1;
+}
+
+static int sas_bootlogic_active(enum sas_flash_layout_type flash_layout,
+				enum sas_image_src_type kernel,
+				enum sas_image_src_type rootfs,
+				enum sas_image_src_type servicefs)
+{
+	if (kernel != SAS_FLASH)
+		return 0;
+
+	if (rootfs != SAS_FLASH)
+		return 0;
+
+	if (servicefs == SAS_PTEST)
+		return 1;
+
+	if (sas_flash_layout_has_service_images(flash_layout) &&
+		servicefs == SAS_FLASH)
+		return 1;
+
+	return 0;
+}
+
+static int do_sas_boot(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	const char *kernel_src, *rootfs_src, *servicefs_src;
+	const enum sas_flash_layout_type flash_layout = sas_flash_layout_current();
+	enum sas_image_src_type kernel, rootfs, servicefs;
+	ulong loadaddr;
+	int ret = 0, save_env = 0;
+	int boot_logic, ptest_mode, can_boot;
+	int retry, active_image;
+
+	if (!sas_etl_version()) {
+		printf("Cannot boot without Sphairon typelabel\n");
+		ret = 1;
+		return 1;
+	}
+
+	if (argc == 4) {
+		kernel_src = argv[1];
+		rootfs_src = argv[2];
+		servicefs_src = argv[3];
+	} else if (argc == 1) {
+		kernel_src = getenv("kernel_src");
+		rootfs_src = getenv("rootfs_src");
+		servicefs_src = getenv("servicefs_src");
+	} else
+		return CMD_RET_USAGE;
+
+	kernel = sas_parse_image_src(kernel_src, SAS_FLASH);
+	rootfs = sas_parse_image_src(rootfs_src, SAS_FLASH);
+	servicefs = sas_parse_image_src(servicefs_src, SAS_FLASH);
+
+	if (kernel == SAS_INVALID || rootfs == SAS_INVALID ||
+		servicefs == SAS_INVALID)
+		return CMD_RET_USAGE;
+
+	ptest_mode = sas_check_ptest(flash_layout, kernel, rootfs, servicefs);
+
+	/* Fixup servicefs mode if ptest auto-detection sets ptest_mode to 1 */
+	if (ptest_mode && servicefs != SAS_PTEST) {
+		servicefs = SAS_PTEST;
+		if (!servicefs_src)
+			sas_image_src_set("servicefs_src", servicefs, &save_env);
+	}
+
+	loadaddr = getenv_ulong("loadaddr", 16, 0);
+	boot_logic = sas_bootlogic_active(flash_layout, kernel, rootfs,
+						servicefs);
+
+	printf("Booting with: kernel %s, rootfs %s, servicefs %s, boot_logic %d ptest %d\n",
+		sas_image_src_str(kernel), sas_image_src_str(rootfs),
+		sas_image_src_str(servicefs), boot_logic, ptest_mode);
+
+	/* Handle persistent env variables */
+	sas_env_bootargs_clear();
+	sas_env_flashlayout_set(flash_layout, &save_env);
+	sas_env_compat_set(&save_env);
+
+	retry = 0;
+	can_boot = 1;
+	do {
+		/*
+		 * If active_image is equal to 0 then no partition contains the
+		 * complete set of boot images (kernel + different rootfs types).
+		 * Otherwise the partition index in range 1..max_partitions
+		 * is returned.
+		 */
+		active_image = sas_boot_find_working_image(flash_layout);
+		/*
+		 * Abort immediately if boot logic is enabled and
+		 * no active images could be found.
+		 */
+		if (boot_logic && !active_image) {
+			can_boot = 0;
+			break;
+		}
+
+		/* Load kernel from flash or via TFTP */
+		ret = sas_kernel_load(active_image, kernel, loadaddr);
+		if (ret)
+			return 1;
+
+		ret = sas_servicefs_load(flash_layout, active_image, servicefs);
+		if (ret)
+			return 1;
+
+		if (boot_logic && active_image && !ptest_mode)
+			can_boot = sas_boot_update_states(active_image, &retry,
+								&save_env);
+	} while (retry);
+
+	if (!can_boot) {
+		puts("Invalid or incomplete images available for boot\n");
+		return 1;
+	}
+
+	sas_etl_env_save(&save_env);
+	sas_env_save(save_env);
+
+	ret = sas_mtdparts_update(flash_layout, active_image, rootfs,
+		servicefs);
+	if (ret) {
+		puts("Failed to init mtdparts\n");
+		return 1;
+	}
+
+	/* Handle transient env variables */
+	sas_env_console_init(loadaddr);
+	sas_env_fs_args_init(active_image, rootfs, servicefs);
+	sas_env_bootargs_init(ptest_mode);
+
+	/* Perform boot */
+	return sas_bootm(loadaddr);
+}
+
+U_BOOT_CMD(sas_boot, 4, 1, do_sas_boot,
+	"Sphairon kernel and rootfs loader",
+	"[kernel_src rootfs_src servicefs_src] \n"
+	"    - kernel_src = [flash|tftp]\n"
+	"    - rootfs_src = [flash|tftp|nfs|none]\n"
+	"    - servicefs_src = [flash|tftp|nfs|none|ptest]\n");
diff --git a/lib/sphairon/cmd_sas_controlfile.c b/lib/sphairon/cmd_sas_controlfile.c
new file mode 100644
index 0000000000000000000000000000000000000000..547246503cfa593866c1c69edac5b63998ed3d47
--- /dev/null
+++ b/lib/sphairon/cmd_sas_controlfile.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <hush.h>
+#include <malloc.h>
+#include <sas/controlfile.h>
+#include <sas/util.h>
+
+#define SAS_CF_FILENAME		"control.script"
+
+static int do_sas_controlfile(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	size_t size;
+	unsigned long loadaddr;
+	int ret;
+	char *cmd;
+
+	loadaddr = getenv_ulong("loadaddr", 16, 0);
+	size = sas_run_tftpboot(loadaddr, SAS_CF_FILENAME);
+	if (!size) {
+		ret = -1;
+		goto done;
+	}
+
+	cmd = malloc(size + 1);
+	if (!cmd) {
+		ret = -1;
+		goto done;
+	}
+
+	memmove(cmd, (char *)loadaddr, size);
+	cmd[size] = 0;
+
+	ret = parse_string_outer(cmd, FLAG_PARSE_SEMICOLON);
+	free(cmd);
+
+done:
+	sas_cf_status_board(ret ? CF_FAILED : CF_FINISHED);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_controlfile, 1, 0, do_sas_controlfile,
+	   "Sphairon control file execution", NULL);
diff --git a/lib/sphairon/cmd_sas_etl.c b/lib/sphairon/cmd_sas_etl.c
new file mode 100644
index 0000000000000000000000000000000000000000..a6ac684d718c7871e6d07edcbbdd3c5d467e60e6
--- /dev/null
+++ b/lib/sphairon/cmd_sas_etl.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+#define DEBUG
+#include <common.h>
+#include <command.h>
+#include <sas/flash.h>
+#include <sas/etl.h>
+
+static int parse_loadaddr(int argc, const char *value, unsigned long *loadaddr)
+{
+	if (argc == 2)
+		strict_strtoul(value, 16, loadaddr);
+	else if (argc == 1)
+		*loadaddr = getenv_ulong("loadaddr", 16, CONFIG_LOADADDR);
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+static int do_etl_import(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	unsigned long loadaddr;
+	int ret;
+
+	ret = parse_loadaddr(argc, argv[1], &loadaddr);
+	if (ret)
+		return ret;
+
+	ret = sas_etl_import(loadaddr);
+	if (ret)
+		return ret;
+
+	sas_etl_env_set_ethaddr(NULL);
+
+	return 0;
+}
+
+static int do_etl_export(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	unsigned long loadaddr;
+	int ret;
+
+	ret = parse_loadaddr(argc, argv[1], &loadaddr);
+	if (ret)
+		return ret;
+
+	return sas_etl_export(loadaddr);
+}
+
+static int do_etl_read(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	unsigned long loadaddr;
+	int ret;
+
+	ret = parse_loadaddr(argc, argv[1], &loadaddr);
+	if (ret)
+		return ret;
+
+	return sas_etl_flash_read(loadaddr);
+}
+
+static int do_etl_write(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	unsigned long loadaddr;
+	int ret;
+
+	ret = parse_loadaddr(argc, argv[1], &loadaddr);
+	if (ret)
+		return ret;
+
+	return sas_etl_flash_write(loadaddr);
+}
+
+static int do_etl_set(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	enum sas_etl_id idx;
+	unsigned long val;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	idx = sas_etl_id_parse(argv[1]);
+	if (idx == SAS_ETL_ID_LAST) {
+		printf("invalid id: %s\n", argv[1]);
+		return CMD_RET_FAILURE;
+	}
+
+	if (sas_etl_is_hex(idx)) {
+		strict_strtoul(argv[2], 16, &val);
+		sas_etl_set_hex(idx, sas_etl_hex_size(idx), val);
+	} else
+		sas_etl_set_string(idx, argv[2]);
+
+	return 0;
+}
+
+static int do_etl_get(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	enum sas_etl_id idx;
+	const char *val;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	idx = sas_etl_id_parse(argv[1]);
+	if (idx == SAS_ETL_ID_LAST) {
+		printf("invalid id: %s\n", argv[1]);
+		return CMD_RET_FAILURE;
+	}
+
+	val = sas_etl_get_string(idx);
+	printf("%s\n", val);
+
+	return 0;
+}
+
+static int do_etl_save(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	unsigned long loadaddr;
+	int ret;
+
+	parse_loadaddr(1, NULL, &loadaddr);
+
+	ret = sas_etl_export(loadaddr);
+	if (ret)
+		return ret;
+
+	sas_flash_verbose_set(1);
+	ret = sas_etl_flash_write(loadaddr);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+static int do_etl_dump(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	sas_etl_dump();
+
+	return 0;
+}
+
+static cmd_tbl_t cmd_etl_sub[] = {
+	U_BOOT_CMD_MKENT(import, 2, 0, do_etl_import, "", ""),
+	U_BOOT_CMD_MKENT(export, 2, 0, do_etl_export, "", ""),
+	U_BOOT_CMD_MKENT(read, 2, 0, do_etl_read, "", ""),
+	U_BOOT_CMD_MKENT(write, 2, 0, do_etl_write, "", ""),
+	U_BOOT_CMD_MKENT(save, 1, 0, do_etl_save, "", ""),
+	U_BOOT_CMD_MKENT(dump, 1, 0, do_etl_dump, "", ""),
+	U_BOOT_CMD_MKENT(set, 3, 0, do_etl_set, "", ""),
+	U_BOOT_CMD_MKENT(get, 2, 0, do_etl_get, "", ""),
+};
+
+static int do_sas_etl(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	cmd_tbl_t *cp;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	/* drop initial "sas_etl" arg */
+	argc--;
+	argv++;
+
+	cp = find_cmd_tbl(argv[0], cmd_etl_sub, ARRAY_SIZE(cmd_etl_sub));
+	if (!cp)
+		return CMD_RET_USAGE;
+
+	return cp->cmd(cmdtp, flag, argc, argv);
+}
+
+U_BOOT_CMD(sas_etl, CONFIG_SYS_MAXARGS, 0, do_sas_etl,
+	"Sphairon ETL commands",
+	"import [addr] - import ETL at [addr]\n"
+	"sas_etl export [addr] - export ETL to [addr]\n"
+	"sas_etl read [addr] - read ETL from flash to [addr]\n"
+	"sas_etl write [addr] - write ETL at [addr] to flash\n"
+	"sas_etl save - save current ETL values to flash\n"
+	"sas_etl dump - dump ETL values\n"
+	"sas_etl set <id|name> <value> - set new <value> for <id|name>\n"
+	"sas_etl get <id|name> - get value for <id|name>\n");
diff --git a/lib/sphairon/cmd_sas_test_sf.c b/lib/sphairon/cmd_sas_test_sf.c
new file mode 100644
index 0000000000000000000000000000000000000000..6fde7116c0fba5820c5509c584aad18a38693173
--- /dev/null
+++ b/lib/sphairon/cmd_sas_test_sf.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <command.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <asm/io.h>
+
+static int sas_test_4byte_mode(const struct spi_flash *sf)
+{
+	if (sf->size > (1 << 24))
+		return 1;
+
+	return 0;
+}
+
+static int do_sas_test_sf(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	struct spi_flash *sf;
+	const ulong ram_addr = CONFIG_SYS_SDRAM_BASE;
+	ulong sf_addr_lo, sf_addr_hi;
+	const uint32_t pattern_len = 0x20;
+	volatile uint8_t *p8;
+	void *p;
+	int i, j, ret = 0;
+	char c;
+
+	puts(">>> Caution: this test program erases some flash sectors!");
+	for (;;) {
+		puts("\n>>> Do you want to continue (y|n)? :");
+		c = getc();
+		if (c == 'y')
+			break;
+		if (c == 'n') {
+			puts("\n");
+			return 0;
+		}
+	}
+
+	sf = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (!sf)
+		return -1;
+
+	sf_addr_lo = 6 * sf->sector_size;
+	sf_addr_hi = sf_addr_lo + 0x1000000;
+
+	p8 = (volatile uint8_t *)ram_addr;
+	printf("\n>>> Init pattern in RAM @ %p\n", p8);
+	for (i = 0; i < pattern_len; i++) {
+		j = 4;
+		while (j--)
+			*p8++ = i;
+	}
+
+	p = (void *)ram_addr;
+	print_buffer(ram_addr, p, 4, pattern_len, 0);
+
+	printf(">>> Erasing flash at offset %04lx and len %04x\n", sf_addr_lo, sf->sector_size);
+	ret = spi_flash_erase(sf, sf_addr_lo, sf->sector_size);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	printf(">>> Write pattern to flash at offset %04lx\n", sf_addr_lo);
+	ret = spi_flash_write(sf, sf_addr_lo, 4 * pattern_len, (const void *)ram_addr);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	p += 4 * pattern_len;
+	printf(">>> Read back pattern from flash @ %04lx to RAM @ %p\n", sf_addr_lo, p);
+	ret = spi_flash_read(sf, sf_addr_lo, 4 * pattern_len, p);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	print_buffer((ulong)p, p, 4, pattern_len, 0);
+
+	if (!sas_test_4byte_mode(sf)) {
+		puts(">>> Skipping 4-byte addressing test\n");
+		ret = 0;
+		goto out;
+	}
+
+	printf(">>> Erasing flash at offset %04lx and len %04x\n", sf_addr_hi, sf->sector_size);
+	ret = spi_flash_erase(sf, sf_addr_hi, sf->sector_size);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	printf(">>> Write pattern to flash at offset %04lx\n", sf_addr_hi);
+	ret = spi_flash_write(sf, sf_addr_hi, 4 * pattern_len, (const void *)ram_addr);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	p += 4 * pattern_len;
+	printf(">>> Read back pattern from flash @ %04lx to RAM @ %p\n", sf_addr_hi, p);
+	ret = spi_flash_read(sf, sf_addr_hi, 4 * pattern_len, p);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	print_buffer((ulong)p, p, 4, pattern_len, 0);
+
+out:
+	spi_flash_free(sf);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_test_sf, 1, 0, do_sas_test_sf,
+	   "Sphairon test program for SPI flash", NULL);
diff --git a/lib/sphairon/cmd_sas_upgrade.c b/lib/sphairon/cmd_sas_upgrade.c
new file mode 100644
index 0000000000000000000000000000000000000000..b69928fd602aa751c710d4f3f8713ee9850932b8
--- /dev/null
+++ b/lib/sphairon/cmd_sas_upgrade.c
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+#include <sas/boot.h>
+#include <sas/etl.h>
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+#define SAS_UBOOT_USED		SAS_UBOOT_LZO_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_LZO_IMAGE
+#elif defined(CONFIG_LTQ_SPL_COMP_LZMA)
+#define SAS_UBOOT_USED		SAS_UBOOT_LZMA_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_LZMA_IMAGE
+#else
+#define SAS_UBOOT_USED		SAS_UBOOT_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_IMAGE
+#endif
+#else
+#define SAS_UBOOT_USED		SAS_UBOOT_BIN
+#define SAS_UBOOT_ALT		SAS_UBOOT_IMAGE
+#endif
+
+static int sas_upgrade_images_load(const char *name1, ulong *addr1,
+					size_t *size1, const char *name2,
+					ulong *addr2, size_t *size2)
+{
+	ulong loadaddr;
+	size_t size;
+
+	loadaddr = getenv_ulong("loadaddr", 16, 0);
+
+	size = sas_run_tftpboot(loadaddr, name1);
+	if (!size)
+		goto err;
+
+	*addr1 = loadaddr;
+	*size1 = size;
+
+	debug("addr1 %08lx, size1 %zu\n", *addr1, *size1);
+
+	if (!name2)
+		return 0;
+
+	loadaddr += size + 1;
+	loadaddr = ROUND(loadaddr, 32);
+
+	size = sas_run_tftpboot(loadaddr, name2);
+	if (!size)
+		goto err;
+
+	*addr2 = loadaddr;
+	*size2 = size;
+
+	debug("addr2 %08lx, size2 %zu\n", *addr2, *size2);
+
+	return 0;
+
+err:
+	puts("Could not load images\n");
+
+	return 1;
+}
+
+static int sas_upgrade_image_load(cmd_tbl_t * cmdtp, int argc,
+					char *const argv[], const char *image,
+					ulong *addr, size_t *size)
+{
+	int ret;
+	ulong val;
+
+	if (argc == 1) {
+		return sas_upgrade_images_load(image, addr, size,
+						NULL, NULL, NULL);
+	} else if (argc == 3) {
+		ret = strict_strtoul(argv[1], 16, &val);
+		if (ret)
+			return 1;
+
+		*addr = val;
+
+		ret = strict_strtoul(argv[2], 16, &val);
+		if (ret)
+			return 1;
+
+		if (!val) {
+			printf("Invalid size %08zx\n", *size);
+			return 1;
+		}
+
+		*size = val;
+
+		return 0;
+	}
+
+	return cmd_usage(cmdtp);
+}
+
+static int sas_upgrade_image_check(ulong addr, sas_image_type_t image_type)
+{
+	int ret;
+	sas_image_type_t type;
+	const image_header_t *hdr = (const image_header_t *) addr;
+
+	type = sas_image_type(hdr);
+	if (type != image_type) {
+		puts("invalid image type\n");
+		return 0;
+	}
+
+	ret = sas_run_command("iminfo %p", hdr);
+	if (ret)
+		return 0;
+
+	return 1;
+}
+
+static int sas_upgrade_check_forced(int argc, char *const argv[])
+{
+	return (argc == 2 || argc == 4) && !strcmp(argv[1], "-f");
+}
+
+static int do_sas_upgrade_uboot(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	ulong loadaddr, cd_offset;
+	size_t size;
+	int ret;
+
+	if (sas_upgrade_check_forced(argc, argv)) {
+		argc--;
+		argv++;
+	} else {
+		ret = sas_confirm("Caution: this can damage your board");
+		if (!ret)
+			return 0;
+	}
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_UBOOT_USED,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	if (size >= part->size) {
+		puts("Image size too big\n");
+		return 1;
+	}
+
+	cd_offset = sas_flash_cd_offset(part);
+	if (size >= cd_offset) {
+		puts("Image size leads to overwriting of CD/ETL area\n");
+		return 1;
+	}
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_complete_write(part, 0, size, size,
+					(const void *) loadaddr, 1);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_uboot, 4, 0, do_sas_upgrade_uboot,
+	"Update U-Boot in flash", "[-f] [addr size]\n");
+
+static __maybe_unused int do_sas_upgrade_uboot_alt(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	ulong loadaddr;
+	size_t size;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_UPDATE);
+	if (!part)
+		return 1;
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_UBOOT_ALT,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	if (size >= part->size) {
+		puts("Image size too big\n");
+		return 1;
+	}
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_complete_write(part, 0, size, size,
+					(const void *) loadaddr, 0);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+#ifndef CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+U_BOOT_CMD(sas_upgrade_uboot_alt, 3, 0, do_sas_upgrade_uboot_alt,
+	"Update alternate U-Boot in flash", "[addr] [size]\n");
+#endif
+
+static __maybe_unused int do_sas_erase_uboot_alt(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_UPDATE);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_erase(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+#ifndef CONFIG_SPHAIRON_NO_UBOOT_UPDATE
+U_BOOT_CMD(sas_erase_uboot_alt, 1, 0, do_sas_erase_uboot_alt,
+	"Erase second U-Boot in flash", "");
+#endif
+
+static int do_sas_upgrade_etl(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	ulong loadaddr;
+	size_t size;
+	int ret;
+
+	if (sas_upgrade_check_forced(argc, argv)) {
+		argc--;
+		argv++;
+	} else {
+		ret = sas_confirm("Caution: this can damage your board");
+		if (!ret)
+			return 0;
+	}
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_TYPELABEL_BIN,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	ret = sas_etl_import(loadaddr);
+	if (ret)
+		return ret;
+
+	sas_flash_verbose_set(1);
+	ret = sas_etl_flash_write(loadaddr);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_etl, 4, 0, do_sas_upgrade_etl,
+	"Update ETL in flash", "[-f] [addr size]\n");
+
+static int do_sas_erase_etl(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	int ret;
+
+	if (!sas_upgrade_check_forced(argc, argv)) {
+		ret = sas_confirm("Caution: this can damage your board");
+		if (!ret)
+			return 0;
+	}
+
+	sas_flash_verbose_set(1);
+	ret = sas_etl_flash_erase();
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_etl, 2, 0, do_sas_erase_etl,
+	"Erase ETL in flash", "[-f]");
+
+static int do_sas_erase_uboot_cfg(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_CFG);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_unlock(part, 0, part->size);
+	if (ret)
+		return 1;
+
+	ret = sas_flash_erase(part, 0, part->size);
+
+	sas_flash_lock(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_uboot_cfg, 1, 0, do_sas_erase_uboot_cfg,
+	"Erase U-Boot config in flash", "");
+
+static void sas_upgrade_index(int argc, char *const argv[], int *index)
+{
+	int ret;
+	ulong val;
+
+	if (argc == 1) {
+		*index = 0;
+		return;
+	}
+
+	ret = strict_strtoul(argv[1], 10, &val);
+	if (ret) {
+		*index = -1;
+		return;
+	}
+
+	*index = val - 1;
+}
+
+static int do_sas_upgrade_platform(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int index = 0, ret;
+	ulong uimage_srcaddr, uimage_dstaddr;
+	ulong rootfs_srcaddr, rootfs_dstaddr;
+	size_t uimage_size, rootfs_size, erase_len;
+
+	sas_upgrade_index(argc, argv, &index);
+	part = sas_flash_layout_image_partition(index);
+	if (!part) {
+		puts("Invalid index or partition\n");
+		return 1;
+	}
+
+	debug("using partition %s\n", part->mtd->name);
+
+	ret = sas_upgrade_images_load(SAS_KERNEL_IMAGE, &uimage_srcaddr,
+					&uimage_size, SAS_ROOTFS_IMAGE,
+					&rootfs_srcaddr, &rootfs_size);
+	if (ret)
+		return ret;
+
+	ret = sas_upgrade_image_check(uimage_srcaddr, SAS_IMG_KERNEL);
+	if (!ret)
+		return 1;
+
+	ret = sas_upgrade_image_check(rootfs_srcaddr, SAS_IMG_ROOTFS);
+	if (!ret)
+		return 1;
+
+	ret = sas_boot_layout_platform(part, uimage_size, rootfs_size,
+					&uimage_dstaddr, &rootfs_dstaddr,
+					&erase_len);
+	if (ret)
+		return ret;
+
+	sas_boot_invalidate_image_state(index + 1);
+
+	ret = sas_boot_invalidate_platform_images(part);
+	if (ret)
+		return ret;
+
+	sas_flash_verbose_set(1);
+
+	ret = sas_flash_complete_write(part, uimage_dstaddr, uimage_size,
+					erase_len,
+					(const void *) uimage_srcaddr, 0);
+	if (ret)
+		goto done;
+
+	ret = sas_flash_write(part, rootfs_dstaddr, rootfs_size,
+				(const void *) rootfs_srcaddr);
+
+done:
+	sas_flash_verbose_set(0);
+	ret = sas_boot_scan_images(NULL);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_platform, 2, 0, do_sas_upgrade_platform,
+	"Update kernel and rootfs in flash", "[index]");
+
+static int do_sas_upgrade_service(cmd_tbl_t * cmdtp, int flag,
+					int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int index = 0, ret;
+	ulong servicefs_srcaddr, servicefs_dstaddr;
+	ulong configfs_srcaddr, configfs_dstaddr;
+	size_t servicefs_size, configfs_size, erase_len;
+
+	sas_upgrade_index(argc, argv, &index);
+	part = sas_flash_layout_image_partition(index);
+	if (!part) {
+		puts("Invalid index or partition\n");
+		return 1;
+	}
+
+	debug("using partition %s\n", part->mtd->name);
+
+	ret = sas_upgrade_images_load(SAS_SERVICEFS_IMAGE, &servicefs_srcaddr,
+					&servicefs_size, SAS_CONFIGFS_IMAGE,
+					&configfs_srcaddr, &configfs_size);
+	if (ret)
+		return ret;
+
+	ret = sas_upgrade_image_check(servicefs_srcaddr, SAS_IMG_SERVICEFS);
+	if (!ret)
+		return 1;
+
+	ret = sas_upgrade_image_check(configfs_srcaddr, SAS_IMG_DEFCONFIG);
+	if (!ret)
+		return 1;
+
+	ret = sas_boot_layout_service(part, servicefs_size, configfs_size,
+					&servicefs_dstaddr, &configfs_dstaddr,
+					&erase_len);
+	if (ret)
+		return ret;
+
+	sas_boot_invalidate_image_state(index + 1);
+
+	ret = sas_boot_invalidate_service_images(part);
+	if (ret)
+		return ret;
+
+	sas_flash_verbose_set(1);
+
+	ret = sas_flash_complete_write(part, servicefs_dstaddr, servicefs_size,
+					erase_len,
+					(const void *) servicefs_srcaddr, 0);
+	if (ret)
+		goto done;
+
+	ret = sas_flash_write(part, configfs_dstaddr, configfs_size,
+				(const void *) configfs_srcaddr);
+
+done:
+	sas_flash_verbose_set(0);
+	ret = sas_boot_scan_images(NULL);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_service, 2, 0, do_sas_upgrade_service,
+	"Update servicefs and defconfig in flash", "[index]");
+
+static int do_sas_erase_syscfg(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	enum sas_flash_part_type part_type;
+	int index = 0, ret;
+
+	sas_upgrade_index(argc, argv, &index);
+
+	switch (index) {
+	case 0:
+		part_type = SAS_PART_SYSCFG1;
+		break;
+	case 1:
+		part_type = SAS_PART_SYSCFG2;
+		break;
+	default:
+		puts("Invalid index\n");
+		return 1;
+	}
+
+	part = sas_flash_part_find(part_type);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_erase(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_syscfg, 2, 0, do_sas_erase_syscfg,
+	"Erase sysconfig in flash", "[index]");
+
+static int do_sas_erase_images(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	enum sas_flash_part_type part_type;
+	int index = 0, ret;
+
+	sas_upgrade_index(argc, argv, &index);
+
+	switch (index) {
+	case 0:
+		part_type = SAS_PART_IMAGES1;
+		break;
+	case 1:
+		part_type = SAS_PART_IMAGES2;
+		break;
+	default:
+		puts("Invalid index\n");
+		return 1;
+	}
+
+	part = sas_flash_part_find(part_type);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_erase(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_images, 2, 0, do_sas_erase_images,
+	"Erase images partition in flash", "[index]");
+
+static int do_sas_erase_data(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_DATA);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_erase(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_data, 1, 0, do_sas_erase_data,
+	"Erase data partition in flash", "");
diff --git a/lib/sphairon/controlfile.c b/lib/sphairon/controlfile.c
new file mode 100644
index 0000000000000000000000000000000000000000..7326320a204c8e2046878ef364a7eb7c1a621602
--- /dev/null
+++ b/lib/sphairon/controlfile.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <watchdog.h>
+#include <linux/compiler.h>
+
+#include <sas/controlfile.h>
+
+__weak int sas_cf_check_board(void)
+{
+	return 0;
+}
+
+void sas_cf_status_board(enum sas_cf_state state)
+{
+	puts("control file ");
+
+	switch (state) {
+	case CF_STARTED:
+		puts("started\n");
+		sas_cf_led_action(CF_STARTED);
+		break;
+	case CF_FINISHED:
+		puts("finished\n");
+		sas_cf_led_action(CF_FINISHED);
+		break;
+	case CF_FAILED:
+		puts("failed\n");
+		sas_cf_led_action(CF_FAILED);
+		break;
+	}
+}
+
+__weak void sas_cf_led_action(enum sas_cf_state state)
+{
+	return;
+}
+
+static int sas_cf_debounce(unsigned long interval)
+{
+	unsigned long timebase = get_timer(0);
+
+	while (sas_cf_check_board()) {
+		WATCHDOG_RESET();
+
+		if (get_timer(timebase) > interval)
+			return 1;
+	}
+
+	return 0;
+}
+
+void sas_cf_run(void)
+{
+	int status;
+
+	status = sas_cf_debounce(2000);
+	if (!status)
+		return;
+
+	setenv("bootcmd", "sas_controlfile");
+	setenv("bootdelay", "2");
+}
+
+int sas_cf_is_active(void)
+{
+	const char *bootcmd = getenv("bootcmd");
+
+	if (!bootcmd)
+		return 0;
+
+	if (!strcmp(bootcmd, "sas_controlfile"))
+	{
+		sas_cf_status_board(CF_STARTED);
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/lib/sphairon/etl.c b/lib/sphairon/etl.c
new file mode 100644
index 0000000000000000000000000000000000000000..7f395c30936b785f223bf17b2d7c87a3baafe975
--- /dev/null
+++ b/lib/sphairon/etl.c
@@ -0,0 +1,658 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/compiler.h>
+
+#include <sas/etl.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+
+struct sas_etl_map_entry {
+	struct list_head link;
+	enum sas_etl_id idx;
+	char val[SAS_ETL_MAX_VALUE_CHARS];
+};
+
+static struct list_head sas_etl_map;
+static int sas_etl_ver;
+
+int sas_etl_init(void)
+{
+	const unsigned long addr = CONFIG_LOADADDR;
+	int ret;
+
+	INIT_LIST_HEAD(&sas_etl_map);
+
+	ret = sas_etl_flash_read(addr);
+	if (ret)
+		return ret;
+
+	return sas_etl_import(addr);
+}
+
+int sas_etl_flash_read(unsigned long addr)
+{
+	const struct sas_flash_partition *part;
+	void *buf = (void *)addr;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	return sas_flash_read(part, sas_flash_etl_offset(part),
+		SAS_ETL_V2_SIZE, buf);
+}
+
+int sas_etl_flash_write(unsigned long addr)
+{
+	const struct sas_flash_partition *part;
+	const void *buf = (const void *)addr;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	ret = sas_flash_complete_write(part, sas_flash_etl_offset(part),
+		SAS_ETL_V2_SIZE, SAS_ETL_V2_SIZE, buf, 1);
+
+	return ret;
+}
+
+int sas_etl_flash_erase(void)
+{
+	const struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	ret = sas_flash_unlock(part, 0, part->size);
+	if (ret)
+		return 1;
+
+	ret = sas_flash_partial_erase(part, sas_flash_etl_offset(part),
+		SAS_ETL_V2_SIZE);
+
+	sas_flash_lock(part, 0, part->size);
+
+	return ret;
+}
+
+static struct sas_etl_map_entry *
+sas_etl_entry_create(enum sas_etl_id idx)
+{
+	struct sas_etl_map_entry *entry;
+
+	entry = malloc(sizeof(*entry));
+	if (!entry) {
+		debug("%s: failed to create entry\n", __func__);
+		return NULL;
+	}
+
+	memset(entry, 0, sizeof(*entry));
+	INIT_LIST_HEAD(&entry->link);
+	entry->idx = idx;
+
+	debug("%s: creating entry %d\n", __func__, entry->idx);
+
+	return entry;
+}
+
+static void sas_etl_entry_add(struct sas_etl_map_entry *entry)
+{
+	debug("%s: adding entry %d\n", __func__, entry->idx);
+	list_add_tail(&entry->link, &sas_etl_map);
+}
+
+static struct sas_etl_map_entry *sas_etl_entry_find(enum sas_etl_id idx)
+{
+	struct sas_etl_map_entry *entry;
+
+	if (!idx || idx >= SAS_ETL_ID_LAST)
+		return NULL;
+
+	list_for_each_entry(entry, &sas_etl_map, link) {
+		if (idx == entry->idx)
+			return entry;
+	}
+
+	return NULL;
+}
+
+static struct sas_etl_map_entry *
+sas_etl_entry_find_or_create(enum sas_etl_id idx)
+{
+	struct sas_etl_map_entry *entry = sas_etl_entry_find(idx);
+
+	if (entry)
+		return entry;
+
+	entry = sas_etl_entry_create(idx);
+	if (!entry)
+		return NULL;
+
+	sas_etl_entry_add(entry);
+
+	return entry;
+}
+
+static void sas_etl_entries_clear(void)
+{
+	struct sas_etl_map_entry *entry;
+	struct list_head *pos, *q;
+
+	sas_etl_ver = 0;
+
+	list_for_each_safe(pos, q, &sas_etl_map) {
+		entry = list_entry(pos, struct sas_etl_map_entry, link);
+		debug("%s: deleting entry %d\n", __func__, entry->idx);
+		list_del(pos);
+		free(entry);
+	}
+}
+
+int sas_etl_import(unsigned long addr)
+{
+	const u8 *buf = (const u8 *)addr;
+	struct sas_etl_map_entry *entry;
+	u8 idx, len;
+
+	sas_etl_entries_clear();
+
+	/* Check for empty flash and ETL version */
+	if (buf[0] == 0xff || buf[SAS_ETL_V2_SIZE - 1] == 0xff) {
+		debug("%s: empty flash\n", __func__);
+		return 0;
+	}
+
+	if (buf[SAS_ETL_V2_SIZE - 1] == 0x1) {
+		debug("%s: ETL v2\n", __func__);
+		sas_etl_ver = 2;
+	} else {
+		debug("%s: invalid ETL version\n", __func__);
+		return 0;
+	}
+
+	do {
+		idx = *buf++;
+		len = *buf++;
+
+		debug("%s: idx %u, len %u\n", __func__, idx, len);
+
+		/* end of ETL reached */
+		if (!idx && !len)
+			return 0;
+
+		if (idx >= SAS_ETL_ID_LAST) {
+			debug("%s: invalid idx %u\n", __func__, idx);
+			return 1;
+		}
+
+		if (len >= SAS_ETL_MAX_VALUE_CHARS) {
+			debug("%s: invalid len %u\n", __func__, len);
+			return 1;
+		}
+
+		entry = sas_etl_entry_create(idx);
+		if (!entry)
+			return 1;
+
+		memcpy(entry->val, buf, len);
+		sas_etl_entry_add(entry);
+
+		buf += len;
+	} while ((buf - (const u8 *)addr) < SAS_ETL_V2_SIZE);
+
+	return 0;
+}
+
+int sas_etl_export(unsigned long addr)
+{
+	u8 *buf = (u8 *)addr;
+	struct sas_etl_map_entry *entry;
+	u8 len;
+
+	memset(buf, 0, SAS_ETL_V2_SIZE);
+
+	list_for_each_entry(entry, &sas_etl_map, link) {
+		if (sas_etl_is_hex(entry->idx))
+			len = 4;
+		else
+			len = strlen(entry->val);
+
+		debug("%s: idx %u, len %u\n", __func__, entry->idx, len);
+
+		*buf++ = entry->idx;
+		*buf++ = len;
+		memcpy(buf, entry->val, len);
+		buf += len;
+	}
+
+	buf = (u8 *)addr;
+	buf[SAS_ETL_V2_SIZE - 1] = 0x1;
+
+	return 0;
+}
+
+static void sas_etl_env_set_default(enum sas_etl_id idx, const char *name,
+					const char *defval, int *save_env)
+{
+	const char *etl_val = sas_etl_get_string(idx);
+	const char *env_val;
+
+	if (etl_val)
+		env_val = etl_val;
+	else
+		env_val = defval;
+
+	sas_setenv(name, env_val, save_env);
+}
+
+static void sas_etl_env_set_fill(enum sas_etl_id idx, const char *name,
+				char fillval, size_t len, int *save_env)
+{
+	const char *etl_val = sas_etl_get_string(idx);
+	const char *env_val;
+	char tmp[40];
+
+	if (etl_val)
+		env_val = etl_val;
+	else {
+		memset(tmp, fillval, len);
+		tmp[len] = 0;
+		env_val = tmp;
+	}
+
+	sas_setenv(name, env_val, save_env);
+}
+
+void sas_etl_env_set_ethaddr(int *save_env)
+{
+	const char *val;
+	int i;
+
+	val = sas_etl_get_string(SAS_ETL_MAC_ADDR);
+	if (!val)
+		return;
+
+	if (17 != strlen(val))
+		return;
+
+	for (i = 2; i < 15; i += 3)
+		if (val[i] != ':')
+			return;
+
+	sas_setenv("ethaddr", val, save_env);
+}
+
+static void sas_etl_env_set_hwcfg(int *save_env)
+{
+	const char *val;
+	struct sas_hw_cfg hw_cfg;
+
+	val = sas_etl_get_string(SAS_ETL_HW_CFG);
+	if (!val)
+		return;
+
+	memcpy(&hw_cfg, val, sizeof(hw_cfg));
+
+	sas_setenv_num("etl_fxo", hw_cfg.FXO, save_env);
+	sas_setenv_num("etl_s0_ext", hw_cfg.S0_ext, save_env);
+	sas_setenv_num("etl_s0_int", hw_cfg.S0_int, save_env);
+	sas_setenv_num("etl_ab_count", hw_cfg.ab_count, save_env);
+	sas_setenv_num("etl_switch_ic", hw_cfg.switch_ic, save_env);
+	sas_setenv_num("etl_usb", hw_cfg.USB, save_env);
+	sas_setenv_num("etl_metering_hw", hw_cfg.metering_hw, save_env);
+}
+
+static void sas_etl_env_set_hwcfg2(int *save_env)
+{
+	const char *val;
+	struct sas_hw_cfg2 hw_cfg2;
+
+	val = sas_etl_get_string(SAS_ETL_HW_CFG2);
+	if (!val)
+		return;
+
+	memcpy(&hw_cfg2, val, sizeof(hw_cfg2));
+
+	sas_setenv_num("etl_fxs_ringvoltage", hw_cfg2.fxs_ringvoltage, save_env);
+	sas_setenv_num("etl_s0_int_count", hw_cfg2.S0_int_count, save_env);
+}
+
+static void sas_etl_env_set_bcd(enum sas_etl_id idx, const char *name,
+				int *save_env)
+{
+	unsigned long val;
+	char buf[16];
+
+	val = sas_etl_get_hex(idx, sas_etl_hex_size(idx));
+	sprintf(buf, "%0*lx", sas_etl_hex_size(idx) * 2, val);
+	sas_setenv(name, buf, save_env);
+}
+
+void sas_etl_env_save(int *save_env)
+{
+	if (!sas_etl_ver) {
+		sas_setenv_num("etl_exists", 0, save_env);
+		return;
+	}
+
+	sas_setenv_num("etl_exists", 1, save_env);
+
+	sas_etl_env_set_ethaddr(save_env);
+
+	sas_etl_env_set_default(SAS_ETL_TRIV_NAME, "etl_triv_name",
+		CONFIG_IDENT_STRING, save_env);
+
+	sas_etl_env_set_default(SAS_ETL_IDENT_NO, "etl_ident_no",
+		"0", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_BASE_PLATFORM, "etl_base_platform",
+		"0", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_FLASH_LAYOUT, "etl_flash_layout",
+		CONFIG_SPHAIRON_FLASHLAYOUT, save_env);
+
+	sas_etl_env_set_default(SAS_ETL_WLAN_SSID, "etl_wlan_ssid",
+		"default", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_WLAN_SSID_EXTRA, "etl_wlan_ssid_extra",
+		"default_extra", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_CUSTOMER, "etl_customer",
+		"Sphairon", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_MAC_ADDR_POOL, "etl_mac_addr_pool",
+		"8", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_DATA_PART_SIZE, "etl_data_part_size",
+		"10", save_env);
+
+	sas_etl_env_set_default(SAS_ETL_DATA_PART_LOC, "etl_data_part_loc",
+		"0", save_env);
+
+	sas_etl_env_set_bcd(SAS_ETL_WLANCFG, "etl_wlanconfig", save_env);
+	sas_etl_env_set_bcd(SAS_ETL_LEDCFG, "etl_led", save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_HW_VERSION, "etl_hw_version",
+		'x', 4, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_SERIAL, "etl_serial_no",
+		'x', 13, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_SERIAL_EXTRA, "etl_serial_extra",
+		'x', 15, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_PROD_DATE, "etl_prod_date",
+		'x', 10, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_WLAN_MODULE, "etl_wlan_module",
+		'x', 32, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_WLAN_KEY, "etl_wlan_wep_key",
+		'x', 26, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_WPS_PIN, "etl_wlan_wps_pin",
+		'x', 16, save_env);
+
+	sas_etl_env_set_fill(SAS_ETL_ACS_AUTH, "etl_acs_auth",
+		'x', 16, save_env);
+
+	sas_etl_env_set_hwcfg(save_env);
+	sas_etl_env_set_hwcfg2(save_env);
+}
+
+const char *sas_etl_get_string(enum sas_etl_id idx)
+{
+	const struct sas_etl_map_entry *entry = sas_etl_entry_find(idx);
+
+	if (!entry)
+		return NULL;
+
+	return entry->val;
+}
+
+int sas_etl_get_integer(enum sas_etl_id idx)
+{
+	const struct sas_etl_map_entry *entry = sas_etl_entry_find(idx);
+	unsigned long val;
+
+	if (!entry)
+		return 0;
+
+	strict_strtoul(entry->val, 10, &val);
+
+	return val;
+}
+
+unsigned long sas_etl_get_hex(enum sas_etl_id idx, unsigned int len)
+{
+	const struct sas_etl_map_entry *entry = sas_etl_entry_find(idx);
+	unsigned long val;
+	unsigned int i;
+
+	if (!entry)
+		return 0;
+
+	val = entry->val[0];
+	for (i = 1; i < len; i++) {
+		val <<= 8;
+		val |= entry->val[i];
+	}
+
+	return val;
+}
+
+void sas_etl_set_string(enum sas_etl_id idx, const char *val)
+{
+	struct sas_etl_map_entry *entry = sas_etl_entry_find_or_create(idx);
+
+	if (!entry)
+		return;
+
+	if (val)
+		snprintf(entry->val, SAS_ETL_MAX_VALUE_CHARS - 1, "%s", val);
+	else
+		memset(entry->val, 0, SAS_ETL_MAX_VALUE_CHARS);
+}
+
+void sas_etl_set_integer(enum sas_etl_id idx, int val)
+{
+	struct sas_etl_map_entry *entry = sas_etl_entry_find_or_create(idx);
+
+	if (!entry)
+		return;
+
+	snprintf(entry->val, SAS_ETL_MAX_VALUE_CHARS - 1, "%d", val);
+}
+
+void sas_etl_set_hex(enum sas_etl_id idx, unsigned int len, unsigned long val)
+{
+	struct sas_etl_map_entry *entry = sas_etl_entry_find_or_create(idx);
+
+	if (!entry)
+		return;
+
+	val <<= (4 - len) * 8;
+	memcpy(entry->val, &val, 4);
+}
+
+static void sas_etl_banner_print(const char *name, const char *buf)
+{
+	sas_banner_content_print("%-25s%-s ", name, buf ? buf : "");
+}
+
+void sas_etl_print(void)
+{
+	if (!sas_etl_ver) {
+		sas_banner_header_print("No Sphairon type label installed");
+		return;
+	}
+
+	sas_banner_header_print("Sphairon type label v%u", sas_etl_ver);
+
+	sas_etl_banner_print("Product name",
+		sas_etl_get_string(SAS_ETL_TRIV_NAME));
+	sas_etl_banner_print("Ident number",
+		sas_etl_get_string(SAS_ETL_IDENT_NO));
+	sas_etl_banner_print("Base platform",
+		sas_etl_get_string(SAS_ETL_BASE_PLATFORM));
+	sas_etl_banner_print("Flash layout",
+		sas_etl_get_string(SAS_ETL_FLASH_LAYOUT));
+	sas_etl_banner_print("Data partition size",
+		sas_etl_get_string(SAS_ETL_DATA_PART_SIZE));
+	sas_etl_banner_print("Data partition location",
+		sas_etl_get_string(SAS_ETL_DATA_PART_LOC));
+
+	sas_banner_line_print();
+
+	sas_etl_banner_print("HW version",
+		sas_etl_get_string(SAS_ETL_HW_VERSION));
+	sas_etl_banner_print("Serial number",
+		sas_etl_get_string(SAS_ETL_SERIAL));
+	sas_etl_banner_print("Serial number extra",
+		sas_etl_get_string(SAS_ETL_SERIAL_EXTRA));
+	sas_etl_banner_print("ACS authentication",
+		sas_etl_get_string(SAS_ETL_ACS_AUTH));
+	sas_etl_banner_print("Date of production",
+		sas_etl_get_string(SAS_ETL_PROD_DATE));
+	sas_etl_banner_print("MAC address",
+		sas_etl_get_string(SAS_ETL_MAC_ADDR));
+	sas_etl_banner_print("MAC address pool",
+		sas_etl_get_string(SAS_ETL_MAC_ADDR_POOL));
+	sas_etl_banner_print("WLAN SSID",
+		sas_etl_get_string(SAS_ETL_WLAN_SSID));
+	sas_etl_banner_print("WLAN SSID extra",
+		sas_etl_get_string(SAS_ETL_WLAN_SSID_EXTRA));
+
+	sas_banner_footer_print();
+}
+
+void sas_etl_dump(void)
+{
+	enum sas_etl_id idx;
+	const char *str;
+
+	for (idx = SAS_ETL_HW_VERSION; idx < SAS_ETL_ID_LAST; idx++) {
+		printf("%03d: %s = ", idx, sas_etl_id_str(idx));
+
+		if (sas_etl_is_integer(idx))
+			printf("%d\n", sas_etl_get_integer(idx));
+		else if (sas_etl_is_hex(idx))
+			printf("0x%0*lx\n", 2 * sas_etl_hex_size(idx),
+				sas_etl_get_hex(idx, sas_etl_hex_size(idx)));
+		else {
+			str = sas_etl_get_string(idx);
+			printf("%s\n", str ? str : "");
+		}
+	}
+}
+
+int sas_etl_version(void)
+{
+	return sas_etl_ver;
+}
+
+enum sas_flash_layout_type sas_etl_flash_layout(void)
+{
+	const char *val;
+
+	val = getenv("flash_layout_override");
+	if (!val) {
+		val = sas_etl_get_string(SAS_ETL_FLASH_LAYOUT);
+		if (!val)
+			val = CONFIG_SPHAIRON_FLASHLAYOUT;
+	}
+
+	return sas_flash_layout_parse(val);
+}
+
+size_t sas_etl_data_part_size(void)
+{
+	size_t size = sas_etl_get_integer(SAS_ETL_DATA_PART_SIZE);
+
+	if (!size)
+		size = SAS_ETL_DATA_PART_SIZE_DEFAULT;
+
+	return size << 20;
+}
+
+enum sas_data_part_loc sas_etl_data_part_loc(void)
+{
+	int loc = sas_etl_get_integer(SAS_ETL_DATA_PART_LOC);
+
+	if (loc < 0 || loc >= DATA_PART_LOC_INVALID)
+		return SAS_ETL_DATA_PART_LOC_DEFAULT;
+
+	return loc;
+}
+
+static const char sas_etl_id_strings[][16] = {
+	"hw_version",
+	"serial_no",
+	"prod_date",
+	"wlan_module",
+	"wlan_key",
+	"triv_name",
+	"mac_addr",
+	"hw_cfg",
+	"hw_cfg2",
+	"ident_no",
+	"customer",
+	"base_platform",
+	"wlan_wps_pin",
+	"led_cfg",
+	"wlan_cfg",
+	"wlan_ssid",
+	"flash_layout",
+	"extra_space",
+	"jffs_images",
+	"serial_extra",
+	"shdsl_lines",
+	"mac_addr_pool",
+	"data_part_size",
+	"data_part_loc",
+	"acs_auth",
+	"wlan_ssid_extra",
+};
+
+const char *sas_etl_id_str(enum sas_etl_id idx)
+{
+	assert(idx && idx < SAS_ETL_ID_LAST);
+
+	return sas_etl_id_strings[idx - 1];
+}
+
+enum sas_etl_id sas_etl_id_parse(const char *str)
+{
+	unsigned int i;
+	unsigned long val;
+	const char *name;
+
+	if (!str)
+		return SAS_ETL_ID_LAST;
+
+	for (i = SAS_ETL_HW_VERSION; i < SAS_ETL_ID_LAST; i++) {
+		name = sas_etl_id_strings[i - 1];
+
+		if (!strncmp(name, str, 15))
+			return i;
+	}
+
+	if (strict_strtoul(str, 10, &val))
+		return SAS_ETL_ID_LAST;
+
+	if (val && val < SAS_ETL_ID_LAST)
+		return val;
+
+	return SAS_ETL_ID_LAST;
+}
diff --git a/lib/sphairon/flash.c b/lib/sphairon/flash.c
new file mode 100644
index 0000000000000000000000000000000000000000..84ed5dc49854c7593851dce81972c6a9ee812198
--- /dev/null
+++ b/lib/sphairon/flash.c
@@ -0,0 +1,548 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <spi_flash.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <jffs2/load_kernel.h>
+#include <ubi_uboot.h>
+
+#include <sas/flash.h>
+#include <sas/util.h>
+
+#ifdef CONFIG_CMD_UBI
+#define init_ubi	1
+#else
+#define init_ubi	0
+#endif
+
+#define UBI_VID_HDR_OFFSET	512
+
+static struct list_head sas_flash_partitions;
+static int sas_flash_verbose;
+static int ubi_num;
+
+int sas_flash_init(void)
+{
+	char *nand;
+	char mtdids[64];
+	unsigned int pos;
+
+	INIT_LIST_HEAD(&sas_flash_partitions);
+
+	snprintf(mtdids, sizeof(mtdids - 1), "%s", MTDIDS_DEFAULT);
+
+	/* strip nand0 from mtdids if not assembled */
+	if (!sas_flash_nand_device()) {
+		/* check if nand0 is configured */
+		nand = strstr(mtdids, "nand0");
+		if (nand) {
+			pos = nand - mtdids;
+			if (mtdids[pos - 1] == ',')
+				pos--;
+
+			mtdids[pos] = 0;
+		}
+	}
+
+	/* init env variables mtdparts and mtdids */
+	setenv("mtdids", mtdids);
+	setenv("mtdparts", MTDPARTS_DEFAULT);
+	setenv("partition", NULL);
+	mtdparts_init();
+
+	if (init_ubi)
+		ubi_init();
+
+	return 0;
+}
+
+void sas_flash_verbose_set(int v)
+{
+	sas_flash_verbose = v;
+}
+
+struct sas_flash_partition *
+sas_flash_part_create(enum sas_flash_part_type type)
+{
+	struct sas_flash_partition *part;
+
+	part = malloc(sizeof(*part));
+	if (!part)
+		return NULL;
+
+	memset(part, 0, sizeof(*part));
+	INIT_LIST_HEAD(&part->link);
+	part->type = type;
+
+	return part;
+}
+
+void sas_flash_part_destroy(struct sas_flash_partition *part)
+{
+	free(part);
+}
+
+void sas_flash_part_add(struct sas_flash_partition *part)
+{
+	list_add_tail(&part->link, &sas_flash_partitions);
+}
+
+void sas_flash_part_del(struct sas_flash_partition *part)
+{
+	list_del(&part->link);
+}
+
+struct sas_flash_partition *
+sas_flash_part_find(enum sas_flash_part_type type)
+{
+	struct sas_flash_partition *part;
+
+	list_for_each_entry(part, &sas_flash_partitions, link)
+		if (part->type == type)
+			return part;
+
+	return NULL;
+}
+
+int sas_flash_part_mtdparts_sync(struct sas_flash_partition *part)
+{
+	const char *name = sas_flash_partition_str(part->type);
+	struct mtd_device *dev;
+	int err;
+
+	debug("%s: name %s\n", __func__, name);
+
+	err = find_dev_and_part(name, &dev, &part->pnum, &part->pinfo);
+	if (err) {
+		debug("%s: find_dev_and_part failed (%d)\n",
+			__func__, err);
+		return 1;
+	}
+
+	part->size = part->pinfo->size;
+	part->offset = part->pinfo->offset;
+
+	return 0;
+}
+
+int sas_flash_part_mtdparts_add(const struct mtd_info *mtd,
+				struct sas_flash_partition *part,
+				size_t size, size_t offset)
+{
+	const char *name = sas_flash_partition_str(part->type);
+	int err;
+
+	debug("%s: name %s\n", __func__, name);
+
+	err = sas_run_command("mtdparts add %s %u@%u %s", mtd->name,
+				size, offset, name);
+	if (err) {
+		debug("%s: mtdparts add failed (%d)\n",
+			__func__, err);
+		return 1;
+	}
+
+	return sas_flash_part_mtdparts_sync(part);
+}
+
+struct mtd_info *
+sas_flash_part_mtd_parent(const struct sas_flash_partition *part)
+{
+	struct mtd_device *dev = part->pinfo->dev;
+	struct mtd_info *mtd;
+	char mtd_dev[16];
+
+	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(dev->id->type), dev->id->num);
+
+	mtd = get_mtd_device_nm(mtd_dev);
+	if (IS_ERR(mtd))
+		return NULL;
+
+	return mtd;
+}
+
+int sas_flash_part_mtd_register(struct mtd_info *mtd,
+				struct sas_flash_partition *part)
+{
+	struct mtd_partition mtd_part;
+	int err;
+
+	debug("%s: name %s\n", __func__, part->pinfo->name);
+
+	memset(&mtd_part, 0, sizeof(mtd_part));
+	mtd_part.name = part->pinfo->name;
+	mtd_part.offset = part->pinfo->offset;
+	mtd_part.size = part->pinfo->size;
+	mtd_part.mtdp = &part->mtd;
+
+	err = add_mtd_partitions(mtd, &mtd_part, 1);
+	if (err) {
+		debug("%s: add_mtd_partitions failed (%d)\n",
+			__func__, err);
+		return 1;
+	}
+
+	add_mtd_device(part->mtd);
+
+	return 0;
+}
+
+int sas_flash_part_ubi_attach(struct sas_flash_partition *part)
+{
+	int err;
+
+	debug("%s: name %s\n", __func__, part->pinfo->name);
+
+	err = ubi_attach_mtd_dev(part->mtd, ubi_num, UBI_VID_HDR_OFFSET);
+	if (err)
+		return 1;
+
+	part->ubi = ubi_devices[ubi_num++];
+
+	return 0;
+}
+
+struct ubi_volume *sas_flash_ubi_volume_find(struct sas_flash_partition *part,
+						const char *volume)
+{
+	struct ubi_device *ubi = part->ubi;
+	struct ubi_volume *vol;
+	int i;
+
+	for (i = 0; i < ubi->vtbl_slots; i++) {
+		vol = ubi->volumes[i];
+		if (vol && !strcmp(vol->name, volume))
+			return vol;
+	}
+
+	return NULL;
+}
+
+struct mtd_info *sas_flash_boot_device(void)
+{
+	struct sas_flash_partition *part;
+
+	part = sas_flash_part_find(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return NULL;
+
+	return sas_flash_part_mtd_parent(part);
+}
+
+struct mtd_info *sas_flash_nand_device(void)
+{
+#ifdef CONFIG_CMD_NAND
+	struct mtd_info *mtd = get_mtd_device_nm("nand0");
+	if (IS_ERR(mtd))
+		return NULL;
+
+	return mtd;
+#else
+	return NULL;
+#endif
+}
+
+void sas_flash_partition_print(void)
+{
+	struct sas_flash_partition *part;
+
+	list_for_each_entry(part, &sas_flash_partitions, link)
+		sas_banner_content_print("%4s%u: %-16s %8x @ %08x",
+			MTD_DEV_TYPE(part->pinfo->dev->id->type),
+			part->pinfo->dev->id->num, part->pinfo->name,
+			part->pinfo->size, part->pinfo->offset);
+}
+
+static inline void sas_flash_info_print(const char *func,
+					const struct sas_flash_partition *part,
+					ulong from, size_t len,
+					const void *buf)
+{
+	if (sas_flash_verbose) {
+		printf("%s: %x bytes @ %lx on %s ",
+			func, len, from, part->mtd->name);
+		if (buf)
+			printf("from %p ", buf);
+	}
+}
+
+static inline void sas_flash_result_print(int result)
+{
+	if (result)
+		printf(" failed (%d)\n", result);
+	else if (sas_flash_verbose)
+		puts(" done\n");
+}
+
+size_t sas_flash_roundb(const struct sas_flash_partition *part, size_t len)
+{
+	return ROUND(len, part->mtd->erasesize);
+}
+
+int sas_flash_read(const struct sas_flash_partition *part,
+			ulong from, size_t len, void *buf)
+{
+	int ret;
+	size_t retlen;
+
+	sas_flash_info_print(__func__, part, from, len, buf);
+
+	ret = part->mtd->read(part->mtd, from, len, &retlen, buf);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_write(const struct sas_flash_partition *part,
+			ulong to, size_t len, const void *buf)
+{
+	int ret;
+	size_t retlen;
+
+	sas_flash_info_print(__func__, part, to, len, buf);
+
+	ret = part->mtd->write(part->mtd, to, len, &retlen, buf);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_lock(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	int ret = 0;
+	size_t erase_len = sas_flash_roundb(part, len);
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	if (part->mtd->lock)
+		ret = part->mtd->lock(part->mtd, off, erase_len);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_unlock(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	int ret = 0;
+	size_t erase_len = sas_flash_roundb(part, len);
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	if (part->mtd->unlock)
+		ret = part->mtd->unlock(part->mtd, off, erase_len);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+static int __flash_erase(struct mtd_info *mtd, ulong off, size_t len)
+{
+	struct erase_info instr;
+	unsigned long erase_len, erased_len; /* in blocks */
+	int ret = 0;
+
+	instr.mtd = mtd;
+	instr.addr = off;
+	instr.len = mtd->erasesize;
+	instr.callback = NULL;
+	erase_len = lldiv(len + mtd->erasesize - 1, mtd->erasesize);
+
+	putc('\n');
+
+	for (erased_len = 0; erased_len < erase_len;
+		instr.addr += mtd->erasesize, erased_len++) {
+
+		WATCHDOG_RESET();
+
+		if (tstc()) {
+			if ('c' == getc())
+				return 1;
+		}
+
+		if (mtd->block_isbad) {
+			ret = mtd->block_isbad(mtd, instr.addr);
+			if (ret > 0) {
+				printf("\nskipping bad block at %08llx\n",
+					instr.addr);
+				continue;
+			}
+		}
+
+		ret = mtd->erase(mtd, &instr);
+		if (ret)
+			return ret;
+
+		printf("\rErasing block %lu/%lu (press c to cancel)",
+			erased_len + 1, erase_len);
+	}
+
+	return 0;
+}
+
+int sas_flash_erase(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	size_t erase_len = sas_flash_roundb(part, len);
+	int ret;
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	ret = __flash_erase(part->mtd, off, erase_len);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_partial_erase(const struct sas_flash_partition *part,
+				ulong off, size_t len)
+{
+	int ret;
+	ulong pre_start = 0, post_start = 0, post_end = 0;
+	ulong erase_start, erase_end;
+	size_t pre_size, post_size, erase_len, retlen;
+	void *pre_data = NULL, *post_data = NULL;
+
+	sas_flash_info_print(__func__, part, off, len, NULL);
+
+	if (part->mtd->numeraseregions)
+		printf("\n%s: note: not yet optimized for non-uniform "
+			"flash devices\n", __func__);
+
+	pre_size = off % part->mtd->erasesize;
+	if (pre_size) {
+		pre_start = off - pre_size;
+		pre_size--;
+		erase_start = pre_start;
+
+		pre_data = malloc(pre_size);
+		if (!pre_data) {
+			ret = 1;
+			goto done;
+		}
+
+		ret = part->mtd->read(part->mtd, pre_start, pre_size,
+					&retlen, pre_data);
+		if (ret)
+			goto done;
+	} else
+		erase_start = off;
+
+	post_size = (off + len) % part->mtd->erasesize;
+	if (post_size) {
+		post_end = sas_flash_roundb(part, off + len) - 1;
+		post_start = off + len;
+		post_size = post_end - post_start;
+		erase_end = post_end;
+
+		post_data = malloc(post_size);
+		if (!post_data) {
+			ret = 1;
+			goto done;
+		}
+
+		ret = part->mtd->read(part->mtd, post_start, post_size,
+					&retlen, post_data);
+		if (ret)
+			goto done;
+	} else
+		erase_end = off + len - 1;
+
+	erase_len = erase_end - erase_start + 1;
+
+	ret = __flash_erase(part->mtd, erase_start, erase_len);
+	if (ret)
+		goto done;
+
+	if (pre_data) {
+		ret = part->mtd->write(part->mtd, pre_start, pre_size,
+					&retlen, pre_data);
+		if (ret)
+			goto done;
+	}
+
+	if (post_data) {
+		ret = part->mtd->write(part->mtd, post_start, post_size,
+					&retlen, post_data);
+		if (ret)
+			goto done;
+	}
+
+done:
+	sas_flash_result_print(ret);
+
+	if (pre_data)
+		free(pre_data);
+
+	if (post_data)
+		free(post_data);
+
+	return ret;
+}
+
+int sas_flash_complete_write(const struct sas_flash_partition *part,
+				ulong to, size_t write_len,
+				size_t erase_len, const void *buf,
+				int partial_erase)
+{
+	int ret;
+
+	if (part->locked) {
+		ret = sas_flash_unlock(part, 0, part->size);
+		if (ret)
+			return ret;
+	}
+
+	if (partial_erase)
+		ret = sas_flash_partial_erase(part, to, erase_len);
+	else
+		ret = sas_flash_erase(part, to, erase_len);
+
+	if (ret)
+		goto done;
+
+	ret = sas_flash_write(part, to, write_len, buf);
+	if (ret)
+		goto done;
+
+done:
+	if (part->locked)
+		sas_flash_lock(part, 0, part->size);
+
+	return ret;
+}
+
+static const char sas_flash_partition_strings[][16] = {
+	"uboot_fix",
+	"uboot_cfg",
+	"uboot_update",
+	"syscfg1",
+	"syscfg2",
+	"images1",
+	"images2",
+	"images3",
+	"device",
+	"data",
+	"invalid"
+};
+
+const char* sas_flash_partition_str(enum sas_flash_part_type type)
+{
+	assert(type <= SAS_PART_INVALID);
+
+	return sas_flash_partition_strings[type];
+}
diff --git a/lib/sphairon/flashlayout.c b/lib/sphairon/flashlayout.c
new file mode 100644
index 0000000000000000000000000000000000000000..d9dc0899c44b49c4dc0cfbfe8b56d51e4c60e7c7
--- /dev/null
+++ b/lib/sphairon/flashlayout.c
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/flashlayout.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/etl.h>
+
+#if defined(CONFIG_ENV_OFFSET) && defined(CONFIG_ENV_SECT_SIZE)
+#define UBOOT_ENV_OFFSET		CONFIG_ENV_OFFSET
+#define UBOOT_ENV_SECT_SIZE		CONFIG_ENV_SECT_SIZE
+#else
+#define UBOOT_ENV_OFFSET		0
+#define UBOOT_ENV_SECT_SIZE		0
+#endif
+
+#define SYSCFG_MIN_SIZE			(512 * 1024)
+
+struct sas_layout_map {
+	const char name[4];
+	const char desc[36];
+};
+
+static enum sas_flash_layout_type sas_flash_layout;
+
+static int sas_flash_layout_static_part_init(enum sas_flash_part_type type)
+{
+	struct sas_flash_partition *part;
+	struct mtd_info *mtd;
+	int err;
+
+	part = sas_flash_part_create(type);
+	if (!part)
+		return 1;
+
+	part->locked = 1;
+
+	err = sas_flash_part_mtdparts_sync(part);
+	if (err)
+		return 1;
+
+	mtd = sas_flash_part_mtd_parent(part);
+	if (!mtd)
+		return 1;
+
+	err = sas_flash_part_mtd_register(mtd, part);
+	if (err)
+		return 1;
+
+	sas_flash_part_add(part);
+
+	return 0;
+}
+
+int sas_flash_layout_static_init(void)
+{
+	int err;
+
+	debug("%s:\n", __func__);
+
+	sas_flash_layout = SAS_LAYOUT_BASIC;
+
+	err = sas_flash_layout_static_part_init(SAS_PART_UBOOT_FIX);
+	if (err)
+		return 1;
+
+	err = sas_flash_layout_static_part_init(SAS_PART_UBOOT_CFG);
+	if (err)
+		return 1;
+
+	if (sas_flash_layout_has_uboot_update_part()) {
+		err = sas_flash_layout_static_part_init(SAS_PART_UBOOT_UPDATE);
+		if (err)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int sas_flash_layout_dynamic_part_add(struct mtd_info *mtd,
+						enum sas_flash_part_type type,
+						unsigned long offset,
+						size_t size, int ubi_attach)
+{
+	struct sas_flash_partition *part;
+	int err;
+
+	debug("%s: mtd %s, type %s, offset %08lx, size %08zx\n", __func__,
+		mtd->name, sas_flash_partition_str(type), offset, size);
+
+	part = sas_flash_part_create(type);
+	if (!part)
+		return 1;
+
+	err = sas_flash_part_mtdparts_add(mtd, part, size, offset);
+	if (err)
+		return 1;
+
+	err = sas_flash_part_mtd_register(mtd, part);
+	if (err)
+		return 1;
+
+	if (ubi_attach) {
+		err = sas_flash_part_ubi_attach(part);
+		if (err)
+			return 1;
+	}
+
+	sas_flash_part_add(part);
+
+	return 0;
+}
+
+int sas_flash_layout_dynamic_init(struct mtd_info *boot_mtd,
+					struct mtd_info *nand_mtd,
+					enum sas_flash_layout_type layout)
+{
+	struct mtd_info *data_mtd = NULL;
+	size_t size, offset;
+	size_t data_size = 0, data_offset = 0;
+	uint64_t available_size;
+	uint32_t n;
+	int err;
+
+	if (!boot_mtd)
+		return 0;
+
+	debug("%s: boot_mtd %s, nand_mtd %s, layout %s\n",
+		__func__, boot_mtd->name, nand_mtd ? nand_mtd->name : "none",
+		sas_flash_layout_str(layout));
+
+	offset = sas_flash_layout_dynamic_offset();
+
+	if (sas_flash_layout_has_sysconfig_part(layout)) {
+		size = SYSCFG_MIN_SIZE;
+
+		err = sas_flash_layout_dynamic_part_add(boot_mtd,
+			SAS_PART_SYSCFG1, offset, size, 0);
+		if (err)
+			return 1;
+
+		offset += size;
+
+		if (sas_flash_layout_is_mirrored(layout)) {
+			err = sas_flash_layout_dynamic_part_add(boot_mtd,
+				SAS_PART_SYSCFG2, offset, size, 0);
+			if (err)
+				return 1;
+
+			offset += size;
+		}
+	}
+
+	switch (sas_etl_data_part_loc()) {
+	case DATA_PART_LOC_BOOT:
+		if (sas_flash_layout_has_data_part(layout)) {
+			data_mtd = boot_mtd;
+			data_size = sas_etl_data_part_size();
+			data_offset = offset;
+			offset += data_size;
+		}
+		break;
+	case DATA_PART_LOC_NAND:
+		if (!nand_mtd)
+			return 1;
+
+		if (sas_flash_layout_has_data_part(layout)) {
+			data_mtd = nand_mtd;
+			data_size = nand_mtd->size;
+			data_offset = 0;
+		}
+		break;
+	case DATA_PART_LOC_AUTO:
+		if (nand_mtd) {
+			data_mtd = nand_mtd;
+			data_size = nand_mtd->size;
+			data_offset = 0;
+		} else if (sas_flash_layout_has_data_part(layout)) {
+			data_mtd = boot_mtd;
+			data_size = sas_etl_data_part_size();
+			data_offset = offset;
+			offset += data_size;
+		}
+		break;
+	default:
+		return 1;
+	}
+
+	if (data_mtd) {
+		err = sas_flash_layout_dynamic_part_add(data_mtd, SAS_PART_DATA,
+			data_offset, data_size, 0);
+		if (err)
+			return 1;
+	}
+
+	if (sas_flash_layout_has_image_parts(layout)) {
+		available_size = boot_mtd->size - offset;
+
+		if (sas_flash_layout_is_mirrored(layout)) {
+			n = mtd_div_by_eb(available_size, boot_mtd);
+			n >>= 1;
+			size = n * boot_mtd->erasesize;
+		}
+		else
+			size = available_size;
+
+		err = sas_flash_layout_dynamic_part_add(boot_mtd,
+			SAS_PART_IMAGES1, offset, size, 0);
+		if (err)
+			return 1;
+
+		if (sas_flash_layout_is_mirrored(layout)) {
+			offset += size;
+
+			err = sas_flash_layout_dynamic_part_add(boot_mtd,
+				SAS_PART_IMAGES2, offset, size, 0);
+			if (err)
+				return 1;
+		}
+	}
+
+	sas_flash_layout = layout;
+
+	return 0;
+}
+
+void sas_flash_layout_print(void)
+{
+	sas_banner_header_print("Flash partition info");
+	sas_banner_content_print("%-25s%-s ", "Used layout",
+		sas_flash_layout_str(sas_flash_layout));
+	sas_banner_line_print();
+	sas_flash_partition_print();
+	sas_banner_footer_print();
+}
+
+unsigned long sas_flash_layout_dynamic_offset(void)
+{
+	unsigned long offset = UBOOT_ENV_OFFSET + UBOOT_ENV_SECT_SIZE;
+
+	if (sas_flash_layout_has_uboot_update_part())
+		offset += UBOOT_ENV_OFFSET;
+
+	return offset;
+}
+
+struct sas_flash_partition *sas_flash_layout_image_partition(unsigned int index)
+{
+	const enum sas_flash_part_type type = index ?
+					SAS_PART_IMAGES2 : SAS_PART_IMAGES1;
+
+	return sas_flash_part_find(type);
+}
+
+enum sas_flash_layout_type sas_flash_layout_current(void)
+{
+	return sas_flash_layout;
+}
+
+static const struct sas_layout_map sas_flash_layout_strings[] = {
+	{ "bas", "Basic" },
+	{ "pos", "Platform only - single" },
+	{ "pom", "Platform only - mirrored" },
+	{ "pss", "Platform/Service - single" },
+	{ "psm", "Platform/Service - mirrored" },
+	{ "posd", "Platform only/Data - single" },
+	{ "pomd", "Platform only/Data - mirrored" },
+	{ "pssd", "Platform/Service/Data - single" },
+	{ "psmd", "Platform/Service/Data - mirrored" },
+	{ "", "invalid" }
+};
+
+const char* sas_flash_layout_name(enum sas_flash_layout_type layout)
+{
+	assert(layout <= SAS_LAYOUT_INVALID);
+
+	return sas_flash_layout_strings[layout].name;
+}
+
+const char* sas_flash_layout_str(enum sas_flash_layout_type layout)
+{
+	assert(layout <= SAS_LAYOUT_INVALID);
+
+	return sas_flash_layout_strings[layout].desc;
+}
+
+enum sas_flash_layout_type sas_flash_layout_parse(const char *str)
+{
+	unsigned int i;
+	const char *name;
+
+	if (!str)
+		return SAS_LAYOUT_INVALID;
+
+	for (i = 0; i < SAS_LAYOUT_INVALID; i++) {
+		name = sas_flash_layout_strings[i].name;
+
+		if (!strncmp(name, str, 4))
+			return i;
+	}
+
+	return SAS_LAYOUT_INVALID;
+}
diff --git a/lib/sphairon/image.c b/lib/sphairon/image.c
new file mode 100644
index 0000000000000000000000000000000000000000..07ed007abc84ed67e8a16cb0815102d62ea0e799
--- /dev/null
+++ b/lib/sphairon/image.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <sas/image.h>
+
+int sas_image_header_check(const image_header_t *hdr)
+{
+	int format, ret;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		ret = image_check_hcrc(hdr);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+int sas_image_data_check(const image_header_t *hdr)
+{
+	int format, ret;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		ret = image_check_hcrc(hdr);
+		if (ret)
+			ret = image_check_dcrc(hdr);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const char sas_image_strings[][8] = {
+	"fdt",
+	"kernel",
+	"rootfs",
+	"servfs",
+	"defcfg",
+	"unspec",
+	"invalid"
+};
+
+const char* sas_image_type_str(sas_image_type_t type)
+{
+	assert(type <= SAS_IMG_INVALID);
+
+	return sas_image_strings[type];
+}
+
+static sas_image_type_t sas_image_type_legacy(const image_header_t *hdr)
+{
+	char name[IH_NMLEN + 1];
+	int i, ret;
+
+	sprintf(name, "%.*s", IH_NMLEN, image_get_name(hdr));
+	if (name[6] != '#')
+		return SAS_IMG_INVALID;
+
+	name[6] = 0;
+	for (i = 0; i < SAS_IMG_INVALID; i++) {
+		ret = strcmp(sas_image_strings[i], name);
+		if (!ret)
+			return i;
+	}
+
+	return SAS_IMG_INVALID;
+}
+
+sas_image_type_t sas_image_type(const image_header_t *hdr)
+{
+	int format;
+	sas_image_type_t type;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		type = sas_image_type_legacy(hdr);
+		break;
+	default:
+		type = SAS_IMG_INVALID;
+		break;
+	}
+
+	return type;
+}
+
+size_t sas_image_size(const image_header_t *hdr)
+{
+	int format;
+	size_t size;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		size = image_get_size(hdr) + sizeof(image_header_t);
+		break;
+	default:
+		size = 0;
+		break;
+	}
+
+	return size;
+}
+
+void sas_image_name(const image_header_t *hdr, char *buf)
+{
+	int format;
+	char *name;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		name = image_get_name(hdr);
+		break;
+	default:
+		name = "";
+		break;
+	}
+
+	sprintf(buf, "%s", name);
+}
diff --git a/lib/sphairon/init.c b/lib/sphairon/init.c
new file mode 100644
index 0000000000000000000000000000000000000000..4e462627657659cbe3371bc86e6cbdca7e3e8e18
--- /dev/null
+++ b/lib/sphairon/init.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/init.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+#include <sas/etl.h>
+#include <sas/boot.h>
+#include <sas/controlfile.h>
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define init_flash_layout	0
+#else
+#define init_flash_layout	1
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+__weak int sas_board_init_f(void)
+{
+	return 0;
+}
+
+__weak int sas_board_init_r(void)
+{
+	return 0;
+}
+
+int sas_init_f(void)
+{
+	int ret;
+
+	ret = sas_board_init_f();
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int sas_init_r(void)
+{
+	int ret;
+	int save_env = 0;
+	enum sas_flash_layout_type layout;
+	struct mtd_info *boot_mtd, *nand_mtd;
+
+	printf("Reloc: offset @ 0x%08lx\n", gd->reloc_off);
+
+	ret = sas_flash_init();
+	if (ret)
+		goto err;
+
+	sas_boot_init();
+
+	if (init_flash_layout) {
+		ret = sas_flash_layout_static_init();
+		if (ret)
+			goto err;
+
+		ret = sas_etl_init();
+		if (ret)
+			goto err;
+
+		sas_etl_env_set_ethaddr(&save_env);
+
+		boot_mtd = sas_flash_boot_device();
+		if (!boot_mtd) {
+			ret = -1;
+			goto err;
+		}
+
+		if (sas_etl_version()) {
+			nand_mtd = sas_flash_nand_device();
+			layout = sas_etl_flash_layout();
+
+			ret = sas_flash_layout_dynamic_init(boot_mtd, nand_mtd,
+				layout);
+			if (ret)
+				goto err;
+
+			ret = sas_boot_scan_images(&save_env);
+			if (ret)
+				goto err;
+		}
+
+		sas_etl_print();
+		sas_flash_layout_print();
+		sas_boot_print();
+	}
+
+	ret = sas_board_init_r();
+	if (ret)
+		goto err;
+
+	sas_cf_run();
+
+	if (!sas_cf_is_active()) {
+		if (sas_etl_version()) {
+			setenv("bootcmd", "sas_boot");
+			setenv("bootdelay", "3");
+		} else
+			setenv("bootcmd", NULL);
+	}
+
+	sas_setenv_num("sas_saveenv", save_env, NULL);
+
+	return 0;
+
+err:
+	puts("Failed to initialize Sphairon lib\n");
+	setenv("bootcmd", NULL);
+
+	return ret;
+}
diff --git a/lib/sphairon/util.c b/lib/sphairon/util.c
new file mode 100644
index 0000000000000000000000000000000000000000..fc285e8c35438f56ed25086c8813860ffa6f4c20
--- /dev/null
+++ b/lib/sphairon/util.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2011-2013 Sphairon Technologies GmbH
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+
+#include <sas/util.h>
+
+#if defined (CONFIG_ENV_IS_IN_FLASH) || defined (CONFIG_ENV_IS_IN_SPI_FLASH)
+#define sas_has_saveenv		1
+#else
+#define sas_has_saveenv		0
+#endif
+
+int sas_setenv(const char *name, const char *value, int *saveenv)
+{
+	const char *s;
+	int modified;
+
+	s = getenv(name);
+
+	modified = 1;
+	if (s && value)
+		modified = strcmp(s, value);
+
+	if (modified && saveenv)
+		*saveenv = 1;
+
+	return setenv(name, value);
+}
+
+int sas_setenv_num(const char *name, int value, int *saveenv)
+{
+	char buf[32];
+
+	sprintf(buf, "%d", value);
+
+	return sas_setenv(name, buf, saveenv);
+}
+
+int sas_setenv_hex(const char *name, int value, int *saveenv)
+{
+	char buf[32];
+
+	sprintf(buf, "0x%x", value);
+
+	return sas_setenv(name, buf, saveenv);
+}
+
+void sas_saveenv(void)
+{
+	if (sas_has_saveenv)
+		saveenv();
+}
+
+int sas_run_command(const char* fmt, ...)
+{
+	va_list args;
+	char cmd[128];
+	int ret;
+
+	va_start(args, fmt);
+	vsprintf(cmd, fmt, args);
+	va_end(args);
+
+	debug("sas_run_command: %s\n", cmd);
+
+	ret = run_command(cmd, 0);
+
+	/* error is -1, success is 0 or 1 if cmd is repeatable */
+	if (ret < 0)
+		return 1;
+
+	return 0;
+}
+
+size_t sas_run_tftpboot(ulong loadaddr, const char *file)
+{
+	size_t filesize;
+	int ret;
+
+	setenv("filesize", "0");
+	ret = sas_run_command("tftpboot %08lx %s", loadaddr, file);
+	if (ret)
+		return 0;
+
+	filesize = getenv_ulong("filesize", 16, 0);
+
+	return filesize;
+}
+
+int sas_confirm(const char *message)
+{
+	char c;
+	int ret;
+
+	puts(message);
+	for (;;) {
+		puts("\nDo you want to continue (y|n)? :");
+		c = getc();
+
+		if (c == 'y') {
+			ret = 1;
+			goto done;
+		}
+
+		if (c == 'n') {
+			ret = 0;
+			goto done;
+		}
+	}
+
+done:
+	puts("\n");
+	return ret;
+}
+
+static inline void sas_banner_repeat(char *line, unsigned int n,
+					char c, char **pos)
+{
+	char *p = line;
+
+	while (likely(n--))
+		*p++ = c;
+
+	*pos = p;
+}
+
+static void sas_banner_content(const char *fmt, va_list args)
+{
+	int n;
+	char line[80];
+	char *p = line;
+
+	*p++ = '*';
+	*p++ = ' ';
+	n = vsprintf(p, fmt, args);
+	sas_banner_repeat(p + n, 61 - n, ' ', &p);
+
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_header_print(const char *fmt, ...)
+{
+	va_list args;
+	char line[80];
+	char *p = line;
+
+	*p++ = '\n';
+	sas_banner_repeat(p, 64, '*', &p);
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+
+	va_start(args, fmt);
+	sas_banner_content(fmt, args);
+	va_end(args);
+
+	p = line;
+	*p++ = '*';
+	*p++ = ' ';
+	sas_banner_repeat(p, 60, '-', &p);
+
+	*p++ = ' ';
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_content_print(const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sas_banner_content(fmt, args);
+	va_end(args);
+}
+
+void sas_banner_footer_print(void)
+{
+	char line[80];
+	char *p = line;
+
+	sas_banner_repeat(p, 64, '*', &p);
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_line_print(void)
+{
+	char line[80];
+	char *p = line;
+
+	*p++ = '*';
+	*p++ = ' ';
+	sas_banner_repeat(p, 60, '-', &p);
+
+	*p++ = ' ';
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
diff --git a/net/eth.c b/net/eth.c
index 321d5b18fd842d3d5df52549b2647ab8fb9ef816..827fee916f1bc4d4fbde0d654489632d326be653 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -26,6 +26,7 @@
 #include <net.h>
 #include <miiphy.h>
 #include <phy.h>
+#include <switch.h>
 
 void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
 {
@@ -303,6 +304,8 @@ int eth_initialize(bd_t *bis)
 	phy_init();
 #endif
 
+	switch_init();
+
 	eth_env_init(bis);
 
 	/*
diff --git a/snapshot.commit b/snapshot.commit
index 77343543fb9cc7acc781738033eb2ec283dc1ada..8d263096dd01535bb675de996638e0b04cb29b0a 100644
--- a/snapshot.commit
+++ b/snapshot.commit
@@ -1 +1 @@
-d10f68ae47b67acab8b110b5c605dde4197a1820  Fri, 19 Apr 2013 10:25:43 -0400
+$Format:%H  %cD$
diff --git a/spl/Makefile b/spl/Makefile
index b5a8de7835f6da4a5324815fea8831e553f21ecf..e77a8311092bed05632c32f4b5f8cea4b267f975 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -83,6 +83,8 @@ LIBS-$(CONFIG_SPL_ETH_SUPPORT) += drivers/net/libnet.o
 LIBS-$(CONFIG_SPL_ETH_SUPPORT) += drivers/net/phy/libphy.o
 LIBS-$(CONFIG_SPL_MUSB_NEW_SUPPORT) += drivers/usb/musb-new/libusb_musb-new.o
 LIBS-$(CONFIG_SPL_USBETH_SUPPORT) += drivers/usb/gadget/libusb_gadget.o
+LIBS-$(CONFIG_SPL_LZMA_SUPPORT) += lib/lzma/liblzma.o
+LIBS-$(CONFIG_SPL_LZO_SUPPORT) += lib/lzo/liblzo.o
 
 ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX)$(CONFIG_TI814X),)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
diff --git a/tools/.gitignore b/tools/.gitignore
index 9bce7194782f76c71e7214a81fcd8ef2e0ff2264..3b760987371d2405052e2b6ee589383472625fa8 100644
--- a/tools/.gitignore
+++ b/tools/.gitignore
@@ -2,6 +2,7 @@
 /envcrc
 /gen_eth_addr
 /img2srec
+/ltq-boot-image
 /kwboot
 /mkenvimage
 /mkimage
diff --git a/tools/Makefile b/tools/Makefile
index 889c89798d33919b196de8a331c4bb6461c79126..977f01bc67a3f81eb6536a5cfe063c3f2bc1c6aa 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -65,6 +65,7 @@ BIN_FILES-$(CONFIG_VIDEO_LOGO) += bmp_logo$(SFX)
 BIN_FILES-$(CONFIG_BUILD_ENVCRC) += envcrc$(SFX)
 BIN_FILES-$(CONFIG_CMD_NET) += gen_eth_addr$(SFX)
 BIN_FILES-$(CONFIG_CMD_LOADS) += img2srec$(SFX)
+BIN_FILES-$(CONFIG_SOC_LANTIQ) += ltq-boot-image$(SFX)
 BIN_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes$(SFX)
 BIN_FILES-y += mkenvimage$(SFX)
 BIN_FILES-y += mkimage$(SFX)
@@ -90,6 +91,7 @@ OBJ_FILES-$(CONFIG_BUILD_ENVCRC) += envcrc.o
 NOPED_OBJ_FILES-y += fit_image.o
 OBJ_FILES-$(CONFIG_CMD_NET) += gen_eth_addr.o
 OBJ_FILES-$(CONFIG_CMD_LOADS) += img2srec.o
+OBJ_FILES-$(CONFIG_SOC_LANTIQ) += ltq-boot-image.o
 OBJ_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes.o
 NOPED_OBJ_FILES-y += aisimage.o
 NOPED_OBJ_FILES-y += kwbimage.o
@@ -196,6 +198,10 @@ $(obj)img2srec$(SFX):	$(obj)img2srec.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
 
+$(obj)ltq-boot-image$(SFX):	$(obj)ltq-boot-image.o
+	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
+	$(HOSTSTRIP) $@
+
 $(obj)xway-swap-bytes$(SFX):	$(obj)xway-swap-bytes.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
diff --git a/tools/ltq-boot-image.c b/tools/ltq-boot-image.c
new file mode 100644
index 0000000000000000000000000000000000000000..9b246332ca45d57971352fb5aab68f460d4964d9
--- /dev/null
+++ b/tools/ltq-boot-image.c
@@ -0,0 +1,316 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <compiler.h>
+#include <sys/stat.h>
+
+enum image_types {
+	IMAGE_NONE,
+	IMAGE_SFSPL
+};
+
+/* Lantiq non-volatile bootstrap command IDs */
+enum nvb_cmd_ids {
+	NVB_CMD_DEBUG	= 0x11,
+	NVB_CMD_REGCFG	= 0x22,
+	NVB_CMD_IDWNLD	= 0x33,
+	NVB_CMD_CDWNLD	= 0x44,
+	NVB_CMD_DWNLD	= 0x55,
+	NVB_CMD_IFCFG	= 0x66,
+	NVB_CMD_START	= 0x77
+};
+
+/* Lantiq non-volatile bootstrap command flags */
+enum nvb_cmd_flags {
+	NVB_FLAG_START	= 1,
+	NVB_FLAG_DEC	= (1 << 1),
+	NVB_FLAG_DBG	= (1 << 2),
+	NVB_FLAG_SDBG	= (1 << 3),
+	NVB_FLAG_CFG0	= (1 << 4),
+	NVB_FLAG_CFG1	= (1 << 5),
+	NVB_FLAG_CFG2	= (1 << 6),
+	NVB_FLAG_RST	= (1 << 7)
+};
+
+struct args {
+	enum image_types type;
+	__u32		entry_addr;
+	const char	*uboot_bin;
+	const char	*spl_bin;
+	const char	*out_bin;
+};
+
+static void usage_msg(const char *name)
+{
+	fprintf(stderr, "%s: [-h] -t type -e entry-addr -u uboot-bin [-s spl-bin] -o out-bin\n",
+		name);
+	fprintf(stderr, " Image types:\n"
+			"  sfspl  - SPL + [compressed] U-Boot for SPI flash\n");
+}
+
+static enum image_types parse_image_type(const char *type)
+{
+	if (!type)
+		return IMAGE_NONE;
+
+	if (!strncmp(type, "sfspl", 6))
+		return IMAGE_SFSPL;
+
+	return IMAGE_NONE;
+}
+
+static int parse_args(int argc, char *argv[], struct args *arg)
+{
+	int opt;
+
+	memset(arg, 0, sizeof(*arg));
+
+	while ((opt = getopt(argc, argv, "ht:e:u:s:o:")) != -1) {
+		switch (opt) {
+		case 'h':
+			usage_msg(argv[0]);
+			return 1;
+		case 't':
+			arg->type = parse_image_type(optarg);
+			break;
+		case 'e':
+			arg->entry_addr = strtoul(optarg, NULL, 16);
+			break;
+		case 'u':
+			arg->uboot_bin = optarg;
+			break;
+		case 's':
+			arg->spl_bin = optarg;
+			break;
+		case 'o':
+			arg->out_bin = optarg;
+			break;
+		default:
+			fprintf(stderr, "Invalid option -%c\n", opt);
+			goto parse_error;
+		}
+	}
+
+	if (arg->type == IMAGE_NONE) {
+		fprintf(stderr, "Invalid image type\n");
+		goto parse_error;
+	}
+
+	if (!arg->uboot_bin) {
+		fprintf(stderr, "Missing U-Boot binary\n");
+		goto parse_error;
+	}
+
+	if (!arg->out_bin) {
+		fprintf(stderr, "Missing output binary\n");
+		goto parse_error;
+	}
+
+	if (arg->type == IMAGE_SFSPL && !arg->spl_bin) {
+		fprintf(stderr, "Missing SPL binary\n");
+		goto parse_error;
+	}
+
+	return 0;
+
+parse_error:
+	usage_msg(argv[0]);
+	return -1;
+}
+
+static __u32 build_nvb_command(unsigned cmdid, unsigned cmdflags)
+{
+	__u32 cmd;
+	__u16 tag;
+
+	tag = (cmdid << 8) | cmdflags;
+	cmd = (tag << 16) | (0xFFFF - tag);
+
+	return cpu_to_be32(cmd);
+}
+
+static int write_header(int fd, const void *hdr, size_t size)
+{
+	ssize_t n;
+
+	n = write(fd, hdr, size);
+	if (n != size) {
+		fprintf(stderr, "Cannot write header: %s\n",
+			strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int write_nvb_dwnld_header(int fd, size_t size, __u32 addr)
+{
+	__u32 hdr[3];
+
+	hdr[0] = build_nvb_command(NVB_CMD_DWNLD, NVB_FLAG_START |
+					NVB_FLAG_SDBG);
+	hdr[1] = cpu_to_be32(size + 4);
+	hdr[2] = cpu_to_be32(addr);
+
+	return write_header(fd, hdr, sizeof(hdr));
+}
+
+static int write_nvb_start_header(int fd, __u32 addr)
+{
+	__u32 hdr[3];
+
+	hdr[0] = build_nvb_command(NVB_CMD_START, NVB_FLAG_SDBG);
+	hdr[1] = cpu_to_be32(4);
+	hdr[2] = cpu_to_be32(addr);
+
+	return write_header(fd, hdr, sizeof(hdr));
+}
+
+static int open_input_bin(const char *name, void **ptr, size_t *size)
+{
+	struct stat sbuf;
+	int ret, fd;
+
+	fd = open(name, O_RDONLY | O_BINARY);
+	if (0 > fd) {
+		fprintf(stderr, "Cannot open %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	ret = fstat(fd, &sbuf);
+	if (0 > ret) {
+		fprintf(stderr, "Cannot fstat %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	*ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0);
+	if (*ptr == MAP_FAILED) {
+		fprintf(stderr, "Cannot mmap %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	*size = sbuf.st_size;
+
+	return fd;
+}
+
+static void close_input_bin(int fd, void *ptr, size_t size)
+{
+	munmap(ptr, size);
+	close(fd);
+}
+
+static int copy_bin(int fd, void *ptr, size_t size)
+{
+	ssize_t n;
+
+	n = write(fd, ptr, size);
+	if (n != size) {
+		fprintf(stderr, "Cannot copy binary: %s\n", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int open_output_bin(const char *name)
+{
+	int fd;
+
+	fd = open(name, O_RDWR | O_CREAT | O_TRUNC | O_SYNC | O_BINARY, 0666);
+	if (0 > fd) {
+		fprintf(stderr, "Cannot open %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	return fd;
+}
+
+static int create_sfspl(const struct args *arg)
+{
+	int out_fd, uboot_fd, spl_fd, ret;
+	void *uboot_ptr, *spl_ptr;
+	size_t uboot_size, spl_size;
+
+	out_fd = open_output_bin(arg->out_bin);
+	if (0 > out_fd)
+		goto err;
+
+	spl_fd = open_input_bin(arg->spl_bin, &spl_ptr, &spl_size);
+	if (0 > spl_fd)
+		goto err_spl;
+
+	uboot_fd = open_input_bin(arg->uboot_bin, &uboot_ptr, &uboot_size);
+	if (0 > uboot_fd)
+		goto err_uboot;
+
+	ret = write_nvb_dwnld_header(out_fd, spl_size, arg->entry_addr);
+	if (ret)
+		goto err_write;
+
+	ret = copy_bin(out_fd, spl_ptr, spl_size);
+	if (ret)
+		goto err_write;
+
+	ret = write_nvb_start_header(out_fd, arg->entry_addr);
+	if (ret)
+		goto err_write;
+
+	ret = copy_bin(out_fd, uboot_ptr, uboot_size);
+	if (ret)
+		goto err_write;
+
+	close_input_bin(uboot_fd, uboot_ptr, uboot_size);
+	close_input_bin(spl_fd, spl_ptr, spl_size);
+	close(out_fd);
+
+	return 0;
+
+err_write:
+	close_input_bin(uboot_fd, uboot_ptr, uboot_size);
+err_uboot:
+	close_input_bin(spl_fd, spl_ptr, spl_size);
+err_spl:
+	close(out_fd);
+err:
+	return -1;
+}
+
+int main(int argc, char *argv[])
+{
+	int ret;
+	struct args arg;
+
+	ret = parse_args(argc, argv, &arg);
+	if (ret)
+		goto done;
+
+	switch (arg.type) {
+	case IMAGE_SFSPL:
+		ret = create_sfspl(&arg);
+		break;
+	default:
+		fprintf(stderr, "Image type not implemented\n");
+		ret = -1;
+		break;
+	}
+
+done:
+	if (ret >= 0)
+		return EXIT_SUCCESS;
+
+	return EXIT_FAILURE;
+}
