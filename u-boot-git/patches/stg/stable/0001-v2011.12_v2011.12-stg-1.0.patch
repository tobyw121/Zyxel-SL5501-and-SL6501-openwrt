diff --git a/Makefile b/Makefile
index 0438f1ef8feb7a9d8c4e56dc3402e8cae58fcbe5..72ccd877011b62f53156d2ef9ee0ddf83026ea9f 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 2011
 PATCHLEVEL = 12
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -stg-1.0
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 else
@@ -221,6 +221,9 @@ LIBS  = lib/libgeneric.o
 LIBS += lib/lzma/liblzma.o
 LIBS += lib/lzo/liblzo.o
 LIBS += lib/zlib/libz.o
+ifdef CONFIG_LIB_SPHAIRON
+LIBS += lib/sphairon/libsphairon.o
+endif
 LIBS += $(shell if [ -f board/$(VENDOR)/common/Makefile ]; then echo \
 	"board/$(VENDOR)/common/lib$(VENDOR).o"; fi)
 LIBS += $(CPUDIR)/lib$(CPU).o
@@ -256,6 +259,7 @@ LIBS += drivers/mtd/ubi/libubi.o
 LIBS += drivers/mtd/spi/libspi_flash.o
 LIBS += drivers/net/libnet.o
 LIBS += drivers/net/phy/libphy.o
+LIBS += drivers/net/switch/libswitch.o
 LIBS += drivers/pci/libpci.o
 LIBS += drivers/pcmcia/libpcmcia.o
 LIBS += drivers/power/libpower.o
@@ -389,6 +393,12 @@ $(obj)u-boot.bin:	$(obj)u-boot
 		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
 		$(BOARD_SIZE_CHECK)
 
+$(obj)u-boot.bin.lzma:	$(obj)u-boot.bin
+		cat $< | lzma -9 -f - > $@
+
+$(obj)u-boot.bin.lzo:	$(obj)u-boot.bin
+		cat $< | lzop -9 -f - > $@
+
 $(obj)u-boot.ldr:	$(obj)u-boot
 		$(CREATE_LDR_ENV)
 		$(LDR) -T $(CONFIG_BFIN_CPU) -c $@ $< $(LDR_FLAGS)
@@ -400,12 +410,22 @@ $(obj)u-boot.ldr.hex:	$(obj)u-boot.ldr
 $(obj)u-boot.ldr.srec:	$(obj)u-boot.ldr
 		$(OBJCOPY) ${OBJCFLAGS} -O srec $< $@ -I binary
 
-$(obj)u-boot.img:	$(obj)u-boot.bin
-		$(obj)tools/mkimage -A $(ARCH) -T firmware -C none \
+define GEN_UBOOT_IMAGE
+		$(obj)tools/mkimage -A $(ARCH) -T firmware -C $(1) \
 		-O u-boot -a $(CONFIG_SYS_TEXT_BASE) -e 0 \
 		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
 			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
 		-d $< $@
+endef
+
+$(obj)u-boot.img:	$(obj)u-boot.bin
+		$(call GEN_UBOOT_IMAGE,none)
+
+$(obj)u-boot.lzma.img:	$(obj)u-boot.bin.lzma
+		$(call GEN_UBOOT_IMAGE,lzma)
+
+$(obj)u-boot.lzo.img:	$(obj)u-boot.bin.lzo
+		$(call GEN_UBOOT_IMAGE,lzo)
 
 $(obj)u-boot.imx:       $(obj)u-boot.bin
 		$(obj)tools/mkimage -n  $(CONFIG_IMX_CONFIG) -T imximage \
@@ -433,6 +453,18 @@ $(obj)u-boot.sb:       $(obj)u-boot.bin $(obj)spl/u-boot-spl.bin
 		elftosb -zdf imx28 -c $(TOPDIR)/board/$(BOARDDIR)/u-boot.bd \
 			-o $(obj)u-boot.sb
 
+$(obj)u-boot.ltq.sfspl:	$(obj)u-boot.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
+$(obj)u-boot.ltq.lzo.sfspl: $(obj)u-boot.lzo.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
+$(obj)u-boot.ltq.lzma.sfspl: $(obj)u-boot.lzma.img $(obj)spl/u-boot-spl.bin
+		$(obj)tools/ltq-boot-image -t sfspl -e $(CONFIG_SPL_TEXT_BASE) \
+			-s $(obj)spl/u-boot-spl.bin -u $< -o $@
+
 ifeq ($(CONFIG_SANDBOX),y)
 GEN_UBOOT = \
 		cd $(LNDIR) && $(CC) $(SYMS) -T $(obj)u-boot.lds \
diff --git a/README b/README
index 6fe1e0fc2d779acc7551a13fb055e52d2d8c1086..7d7f206d08dfda1344f7a4d8c64804547900d212 100644
--- a/README
+++ b/README
@@ -374,6 +374,12 @@ The following options need to be configured:
 		Defines the string to utilize when trying to match PCIe device
 		tree nodes for the given platform.
 
+- Generic CPU options:
+		CONFIG_SYS_BIG_ENDIAN, CONFIG_SYS_LITTLE_ENDIAN
+
+		Defines the endianess of the CPU. Implementation of those
+		values is arch specific.
+
 - Intel Monahans options:
 		CONFIG_SYS_MONAHANS_RUN_MODE_OSC_RATIO
 
@@ -409,6 +415,11 @@ The following options need to be configured:
 			CONF_CM_CACHABLE_CUW
 			CONF_CM_CACHABLE_ACCELERATED
 
+		CONFIG_SYS_MIPS_CACHE_EXT_INIT
+
+		Enable this to use extended cache initialization for recent
+		MIPS CPU cores.
+
 		CONFIG_SYS_XWAY_EBU_BOOTCFG
 
 		Special option for Lantiq XWAY SoCs for booting from NOR flash.
diff --git a/arch/mips/cpu/mips32/cache.S b/arch/mips/cpu/mips32/cache.S
index 5ce0ec45fc3509fa81a27e0a5e7ea342d3ad1048..316e9616a80263f0636a933d3f26a9f3d53a7e39 100644
--- a/arch/mips/cpu/mips32/cache.S
+++ b/arch/mips/cpu/mips32/cache.S
@@ -30,6 +30,10 @@
 #include <asm/addrspace.h>
 #include <asm/cacheops.h>
 
+#ifndef CONFIG_SYS_MIPS_CACHE_MODE
+#define CONFIG_SYS_MIPS_CACHE_MODE CONF_CM_CACHABLE_NONCOHERENT
+#endif
+
 #define RA		t8
 
 /*
@@ -77,7 +81,12 @@
  */
 LEAF(mips_init_icache)
 	blez		a1, 9f
+#ifdef CONFIG_SYS_MIPS_CACHE_EXT_INIT
+	mtc0		zero, CP0_ITAGLO
+	mtc0		zero, CP0_IDATALO
+#else
 	mtc0		zero, CP0_TAGLO
+#endif
 	/* clear tag to invalidate */
 	PTR_LI		t0, INDEX_BASE
 	PTR_ADDU	t1, t0, a1
@@ -102,7 +111,12 @@ LEAF(mips_init_icache)
  */
 LEAF(mips_init_dcache)
 	blez		a1, 9f
+#ifdef CONFIG_SYS_MIPS_CACHE_EXT_INIT
+	mtc0		zero, CP0_DTAGLO
+	mtc0		zero, CP0_DDATALO
+#else
 	mtc0		zero, CP0_TAGLO
+#endif
 	/* clear all tags */
 	PTR_LI		t0, INDEX_BASE
 	PTR_ADDU	t1, t0, a1
@@ -224,7 +238,7 @@ LEAF(dcache_enable)
 	mfc0	t0, CP0_CONFIG
 	ori	t0, CONF_CM_CMASK
 	xori	t0, CONF_CM_CMASK
-	ori	t0, CONF_CM_CACHABLE_NONCOHERENT
+	ori	t0, CONFIG_SYS_MIPS_CACHE_MODE
 	mtc0	t0, CP0_CONFIG
 	jr	ra
 	END(dcache_enable)
diff --git a/arch/mips/cpu/mips32/config.mk b/arch/mips/cpu/mips32/config.mk
index 4d1b27379d8973e05352ab472d0ece07e20a5582..a1cd590a00414c5f368af190103882440fbdd971 100644
--- a/arch/mips/cpu/mips32/config.mk
+++ b/arch/mips/cpu/mips32/config.mk
@@ -27,14 +27,23 @@
 # Note: Toolchains with binutils prior to v2.16
 # are no longer supported by U-Boot MIPS tree!
 #
-MIPSFLAGS = -march=mips32r2
+MIPSFLAGS := -march=mips32r2
 
+# Handle special prefix in ELDK 4.0 toolchain
 ifneq (,$(findstring 4KCle,$(CROSS_COMPILE)))
-ENDIANNESS = -EL
-else
-ENDIANNESS = -EB
+ENDIANNESS := -EL
 endif
 
-MIPSFLAGS += $(ENDIANNESS)
+ifdef CONFIG_SYS_LITTLE_ENDIAN
+ENDIANNESS := -EL
+endif
+
+ifdef CONFIG_SYS_BIG_ENDIAN
+ENDIANNESS := -EB
+endif
+
+# Default to EB if no endianess is configured
+ENDIANNESS ?= -EB
 
-PLATFORM_CPPFLAGS += $(MIPSFLAGS)
+PLATFORM_CPPFLAGS += $(MIPSFLAGS) $(ENDIANNESS)
+PLATFORM_LDFLAGS += $(ENDIANNESS)
diff --git a/arch/mips/cpu/mips32/danube/Makefile b/arch/mips/cpu/mips32/danube/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..a72f102e5d28d40cdce56a5bd7ea4c91b4fcfa3a
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/Makefile
@@ -0,0 +1,33 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y	+= cgu.o chipid.o cpu.o ebu.o gpio.o mem.o pmu.o rcu.o
+SOBJS-y	+= cgu_init.o mem_init.o lowlevel_init.o
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/danube/cgu.c b/arch/mips/cpu/mips32/danube/cgu.c
new file mode 100644
index 0000000000000000000000000000000000000000..dec46111990dbb75151f9918072ade26f90ec1af
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/cgu.c
@@ -0,0 +1,118 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CGU_SYS_DDR_MASK		0x0003
+#define LTQ_CGU_SYS_DDR_SHIFT		0
+#define LTQ_CGU_SYS_CPU0_MASK		0x000C
+#define LTQ_CGU_SYS_CPU0_SHIFT		2
+#define LTQ_CGU_SYS_FPI_MASK		0x0040
+#define LTQ_CGU_SYS_FPI_SHIFT		6
+
+struct ltq_cgu_regs {
+	u32	rsvd0;
+	u32	pll0_cfg;	/* PLL0 config */
+	u32	pll1_cfg;	/* PLL1 config */
+	u32	pll2_cfg;	/* PLL2 config */
+	u32	sys;		/* System clock */
+	u32	update;		/* CGU update control */
+	u32	if_clk;		/* Interface clock */
+	u32	osc_con;	/* Update OSC Control */
+	u32	smd;		/* SDRAM Memory Control */
+	u32	rsvd1[3];
+	u32	pcm_cr;		/* PCM control */
+	u32	pci_cr;		/* PCI clock control */
+};
+
+static struct ltq_cgu_regs *ltq_cgu_regs =
+	(struct ltq_cgu_regs *) CKSEG1ADDR(LTQ_CGU_BASE);
+
+static inline u32 ltq_cgu_sys_readl(u32 mask, u32 shift)
+{
+	return (ltq_readl(&ltq_cgu_regs->sys) & mask) >> shift;
+}
+
+unsigned long ltq_get_io_region_clock(void)
+{
+	u32 ddr_sel;
+	unsigned long clk;
+
+	ddr_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_DDR_MASK,
+					LTQ_CGU_SYS_DDR_SHIFT);
+
+	switch (ddr_sel) {
+	case 0:
+		clk = CLOCK_166_MHZ;
+		break;
+	case 1:
+		clk = CLOCK_133_MHZ;
+		break;
+	case 2:
+		clk = CLOCK_111_MHZ;
+		break;
+	case 3:
+		clk = CLOCK_83_MHZ;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_cpu_clock(void)
+{
+	u32 cpu0_sel;
+	unsigned long clk;
+
+	cpu0_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_CPU0_MASK,
+					LTQ_CGU_SYS_CPU0_SHIFT);
+
+	switch (cpu0_sel) {
+		/* Same as PLL0 output (333,33 MHz) */
+	case 0:
+		clk = CLOCK_333_MHZ;
+		break;
+		/* 1/1 fixed ratio to DDR clock */
+	case 1:
+		clk = ltq_get_io_region_clock();
+		break;
+		/* 1/2 fixed ratio to DDR clock */
+	case 2:
+		clk = ltq_get_io_region_clock() << 1;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_bus_clock(void)
+{
+	u32 fpi_sel;
+	unsigned long clk;
+
+	fpi_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_FPI_MASK,
+					LTQ_CGU_SYS_FPI_SHIFT);
+
+	if (fpi_sel)
+		/* Half the DDR clock */
+		clk = ltq_get_io_region_clock() >> 1;
+	else
+		/* Same as DDR clock */
+		clk = ltq_get_io_region_clock();
+
+	return clk;
+}
diff --git a/arch/mips/cpu/mips32/danube/cgu_init.S b/arch/mips/cpu/mips32/danube/cgu_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..9205c3e058f9a4d0ce798ab32bda53519e98d084
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/cgu_init.S
@@ -0,0 +1,143 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* RCU module register */
+#define LTQ_RCU_RST_REQ			0x0010
+#define LTQ_RCU_RST_STAT		0x0014
+#define LTQ_RCU_RST_REQ_VALUE		0x40000008
+#define LTQ_RCU_RST_STAT_XTAL_F	0x20000
+
+/* CGU module register */
+#define LTQ_CGU_PLL0_CFG		0x0004	/* PLL0 config */
+#define LTQ_CGU_PLL1_CFG		0x0008	/* PLL1 config */
+#define LTQ_CGU_PLL2_CFG		0x000C	/* PLL2 config */
+#define LTQ_CGU_SYS			0x0010	/* System clock */
+
+/* Valid SYS.CPU0/1 values */
+#define LTQ_CGU_SYS_CPU0_SHIFT		2
+#define LTQ_CGU_SYS_CPU1_SHIFT		4
+#define LTQ_CGU_SYS_CPU_PLL0		0x0
+#define LTQ_CGU_SYS_CPU_DDR_EQUAL	0x1
+#define LTQ_CGU_SYS_CPU_DDR_TWICE	0x2
+
+/* Valid SYS.DDR values */
+#define LTQ_CGU_SYS_DDR_SHIFT		0
+#define LTQ_CGU_SYS_DDR_167_MHZ	0x0
+#define LTQ_CGU_SYS_DDR_133_MHZ	0x1
+#define LTQ_CGU_SYS_DDR_111_MHZ	0x2
+#define LTQ_CGU_SYS_DDR_83_MHZ		0x3
+
+/* Valid SYS.FPI values */
+#define LTQ_CGU_SYS_FPI_SHIFT		6
+#define LTQ_CGU_SYS_FPI_DDR_EQUAL	0x0
+#define LTQ_CGU_SYS_FPI_DDR_HALF	0x1
+
+/* Valid SYS.PPE values */
+#define LTQ_CGU_SYS_PPE_SHIFT		7
+#define LTQ_CGU_SYS_PPE_266_MHZ	0x0
+#define LTQ_CGU_SYS_PPE_240_MHZ	0x1
+#define LTQ_CGU_SYS_PPE_222_MHZ	0x2
+#define LTQ_CGU_SYS_PPE_133_MHZ	0x3
+
+#if (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_333_DDR_167)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_DDR_TWICE
+#define LTQ_CGU_SYS_DDR_CONFIG		LTQ_CGU_SYS_DDR_167_MHZ
+#define LTQ_CGU_SYS_FPI_CONFIG		LTQ_CGU_SYS_FPI_DDR_HALF
+#define LTQ_CGU_SYS_PPE_CONFIG		LTQ_CGU_SYS_PPE_266_MHZ
+#elif (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_111_DDR_111)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_DDR_EQUAL
+#define LTQ_CGU_SYS_DDR_CONFIG		LTQ_CGU_SYS_DDR_111_MHZ
+#define LTQ_CGU_SYS_FPI_CONFIG		LTQ_CGU_SYS_FPI_DDR_HALF
+#define LTQ_CGU_SYS_PPE_CONFIG		LTQ_CGU_SYS_PPE_133_MHZ
+#else
+#error "Invalid system clock configuration!"
+#endif
+
+/* Build register values */
+#define LTQ_CGU_SYS_VALUE	((LTQ_CGU_SYS_PPE_CONFIG << \
+					LTQ_CGU_SYS_PPE_SHIFT) | \
+				(LTQ_CGU_SYS_FPI_CONFIG << \
+					LTQ_CGU_SYS_FPI_SHIFT) | \
+				(LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU1_SHIFT) | \
+				(LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU0_SHIFT) | \
+				LTQ_CGU_SYS_DDR_CONFIG)
+
+/* Reset values for PLL registers for usage with 35.328 MHz crystal */
+#define PLL0_35MHZ_CONFIG	0x9D861059
+#define PLL1_35MHZ_CONFIG	0x1A260CD9
+#define PLL2_35MHZ_CONFIG	0x8000f1e5
+
+/* Reset values for PLL registers for usage with 36 MHz crystal */
+#define PLL0_36MHZ_CONFIG	0x1000125D
+#define PLL1_36MHZ_CONFIG	0x1B1E0C99
+#define PLL2_36MHZ_CONFIG	0x8002f2a1
+
+LEAF(ltq_cgu_init)
+	/* Load current CGU register value */
+	li	t0, (LTQ_CGU_BASE | KSEG1)
+	lw	t1, LTQ_CGU_SYS(t0)
+
+	/* Load target CGU register values */
+	li	t3, LTQ_CGU_SYS_VALUE
+
+	/* Only update registers if values differ */
+	beq	t1, t3, finished
+
+	/*
+	 * Check whether the XTAL_F bit in RST_STAT register is set or not.
+	 * This bit is latched in via pin strapping. If bit is set then
+	 * clock source is a 36 MHz crystal. Otherwise a 35.328 MHz crystal.
+	 */
+	 li	t1, (LTQ_RCU_BASE | KSEG1)
+	 lw	t2, LTQ_RCU_RST_STAT(t1)
+	 and	t2, t2, LTQ_RCU_RST_STAT_XTAL_F
+	 beq	t2, LTQ_RCU_RST_STAT_XTAL_F, boot_36mhz
+
+boot_35mhz:
+	/* Configure PLL for 35.328 MHz */
+	li	t2, PLL0_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL0_CFG(t0)
+	li	t2, PLL1_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL1_CFG(t0)
+	li	t2, PLL2_35MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL2_CFG(t0)
+
+	b	do_reset
+
+boot_36mhz:
+	/* Configure PLL for 36 MHz */
+	li	t2, PLL0_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL0_CFG(t0)
+	li	t2, PLL1_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL1_CFG(t0)
+	li	t2, PLL2_36MHZ_CONFIG
+	sw	t2, LTQ_CGU_PLL2_CFG(t0)
+
+do_reset:
+	/* Store new clock config */
+	sw	t3, LTQ_CGU_SYS(t0)
+
+	/* Perform software reset to activate new clock config */
+	li	t2, LTQ_RCU_RST_REQ_VALUE
+	sw	t2, LTQ_RCU_RST_REQ(t1)
+
+wait_reset:
+	b	wait_reset
+
+finished:
+	jr	ra
+
+	END(ltq_cgu_init)
diff --git a/arch/mips/cpu/mips32/danube/chipid.c b/arch/mips/cpu/mips32/danube/chipid.c
new file mode 100644
index 0000000000000000000000000000000000000000..87d09bec556a76ff8a951d3343dd171f01c2c4d1
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/chipid.c
@@ -0,0 +1,60 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_CHIPID_VERSION_SHIFT	28
+#define LTQ_CHIPID_VERSION_MASK		(0xF << LTQ_CHIPID_VERSION_SHIFT)
+#define LTQ_CHIPID_PNUM_SHIFT		12
+#define LTQ_CHIPID_PNUM_MASK		(0xFFFF << LTQ_CHIPID_PNUM_SHIFT)
+
+struct ltq_chipid_regs {
+	u32	manid;		/* Manufacturer identification */
+	u32	chipid;		/* Chip identification */
+};
+
+static struct ltq_chipid_regs *ltq_chipid_regs =
+	(struct ltq_chipid_regs *) CKSEG1ADDR(LTQ_CHIPID_BASE);
+
+unsigned int ltq_chip_version_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_VERSION_MASK) >> LTQ_CHIPID_VERSION_SHIFT;
+}
+
+unsigned int ltq_chip_partnum_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_PNUM_MASK) >> LTQ_CHIPID_PNUM_SHIFT;
+}
+
+const char *ltq_chip_partnum_str(void)
+{
+	enum ltq_chip_partnum partnum = ltq_chip_partnum_get();
+
+	switch (partnum) {
+	case LTQ_SOC_DANUBE:
+		return "Danube";
+	case LTQ_SOC_DANUBE_S:
+		return "Danube-S";
+	case LTQ_SOC_TWINPASS:
+		return "Twinpass";
+	default:
+		printf("Unknown partnum: %x\n", partnum);
+	}
+
+	return "";
+}
diff --git a/arch/mips/cpu/mips32/danube/config.mk b/arch/mips/cpu/mips32/danube/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..d8ae51d66face5698791665c60118e432e0ac867
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/config.mk
@@ -0,0 +1,11 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PF_CPPFLAGS_DANUBE := $(call cc-option,-mtune=24kec,)
+PLATFORM_CPPFLAGS += $(PF_CPPFLAGS_DANUBE)
+
+LDSCRIPT := $(TOPDIR)/$(CPUDIR)/$(SOC)/u-boot.lds
diff --git a/arch/mips/cpu/mips32/danube/cpu.c b/arch/mips/cpu/mips32/danube/cpu.c
new file mode 100644
index 0000000000000000000000000000000000000000..792bb966fab6f9a5cf10be5148a3a31943a414d5
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/cpu.c
@@ -0,0 +1,36 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/cpu.h>
+
+int arch_cpu_init(void)
+{
+	ltq_pmu_init();
+	ltq_ebu_init();
+
+	return 0;
+}
+
+void ltq_chip_print_info(void)
+{
+	char buf[32];
+
+	printf("SoC:   Lantiq %s v1.%u\n", ltq_chip_partnum_str(),
+		ltq_chip_version_get());
+	printf("CPU:   %s MHz\n", strmhz(buf, ltq_get_cpu_clock()));
+	printf("IO:    %s MHz\n", strmhz(buf, ltq_get_io_region_clock()));
+	printf("BUS:   %s MHz\n", strmhz(buf, ltq_get_bus_clock()));
+}
+
+void _machine_restart(void)
+{
+	ltq_reset_activate(LTQ_RESET_CORE);
+}
diff --git a/arch/mips/cpu/mips32/danube/ebu.c b/arch/mips/cpu/mips32/danube/ebu.c
new file mode 100644
index 0000000000000000000000000000000000000000..e43e55e65fa733e6ab7e52290ad9750be7fa041d
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/ebu.c
@@ -0,0 +1,51 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_EBU_CON_0_RST_VAL	0x8001F7FF
+
+#define LTQ_EBU_CON_WRDIS	(1 << 31)
+
+struct ltq_ebu_regs {
+	u32	clc;
+	u32	rsvd0[3];
+	u32	con;
+	u32	rsvd1[3];
+	u32	addr_sel_0;
+	u32	addr_sel_1;
+	u32	rsvd2[14];
+	u32	con_0;
+	u32	con_1;
+};
+
+static struct ltq_ebu_regs *ltq_ebu_regs =
+	(struct ltq_ebu_regs *) CKSEG1ADDR(LTQ_EBU_BASE);
+
+void ltq_ebu_init(void)
+{
+	/*
+	 * Map EBU region 0 to range 0x10000000-0x13ffffff and enable
+	 * region control. This supports up to 32 MiB NOR flash in
+	 * bank 0.
+	 */
+	ltq_writel(&ltq_ebu_regs->addr_sel_0, 0x10000011);
+
+	/*
+	 * Restore reset value to fix modifications by internal BootROM.
+	 * Also disable write protection.
+	 */
+	ltq_writel(&ltq_ebu_regs->con_0,
+			LTQ_EBU_CON_0_RST_VAL & ~LTQ_EBU_CON_WRDIS);
+}
+
+void *flash_swap_addr(unsigned long addr)
+{
+	return (void *)(addr ^ 2);
+}
diff --git a/arch/mips/cpu/mips32/danube/gpio.c b/arch/mips/cpu/mips32/danube/gpio.c
new file mode 100644
index 0000000000000000000000000000000000000000..bd95a27e213e633e5a8da25da8082b9a76e6b22b
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/gpio.c
@@ -0,0 +1,138 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gpio.h>
+#include <asm/lantiq/io.h>
+
+struct ltq_gpio_port_regs {
+	u32	out;
+	u32	in;
+	u32	dir;
+	u32	altsel0;
+	u32	altsel1;
+	u32	od;
+	u32	stoff;
+	u32	pudsel;
+	u32	puden;
+	u32	rsvd1[3];
+};
+
+struct ltq_gpio_regs {
+	u32				rsvd[4];
+	struct ltq_gpio_port_regs	ports[2];
+};
+
+static struct ltq_gpio_regs *ltq_gpio_regs =
+	(struct ltq_gpio_regs *) CKSEG1ADDR(LTQ_GPIO_BASE);
+
+int gpio_direction_input(int gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	/* Switch to input */
+	ltq_clrbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+
+	return 0;
+}
+
+int gpio_direction_output(int gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	if (value)
+		ltq_setbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+
+	/* Switch to output */
+	ltq_setbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+
+	return 0;
+}
+
+int gpio_get_value(int gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+	u32 val;
+
+	val = ltq_readl(&ltq_gpio_regs->ports[port].in);
+
+	return val & (1 << pin) ? 1 : 0;
+}
+
+int gpio_set_value(int gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (value)
+		ltq_setbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+
+	return 0;
+}
+
+int gpio_set_altfunc(int gpio, int altsel0, int altsel1, int dir)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (altsel0)
+		ltq_setbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+
+	if (altsel1)
+		ltq_setbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	if (dir) {
+		ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+		ltq_setbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+	} else {
+		ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+		ltq_clrbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+	}
+
+	return 0;
+}
+
+int gpio_set_opendrain(int gpio, int od)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (od)
+		ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+
+	return 0;
+}
diff --git a/arch/mips/cpu/mips32/danube/lowlevel_init.S b/arch/mips/cpu/mips32/danube/lowlevel_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..cc352698f7a344f02f748be6c4b13bdabe5b66f5
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/lowlevel_init.S
@@ -0,0 +1,21 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+NESTED(lowlevel_init, 0, ra)
+	move	t8, ra
+
+	la	t7, ltq_cgu_init
+	jalr	t7
+
+	la	t7, ltq_mem_init
+	jalr	t7
+
+	jr	t8
+	END(lowlevel_init)
diff --git a/arch/mips/cpu/mips32/danube/mem.c b/arch/mips/cpu/mips32/danube/mem.c
new file mode 100644
index 0000000000000000000000000000000000000000..961da8a85b6a8ba5a32d14801ebb24734ebd1617
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/mem.c
@@ -0,0 +1,31 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+static void *ltq_mc_ddr_base = (void *) CKSEG1ADDR(LTQ_MC_DDR_BASE);
+
+static inline u32 ltq_mc_dc_read(u32 index)
+{
+	return ltq_readl(ltq_mc_ddr_base + LTQ_MC_DDR_DC_OFFSET(index));
+}
+
+phys_size_t initdram(int board_type)
+{
+	u32 col, row, dc04, dc19, dc20;
+
+	dc04 = ltq_mc_dc_read(4);
+	dc19 = ltq_mc_dc_read(19);
+	dc20 = ltq_mc_dc_read(20);
+
+	row = (dc04 & 0xF) - ((dc19 & 0x700) >> 8);
+	col = ((dc04 & 0xF00) >> 8) - (dc20 & 0x7);
+
+	return (1 << (row + col)) * 4 * 2;
+}
diff --git a/arch/mips/cpu/mips32/danube/mem_init.S b/arch/mips/cpu/mips32/danube/mem_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..c6e177520542e85ade113055a8d758afb752f47c
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/mem_init.S
@@ -0,0 +1,115 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* Must be configured in BOARDDIR */
+#include <ddr_settings.h>
+
+#define LTQ_MC_GEN_ERRCAUSE		0x0010
+#define LTQ_MC_GEN_ERRADDR		0x0020
+#define LTQ_MC_GEN_CON			0x0060
+#define LTQ_MC_GEN_STAT			0x0070
+#define LTQ_MC_GEN_CON_SRAM_DDR_ENABLE	0x5
+#define LTQ_MC_GEN_STAT_DLCK_PWRON	0xC
+
+#define LTQ_MC_DDR_DC03_MC_START	0x100
+
+	/* Store given value in MC DDR CCRx register */
+	.macro dc_sw num, val
+	li	t2, \val
+	sw	t2, LTQ_MC_DDR_DC_OFFSET(\num)(t1)
+	.endm
+
+LEAF(ltq_mem_init)
+	/* Load MC General and MC DDR module base */
+	li	t0, (LTQ_MC_GEN_BASE | KSEG1)
+	li	t1, (LTQ_MC_DDR_BASE | KSEG1)
+
+	/* Clear access error log registers */
+	sw	zero, LTQ_MC_GEN_ERRCAUSE(t0)
+	sw	zero, LTQ_MC_GEN_ERRADDR(t0)
+
+	/* Enable DDR and SRAM module in memory controller */
+	li	t2, LTQ_MC_GEN_CON_SRAM_DDR_ENABLE
+	sw	t2, LTQ_MC_GEN_CON(t0)
+
+	/* Clear start bit of DDR memory controller */
+	sw	zero, LTQ_MC_DDR_DC_OFFSET(3)(t1)
+
+	/* Init memory controller registers with values ddr_settings.h */
+	dc_sw	0, MC_DC00_VALUE
+	dc_sw	1, MC_DC01_VALUE
+	dc_sw	2, MC_DC02_VALUE
+	dc_sw	4, MC_DC04_VALUE
+	dc_sw	5, MC_DC05_VALUE
+	dc_sw	6, MC_DC06_VALUE
+	dc_sw	7, MC_DC07_VALUE
+	dc_sw	8, MC_DC08_VALUE
+	dc_sw	9, MC_DC09_VALUE
+
+	dc_sw	10, MC_DC10_VALUE
+	dc_sw	11, MC_DC11_VALUE
+	dc_sw	12, MC_DC12_VALUE
+	dc_sw	13, MC_DC13_VALUE
+	dc_sw	14, MC_DC14_VALUE
+	dc_sw	15, MC_DC15_VALUE
+	dc_sw	16, MC_DC16_VALUE
+	dc_sw	17, MC_DC17_VALUE
+	dc_sw	18, MC_DC18_VALUE
+	dc_sw	19, MC_DC19_VALUE
+
+	dc_sw	20, MC_DC20_VALUE
+	dc_sw	21, MC_DC21_VALUE
+	dc_sw	22, MC_DC22_VALUE
+	dc_sw	23, MC_DC23_VALUE
+	dc_sw	24, MC_DC24_VALUE
+	dc_sw	25, MC_DC25_VALUE
+	dc_sw	26, MC_DC26_VALUE
+	dc_sw	27, MC_DC27_VALUE
+	dc_sw	28, MC_DC28_VALUE
+	dc_sw	29, MC_DC29_VALUE
+
+	dc_sw	30, MC_DC30_VALUE
+	dc_sw	31, MC_DC31_VALUE
+	dc_sw	32, MC_DC32_VALUE
+	dc_sw	33, MC_DC33_VALUE
+	dc_sw	34, MC_DC34_VALUE
+	dc_sw	35, MC_DC35_VALUE
+	dc_sw	36, MC_DC36_VALUE
+	dc_sw	37, MC_DC37_VALUE
+	dc_sw	38, MC_DC38_VALUE
+	dc_sw	39, MC_DC39_VALUE
+
+	dc_sw	40, MC_DC40_VALUE
+	dc_sw	41, MC_DC41_VALUE
+	dc_sw	42, MC_DC42_VALUE
+	dc_sw	43, MC_DC43_VALUE
+	dc_sw	44, MC_DC44_VALUE
+	dc_sw	45, MC_DC45_VALUE
+	dc_sw	46, MC_DC46_VALUE
+
+	/* Set start bit of DDR memory controller */
+	li	t2, LTQ_MC_DDR_DC03_MC_START
+	sw	t2, LTQ_MC_DDR_DC_OFFSET(3)(t1)
+
+	/* Wait until DLL has locked and core is ready for data transfers */
+wait_ready:
+	lw	t2, LTQ_MC_GEN_STAT(t0)
+	li	t3, LTQ_MC_GEN_STAT_DLCK_PWRON
+	and	t2, t3
+	bne	t2, t3, wait_ready
+
+finished:
+	jr	ra
+
+	END(ltq_mem_init)
diff --git a/arch/mips/cpu/mips32/danube/pmu.c b/arch/mips/cpu/mips32/danube/pmu.c
new file mode 100644
index 0000000000000000000000000000000000000000..0f7fb8eb329c07ce0dcf300bbf65bb80fc8265af
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/pmu.c
@@ -0,0 +1,118 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PMU_PWDCR_RESERVED		0xFD0C001C
+
+#define LTQ_PMU_PWDCR_TDM		(1 << 25)
+#define LTQ_PMU_PWDCR_PPE_ENET0		(1 << 23)
+#define LTQ_PMU_PWDCR_PPE_ENET1		(1 << 22)
+#define LTQ_PMU_PWDCR_PPE_TC		(1 << 21)
+#define LTQ_PMU_PWDCR_DEU		(1 << 20)
+#define LTQ_PMU_PWDCR_UART1		(1 << 17)
+#define LTQ_PMU_PWDCR_SDIO		(1 << 16)
+#define LTQ_PMU_PWDCR_AHB		(1 << 15)
+#define LTQ_PMU_PWDCR_FPI0		(1 << 14)
+#define LTQ_PMU_PWDCR_PPE		(1 << 13)
+#define LTQ_PMU_PWDCR_GPTC		(1 << 12)
+#define LTQ_PMU_PWDCR_LEDC		(1 << 11)
+#define LTQ_PMU_PWDCR_EBU		(1 << 10)
+#define LTQ_PMU_PWDCR_DSL		(1 << 9)
+#define LTQ_PMU_PWDCR_SPI		(1 << 8)
+#define LTQ_PMU_PWDCR_UART0		(1 << 7)
+#define LTQ_PMU_PWDCR_USB		(1 << 6)
+#define LTQ_PMU_PWDCR_DMA		(1 << 5)
+#define LTQ_PMU_PWDCR_FPI1		(1 << 1)
+#define LTQ_PMU_PWDCR_USB_PHY		(1 << 0)
+
+struct ltq_pmu_regs {
+	u32	rsvd0[7];
+	u32	pwdcr;
+	u32	sr;
+	u32	pwdcr1;
+	u32	sr1;
+};
+
+static struct ltq_pmu_regs *ltq_pmu_regs =
+	(struct ltq_pmu_regs *) CKSEG1ADDR(LTQ_PMU_BASE);
+
+u32 ltq_pm_map(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_PM_CORE:
+		val = LTQ_PMU_PWDCR_UART1 | LTQ_PMU_PWDCR_FPI0 |
+			LTQ_PMU_PWDCR_EBU;
+		break;
+	case LTQ_PM_DMA:
+		val = LTQ_PMU_PWDCR_DMA;
+		break;
+	case LTQ_PM_ETH:
+		val = LTQ_PMU_PWDCR_PPE_ENET0 | LTQ_PMU_PWDCR_PPE_TC |
+			LTQ_PMU_PWDCR_PPE;
+		break;
+	case LTQ_PM_SPI:
+		val = LTQ_PMU_PWDCR_SPI;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_pm_enable(enum ltq_pm_modules module)
+{
+	const unsigned long timeout = 1000;
+	unsigned long timebase;
+	u32 sr, val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_pmu_regs->pwdcr, val);
+
+	timebase = get_timer(0);
+
+	do {
+		sr = ltq_readl(&ltq_pmu_regs->sr);
+		if (~sr & val)
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int ltq_pm_disable(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_pmu_regs->pwdcr, val);
+
+	return 0;
+}
+
+void ltq_pmu_init(void)
+{
+	u32 set, clr;
+
+	clr = ltq_pm_map(LTQ_PM_CORE);
+	set = ~(LTQ_PMU_PWDCR_RESERVED | clr);
+
+	ltq_clrsetbits(&ltq_pmu_regs->pwdcr, clr, set);
+}
diff --git a/arch/mips/cpu/mips32/danube/rcu.c b/arch/mips/cpu/mips32/danube/rcu.c
new file mode 100644
index 0000000000000000000000000000000000000000..8d14917088f440ec391a70a9d14c0a1bac6ecbc4
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/rcu.c
@@ -0,0 +1,92 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_RCU_RD_SRST		(1 << 30)	/* Global SW Reset */
+#define LTQ_RCU_RD_MC		(1 << 14)	/* Memory Controller */
+#define LTQ_RCU_RD_PCI		(1 << 13)	/* PCI core */
+#define LTQ_RCU_RD_DFE_AFE	(1 << 12)	/* Voice DFE/AFE */
+#define LTQ_RCU_RD_DSL_AFE	(1 << 11)	/* DSL AFE */
+#define LTQ_RCU_RD_SDIO		(1 << 10)	/* SDIO core */
+#define LTQ_RCU_RD_DMA		(1 << 9)	/* DMA core */
+#define LTQ_RCU_RD_PPE		(1 << 8)	/* PPE core */
+#define LTQ_RCU_RD_ARC_DFE	(1 << 7)	/* ARC/DFE core */
+#define LTQ_RCU_RD_AHB		(1 << 6)	/* AHB bus */
+#define LTQ_RCU_RD_ENET_MAC1	(1 << 5)	/* Ethernet MAC1 */
+#define LTQ_RCU_RD_USB		(1 << 4)	/* USB and Phy core */
+#define LTQ_RCU_RD_CPU1		(1 << 3)	/* CPU1 subsystem */
+#define LTQ_RCU_RD_FPI		(1 << 2)	/* FPI bus */
+#define LTQ_RCU_RD_CPU0		(1 << 1)	/* CPU0 subsystem */
+#define LTQ_RCU_RD_HRST		(1 << 0)	/* HW reset via HRST pin */
+
+struct ltq_rcu_regs {
+	u32	rsvd0[4];
+	u32	req;		/* Reset request */
+	u32	stat;		/* Reset status */
+	u32	usb_cfg;	/* USB configure */
+	u32	rsvd1[2];
+	u32	pci_rdy;	/* PCI boot ready */
+};
+
+static struct ltq_rcu_regs *ltq_rcu_regs =
+	(struct ltq_rcu_regs *) CKSEG1ADDR(LTQ_RCU_BASE);
+
+u32 ltq_reset_map(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_RESET_CORE:
+	case LTQ_RESET_SOFT:
+		val = LTQ_RCU_RD_SRST | LTQ_RCU_RD_CPU1;
+		break;
+	case LTQ_RESET_DMA:
+		val = LTQ_RCU_RD_DMA;
+		break;
+	case LTQ_RESET_ETH:
+		val = LTQ_RCU_RD_PPE;
+		break;
+	case LTQ_RESET_HARD:
+		val = LTQ_RCU_RD_HRST;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_reset_activate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+int ltq_reset_deactivate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
diff --git a/arch/mips/cpu/mips32/danube/u-boot.lds b/arch/mips/cpu/mips32/danube/u-boot.lds
new file mode 100644
index 0000000000000000000000000000000000000000..97653841086aa7fd91f70eeb4dc9f516f41f245c
--- /dev/null
+++ b/arch/mips/cpu/mips32/danube/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2003 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradlittlemips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text : {
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : {
+		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
+	}
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+	.sdata : {
+		*(.sdata*)
+	}
+
+	. = .;
+	_gp = ALIGN(16) + 0x7ff0;
+
+	.got : {
+		__got_start = .;
+		*(.got)
+		__got_end = .;
+	}
+
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	.u_boot_cmd : {
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	. = ALIGN(4);
+	__image_copy_end = .;
+	uboot_end_data = .;
+
+	.bss (NOLOAD) : {
+		__bss_start = .;
+		*(.bss*)
+		*(.sbss*)
+		. = ALIGN(4);
+		__bss_end = .;
+	}
+
+	. = ALIGN(4);
+	__end = .;
+	uboot_end = .;
+}
diff --git a/arch/mips/cpu/mips32/start.S b/arch/mips/cpu/mips32/start.S
index 9c1b2f76d09bcff61c4d617da0795b7f35b9085c..3ac9714ff5da9fefc7d6e7926d3797efa95c3f72 100644
--- a/arch/mips/cpu/mips32/start.S
+++ b/arch/mips/cpu/mips32/start.S
@@ -55,163 +55,61 @@
 #endif
 	.endm
 
-#define RVECENT(f,n) \
-   b f; nop
-#define XVECENT(f,bev) \
-   b f     ;           \
-   li k0,bev
-
-	.set noreorder
-
-	.globl _start
-	.text
-_start:
-	RVECENT(reset,0)			# U-boot entry point
-	RVECENT(reset,1)			# software reboot
-#ifdef CONFIG_SYS_XWAY_EBU_BOOTCFG
 	/*
 	 * Almost all Lantiq XWAY SoC devices have an external bus unit (EBU) to
 	 * access external NOR flashes. If the board boots from NOR flash the
 	 * internal BootROM does a blind read at address 0xB0000010 to read the
 	 * initial configuration for that EBU in order to access the flash
 	 * device with correct parameters. This config option is board-specific.
+	 * Default to 0 if this option is not set.
 	 */
-	.word CONFIG_SYS_XWAY_EBU_BOOTCFG
-	.word 0x00000000
+	.macro lantiq_soc_bootcfg
+	.set	push
+	.set	noreorder
+	.org	0x10
+#ifdef CONFIG_SYS_XWAY_EBU_BOOTCFG
+	.word	CONFIG_SYS_XWAY_EBU_BOOTCFG
 #else
-	RVECENT(romReserved,2)
+	.word	0
 #endif
-	RVECENT(romReserved,3)
-	RVECENT(romReserved,4)
-	RVECENT(romReserved,5)
-	RVECENT(romReserved,6)
-	RVECENT(romReserved,7)
-	RVECENT(romReserved,8)
-	RVECENT(romReserved,9)
-	RVECENT(romReserved,10)
-	RVECENT(romReserved,11)
-	RVECENT(romReserved,12)
-	RVECENT(romReserved,13)
-	RVECENT(romReserved,14)
-	RVECENT(romReserved,15)
-	RVECENT(romReserved,16)
-	RVECENT(romReserved,17)
-	RVECENT(romReserved,18)
-	RVECENT(romReserved,19)
-	RVECENT(romReserved,20)
-	RVECENT(romReserved,21)
-	RVECENT(romReserved,22)
-	RVECENT(romReserved,23)
-	RVECENT(romReserved,24)
-	RVECENT(romReserved,25)
-	RVECENT(romReserved,26)
-	RVECENT(romReserved,27)
-	RVECENT(romReserved,28)
-	RVECENT(romReserved,29)
-	RVECENT(romReserved,30)
-	RVECENT(romReserved,31)
-	RVECENT(romReserved,32)
-	RVECENT(romReserved,33)
-	RVECENT(romReserved,34)
-	RVECENT(romReserved,35)
-	RVECENT(romReserved,36)
-	RVECENT(romReserved,37)
-	RVECENT(romReserved,38)
-	RVECENT(romReserved,39)
-	RVECENT(romReserved,40)
-	RVECENT(romReserved,41)
-	RVECENT(romReserved,42)
-	RVECENT(romReserved,43)
-	RVECENT(romReserved,44)
-	RVECENT(romReserved,45)
-	RVECENT(romReserved,46)
-	RVECENT(romReserved,47)
-	RVECENT(romReserved,48)
-	RVECENT(romReserved,49)
-	RVECENT(romReserved,50)
-	RVECENT(romReserved,51)
-	RVECENT(romReserved,52)
-	RVECENT(romReserved,53)
-	RVECENT(romReserved,54)
-	RVECENT(romReserved,55)
-	RVECENT(romReserved,56)
-	RVECENT(romReserved,57)
-	RVECENT(romReserved,58)
-	RVECENT(romReserved,59)
-	RVECENT(romReserved,60)
-	RVECENT(romReserved,61)
-	RVECENT(romReserved,62)
-	RVECENT(romReserved,63)
-	XVECENT(romExcHandle,0x200)	# bfc00200: R4000 tlbmiss vector
-	RVECENT(romReserved,65)
-	RVECENT(romReserved,66)
-	RVECENT(romReserved,67)
-	RVECENT(romReserved,68)
-	RVECENT(romReserved,69)
-	RVECENT(romReserved,70)
-	RVECENT(romReserved,71)
-	RVECENT(romReserved,72)
-	RVECENT(romReserved,73)
-	RVECENT(romReserved,74)
-	RVECENT(romReserved,75)
-	RVECENT(romReserved,76)
-	RVECENT(romReserved,77)
-	RVECENT(romReserved,78)
-	RVECENT(romReserved,79)
-	XVECENT(romExcHandle,0x280)	# bfc00280: R4000 xtlbmiss vector
-	RVECENT(romReserved,81)
-	RVECENT(romReserved,82)
-	RVECENT(romReserved,83)
-	RVECENT(romReserved,84)
-	RVECENT(romReserved,85)
-	RVECENT(romReserved,86)
-	RVECENT(romReserved,87)
-	RVECENT(romReserved,88)
-	RVECENT(romReserved,89)
-	RVECENT(romReserved,90)
-	RVECENT(romReserved,91)
-	RVECENT(romReserved,92)
-	RVECENT(romReserved,93)
-	RVECENT(romReserved,94)
-	RVECENT(romReserved,95)
-	XVECENT(romExcHandle,0x300)	# bfc00300: R4000 cache vector
-	RVECENT(romReserved,97)
-	RVECENT(romReserved,98)
-	RVECENT(romReserved,99)
-	RVECENT(romReserved,100)
-	RVECENT(romReserved,101)
-	RVECENT(romReserved,102)
-	RVECENT(romReserved,103)
-	RVECENT(romReserved,104)
-	RVECENT(romReserved,105)
-	RVECENT(romReserved,106)
-	RVECENT(romReserved,107)
-	RVECENT(romReserved,108)
-	RVECENT(romReserved,109)
-	RVECENT(romReserved,110)
-	RVECENT(romReserved,111)
-	XVECENT(romExcHandle,0x380)	# bfc00380: R4000 general vector
-	RVECENT(romReserved,113)
-	RVECENT(romReserved,114)
-	RVECENT(romReserved,115)
-	RVECENT(romReserved,116)
-	RVECENT(romReserved,116)
-	RVECENT(romReserved,118)
-	RVECENT(romReserved,119)
-	RVECENT(romReserved,120)
-	RVECENT(romReserved,121)
-	RVECENT(romReserved,122)
-	RVECENT(romReserved,123)
-	RVECENT(romReserved,124)
-	RVECENT(romReserved,125)
-	RVECENT(romReserved,126)
-	RVECENT(romReserved,127)
+	.word	0
+	.set	pop
+	.endm
+
+	.macro reset_vector branch
+	.set	push
+	.set	noreorder
+	b	\branch
+	 nop
+	.set	pop
+	.endm
+
+	.macro exception_vector offset branch
+	.set	push
+	.set	noreorder
+	.org	\offset
+	b	\branch
+	 li	k0, \offset
+	.set	pop
+	.endm
+
+	.set noreorder
+
+	.globl _start
+	.text
+_start:
+	reset_vector reset			# U-boot entry point
+	reset_vector reset			# software reboot
+
+	lantiq_soc_bootcfg 			# Lantiq SoC Boot config word
+
+	exception_vector 0x200, halt		# TLB miss
+	exception_vector 0x280, halt		# XTLB miss
+	exception_vector 0x300, halt		# Cache error
+	exception_vector 0x380, halt		# General
+	exception_vector 0x400, halt		# Interrupt, CauseIV
+	exception_vector 0x480, ejtag_exception	# EJTAG debug
 
-	/*
-	 * We hope there are no more reserved vectors!
-	 * 128 * 8 == 1024 == 0x400
-	 * so this is address R_VEC+0x400 == 0xbfc00400
-	 */
 	.align 4
 reset:
 
@@ -228,7 +126,7 @@ reset:
 	mtc0	zero, CP0_COUNT
 	mtc0	zero, CP0_COMPARE
 
-#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+#if !defined(CONFIG_SKIP_LOWLEVEL_INIT) || defined(CONFIG_SYS_DISABLE_CACHE)
 	/* CONFIG0 register */
 	li	t0, CONF_CM_UNCACHED
 	mtc0	t0, CP0_CONFIG
@@ -378,8 +276,12 @@ in_ram:
 	.end	relocate_code
 
 	/* Exception handlers */
-romReserved:
-	b	romReserved
+ejtag_exception:
+	/* Set DEPC to halt and exit debug mode */
+	la	k1, halt
+	mtc0	k1, CP0_DEPC
+	deret
+	 nop
 
-romExcHandle:
-	b	romExcHandle
+halt:
+	b	halt
diff --git a/arch/mips/cpu/mips32/vrx200/Makefile b/arch/mips/cpu/mips32/vrx200/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..1b9140c9b010cd83d155f14ea9daf4f67ca41672
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/Makefile
@@ -0,0 +1,34 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+COBJS-y	+= cgu.o chipid.o cpu.o ebu.o gphy.o gpio.o mem.o pmu.o rcu.o
+SOBJS-y	+= cgu_init.o mem_init.o lowlevel_init.o
+SOBJS-y	+= gphy_fw.o
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/vrx200/cgu.c b/arch/mips/cpu/mips32/vrx200/cgu.c
new file mode 100644
index 0000000000000000000000000000000000000000..57ed442f72ef020e29cd37d63a900a5718af1b65
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu.c
@@ -0,0 +1,139 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_MASK		(0x3 << LTQ_CGU_SYS_OCP_SHIFT)
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_MASK		(0xF << LTQ_CGU_SYS_CPU_SHIFT)
+
+#define LTQ_CGU_IFCLK_GPHY_SEL_SHIFT	2
+#define LTQ_CGU_IFCLK_GPHY_SEL_MASK	(0x7 << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT)
+
+struct ltq_cgu_regs {
+	u32	rsvd0;
+	u32	pll0_cfg;	/* PLL0 config */
+	u32	pll1_cfg;	/* PLL1 config */
+	u32	sys;		/* System clock */
+	u32	clk_fsr;	/* Clock frequency select */
+	u32	clk_gsr;	/* Clock gating status */
+	u32	clk_gcr0;	/* Clock gating control 0 */
+	u32	clk_gcr1;	/* Clock gating control 1 */
+	u32	update;		/* CGU update control */
+	u32	if_clk;		/* Interface clock */
+	u32	ddr;		/* DDR memory control */
+	u32	ct1_sr;		/* CT status 1 */
+	u32	ct_kval;	/* CT K value */
+	u32	pcm_cr;		/* PCM control */
+	u32	pci_cr;		/* PCI clock control */
+	u32	rsvd1;
+	u32	gphy1_cfg;	/* GPHY1 config */
+	u32	gphy0_cfg;	/* GPHY0 config */
+	u32	rsvd2[6];
+	u32	pll2_cfg;	/* PLL2 config */
+};
+
+static struct ltq_cgu_regs* ltq_cgu_regs =
+	(struct ltq_cgu_regs *) CKSEG1ADDR(LTQ_CGU_BASE);
+
+static inline u32 ltq_cgu_sys_readl(u32 mask, u32 shift)
+{
+	return (ltq_readl(&ltq_cgu_regs->sys) & mask) >> shift;
+}
+
+unsigned long ltq_get_io_region_clock(void)
+{
+	unsigned int ocp_sel;
+	unsigned long clk, cpu_clk;
+
+	cpu_clk = ltq_get_cpu_clock();
+
+	ocp_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_OCP_MASK,
+			LTQ_CGU_SYS_OCP_SHIFT);
+
+	switch (ocp_sel) {
+	case 0:
+		/* OCP ratio 1 */
+		clk = cpu_clk;
+		break;
+	case 2:
+		/* OCP ratio 2 */
+		clk = cpu_clk / 2;
+		break;
+	case 3:
+		/* OCP ratio 2.5 */
+		clk = (cpu_clk * 2) / 5;
+		break;
+	case 4:
+		/* OCP ratio 3 */
+		clk = cpu_clk / 3;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_cpu_clock(void)
+{
+	unsigned int cpu_sel;
+	unsigned long clk;
+
+	cpu_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_CPU_MASK,
+			LTQ_CGU_SYS_CPU_SHIFT);
+
+	switch (cpu_sel) {
+	case 0:
+		clk = CLOCK_600_MHZ;
+		break;
+	case 1:
+		clk = CLOCK_500_MHZ;
+		break;
+	case 2:
+		clk = CLOCK_393_MHZ;
+		break;
+	case 3:
+		clk = CLOCK_333_MHZ;
+		break;
+	case 5:
+	case 6:
+		clk = CLOCK_197_MHZ;
+		break;
+	case 7:
+		clk = CLOCK_166_MHZ;
+		break;
+	case 4:
+	case 8:
+	case 9:
+		clk = CLOCK_125_MHZ;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_bus_clock(void)
+{
+	return ltq_get_io_region_clock();
+}
+
+void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk)
+{
+	ltq_clrbits(&ltq_cgu_regs->if_clk, LTQ_CGU_IFCLK_GPHY_SEL_MASK);
+	ltq_setbits(&ltq_cgu_regs->if_clk, clk << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/cgu_init.S b/arch/mips/cpu/mips32/vrx200/cgu_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..1b2998fde36e698994e281dcbd10908f236256fd
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu_init.S
@@ -0,0 +1,117 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* RCU module register */
+#define LTQ_RCU_RST_REQ		0x0010	/* Reset request */
+#define LTQ_RCU_RST_REQ_VALUE		0xF0000020
+
+/* CGU module register */
+#define LTQ_CGU_PLL0_CFG		0x0004	/* PLL0 config */
+#define LTQ_CGU_PLL1_CFG		0x0008	/* PLL1 config */
+#define LTQ_CGU_PLL2_CFG		0x0060	/* PLL2 config */
+#define LTQ_CGU_SYS			0x000C	/* System clock */
+#define LTQ_CGU_CLK_FSR		0x0010	/* Clock frequency select */
+
+/* Valid SYS.CPU values */
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_600_MHZ	0x0
+#define LTQ_CGU_SYS_CPU_500_MHZ	0x1
+#define LTQ_CGU_SYS_CPU_393_MHZ	0x2
+#define LTQ_CGU_SYS_CPU_333_MHZ	0x3
+#define LTQ_CGU_SYS_CPU_197_MHZ	0x5
+#define LTQ_CGU_SYS_CPU_166_MHZ	0x7
+#define LTQ_CGU_SYS_CPU_125_MHZ	0x9
+
+/* Valid SYS.OCP values */
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_1		0x0
+#define LTQ_CGU_SYS_OCP_2		0x2
+#define LTQ_CGU_SYS_OCP_2_5		0x3
+#define LTQ_CGU_SYS_OCP_3		0x4
+
+/* Valid CLK_FSR.ETH values */
+#define LTQ_CGU_CLK_FSR_ETH_SHIFT	24
+#define LTQ_CGU_CLK_FSR_ETH_50_MHZ	0x0
+#define LTQ_CGU_CLK_FSR_ETH_25_MHZ	0x1
+#define LTQ_CGU_CLK_FSR_ETH_2_5_MHZ	0x2
+#define LTQ_CGU_CLK_FSR_ETH_125_MHZ	0x3
+
+/* Valid CLK_FSR.PPE values */
+#define LTQ_CGU_CLK_FSR_PPE_SHIFT	16
+#define LTQ_CGU_CLK_FSR_PPE_500_MHZ	0x0	/* Overclock frequency */
+#define LTQ_CGU_CLK_FSR_PPE_450_MHZ	0x1	/* High frequency */
+#define LTQ_CGU_CLK_FSR_PPE_400_MHZ	0x2	/* Low frequency */
+
+#if (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_500_DDR_250)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_500_MHZ
+#define LTQ_CGU_SYS_OCP_CONFIG		LTQ_CGU_SYS_OCP_2
+#define LTQ_CGU_CLK_FSR_ETH_CONFIG	LTQ_CGU_CLK_FSR_ETH_125_MHZ
+#define LTQ_CGU_CLK_FSR_PPE_CONFIG	LTQ_CGU_CLK_FSR_PPE_450_MHZ
+#else
+#error "Invalid system clock configuration!"
+#endif
+
+/* Build register values */
+#define LTQ_CGU_SYS_VALUE	((LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU_SHIFT) | \
+					LTQ_CGU_SYS_OCP_CONFIG)
+
+#define LTQ_CGU_CLK_FSR_VALUE	((LTQ_CGU_CLK_FSR_ETH_CONFIG << \
+					LTQ_CGU_CLK_FSR_ETH_SHIFT) | \
+				(LTQ_CGU_CLK_FSR_PPE_CONFIG << \
+					LTQ_CGU_CLK_FSR_PPE_SHIFT))
+
+/* Reset values for PLL registers for usage with 36 MHz crystal */
+#define PLL0_36MHZ_CONFIG	0x00B01F21
+#define PLL1_36MHZ_CONFIG	0x9BA67015
+#define PLL2_36MHZ_CONFIG	0x293002C1
+
+LEAF(ltq_cgu_init)
+	/* Load current CGU register values */
+	li	t0, (LTQ_CGU_BASE | KSEG1)
+	lw	t1, LTQ_CGU_SYS(t0)
+	lw	t2, LTQ_CGU_CLK_FSR(t0)
+
+	/* Load target CGU register values */
+	li	t3, LTQ_CGU_SYS_VALUE
+	li	t4, LTQ_CGU_CLK_FSR_VALUE
+
+	/* Only update registers if values differ */
+	bne	t1, t3, update
+	beq	t2, t4, finished
+
+update:
+	/* Store target register values */
+	sw	t3, LTQ_CGU_SYS(t0)
+	sw	t4, LTQ_CGU_CLK_FSR(t0)
+
+	li	t1, PLL0_36MHZ_CONFIG
+	sw	t1, LTQ_CGU_PLL0_CFG(t0)
+	li	t1, PLL1_36MHZ_CONFIG
+	sw	t1, LTQ_CGU_PLL1_CFG(t0)
+	li	t1, PLL2_36MHZ_CONFIG
+	sw	t1, LTQ_CGU_PLL2_CFG(t0)
+
+	/* Perform software reset to activate new clock config */
+	li	t0, (LTQ_RCU_BASE | KSEG1)
+	li	t1, LTQ_RCU_RST_REQ_VALUE
+	sw	t1, LTQ_RCU_RST_REQ(t0)
+
+wait_reset:
+	b	wait_reset
+
+finished:
+	jr	ra
+
+	END(ltq_cgu_init)
diff --git a/arch/mips/cpu/mips32/vrx200/chipid.c b/arch/mips/cpu/mips32/vrx200/chipid.c
new file mode 100644
index 0000000000000000000000000000000000000000..fdb420f1e8ce1d5acc8f3bdbca5c10f805ceec86
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/chipid.c
@@ -0,0 +1,56 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_CHIPID_VERSION_SHIFT	28
+#define LTQ_CHIPID_VERSION_MASK		(0x7 << LTQ_CHIPID_VERSION_SHIFT)
+#define LTQ_CHIPID_PNUM_SHIFT		12
+#define LTQ_CHIPID_PNUM_MASK		(0xFFFF << LTQ_CHIPID_PNUM_SHIFT)
+
+struct ltq_chipid_regs {
+	u32	manid;		/* Manufacturer identification */
+	u32	chipid;		/* Chip identification */
+};
+
+static struct ltq_chipid_regs* ltq_chipid_regs =
+	(struct ltq_chipid_regs *) CKSEG1ADDR(LTQ_CHIPID_BASE);
+
+unsigned int ltq_chip_version_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return ((chipid & LTQ_CHIPID_VERSION_MASK) >> LTQ_CHIPID_VERSION_SHIFT);
+}
+
+unsigned int ltq_chip_partnum_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return ((chipid & LTQ_CHIPID_PNUM_MASK) >> LTQ_CHIPID_PNUM_SHIFT);
+}
+
+const char* ltq_chip_partnum_str(void)
+{
+	enum ltq_chip_partnum partnum = ltq_chip_partnum_get();
+
+	switch (partnum) {
+	case LTQ_SOC_VRX288:
+		return "VRX288";
+	default:
+		printf("Unknown partnum: %x\n", partnum);
+	}
+
+	return "";
+}
diff --git a/arch/mips/cpu/mips32/vrx200/config.mk b/arch/mips/cpu/mips32/vrx200/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..13d3d4c6566ceb243e4c026397d08f17d8df8c20
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/config.mk
@@ -0,0 +1,22 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PF_CPPFLAGS_XRX := $(call cc-option,-mtune=34kc,)
+PLATFORM_CPPFLAGS += $(PF_CPPFLAGS_XRX)
+
+ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_SYS_BOOT_EVA
+ALL-y += $(obj)u-boot.bin.lzma
+endif
+ifdef CONFIG_SYS_BOOT_SFSPL
+ALL-y += $(obj)u-boot.ltq.sfspl
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += $(obj)u-boot.ltq.lzo.sfspl
+ALL-$(CONFIG_SPL_LZMA_SUPPORT) += $(obj)u-boot.ltq.lzma.sfspl
+endif
+endif
+
+LDSCRIPT := $(TOPDIR)/$(CPUDIR)/$(SOC)/u-boot.lds
diff --git a/arch/mips/cpu/mips32/vrx200/cpu.c b/arch/mips/cpu/mips32/vrx200/cpu.c
new file mode 100644
index 0000000000000000000000000000000000000000..f451858e2506a688da89d800174d7cdba1711e68
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cpu.c
@@ -0,0 +1,64 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/cpu.h>
+
+int arch_cpu_init(void)
+{
+	ltq_pmu_init();
+	ltq_ebu_init();
+
+	return 0;
+}
+
+void ltq_chip_print_info(void)
+{
+	char buf[32];
+
+	printf("SoC:   Lantiq %s v1.%u\n", ltq_chip_partnum_str(),
+		ltq_chip_version_get());
+	printf("CPU:   %s MHz\n", strmhz(buf, ltq_get_cpu_clock()));
+	printf("IO:    %s MHz\n", strmhz(buf, ltq_get_io_region_clock()));
+	printf("BUS:   %s MHz\n", strmhz(buf, ltq_get_bus_clock()));
+	printf("BOOT:  %s\n", ltq_boot_select_str());
+}
+
+void _machine_restart(void)
+{
+	ltq_reset_activate(LTQ_RESET_CORE);
+}
+
+const char *ltq_boot_select_str(void)
+{
+	enum ltq_boot_select boot = ltq_boot_select();
+
+	switch (boot) {
+	case LTQ_BOOT_NOR_NO_BOOTROM:
+		return "NOR (no BootROM)";
+	case LTQ_BOOT_RGMII1:
+		return "RGMII1";
+	case LTQ_BOOT_NOR:
+		return "NOR";
+	case LTQ_BOOT_UART_NO_EEPROM:
+		return "UART (no EEPROM)";
+	case LTQ_BOOT_PCI:
+		return "PCI";
+	case LTQ_BOOT_UART:
+		return "UART";
+	case LTQ_BOOT_SPI:
+		return "SPI";
+	case LTQ_BOOT_NAND:
+		return "NAND";
+	default:
+		printf("Unknown boot select: %d\n", boot);
+		return "";
+	}
+}
diff --git a/arch/mips/cpu/mips32/vrx200/ebu.c b/arch/mips/cpu/mips32/vrx200/ebu.c
new file mode 100644
index 0000000000000000000000000000000000000000..42f10e9cdd3925150b5299300931d281485455a4
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/ebu.c
@@ -0,0 +1,57 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_EBU_CON_0_RST_VAL	0x8001D7FF
+
+#define LTQ_EBU_CON_WRDIS	(1 << 31)
+
+struct ltq_ebu_regs {
+	u32	clc;
+	u32	rsvd0;
+	u32	id;
+	u32	rsvd1;
+	u32	con;
+	u32	rsvd2[3];
+	u32	addr_sel_0;
+	u32	addr_sel_1;
+	u32	addr_sel_2;
+	u32	addr_sel_3;
+	u32	rsvd3[12];
+	u32	con_0;
+	u32	con_1;
+	u32	con_2;
+	u32	con_3;
+};
+
+static struct ltq_ebu_regs* ltq_ebu_regs =
+	(struct ltq_ebu_regs *) CKSEG1ADDR(LTQ_EBU_BASE);
+
+void ltq_ebu_init(void)
+{
+	/*
+	 * Map EBU region 0 to range 0x10000000-0x13ffffff and enable
+	 * region control. This supports up to 32 MiB NOR flash in
+	 * bank 0.
+	 */
+	ltq_writel(&ltq_ebu_regs->addr_sel_0, 0x10000011);
+
+	/*
+	 * Restore reset value to fix modifications by internal BootROM.
+	 * Also disable write protection.
+	 */
+	ltq_writel(&ltq_ebu_regs->con_0,
+			LTQ_EBU_CON_0_RST_VAL & ~LTQ_EBU_CON_WRDIS);
+}
+
+void * flash_swap_addr(unsigned long addr)
+{
+	return (void *)(addr ^ 2);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.bin b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.bin
new file mode 100644
index 0000000000000000000000000000000000000000..cdf3d3063405c1239d15bae873e11f4ad8644e0f
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a1x.bin
@@ -0,0 +1,224 @@
+222 222  2                              ]      `     [     
+          3     T         Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs   "   ?(  $  3. /+!'-0 !3!F!/!)  Y#l!!h!  ! !" "'"Mt#i- +"$$ !D ! !" 3 3!F!NY!v !    ! !E(. ") "u/33@" u/@3P""us|   ""S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""C`u1qqDCuu~~qq"A$4$T4$4 "uuu"tKtL"uc c#0
+0t ~/ 4
+cc2uc c TT0T1TTp$$mpp$$pp$p`$ T0D DD    TTT D (  %T OT   TT3T  OT TOOTTT OTT T ?T0=T   D D  T` TT OT T`pTdT
+`TpT*oT
+`+*TTOT$T$!`$4`$=`$_`$d`$g`qpTT ZTQTDTp#`T"T+4Tc c2$T$"``9`p$>b\pYpT"$Ep@pT"D,y"@t}peet	`etp`e"uc c te,@`p\e[e_` s`sY[_Z\\`[\[Q0|t
+4D?T&0u+V UVV%U5u`UVu U+V	 Uu?Vc c24^2_`ND" ucc te2@c c2ttTTdtT?Tdtx@x)@xxp%vxxxT[Qx`8AT`[Qx8AT[Qx`8AWX$ 4,t @,tAPt03xBTX_Tt`,X^T`QxH@tB39QW`x@t'3BTWQt`3Bdp!`TT6RcTB\D"S	T$`t3_S"0+@TT]Tt3T_"uc ceT0D D  tecc2uu2uu2uu2 G		`p" " tq~ #~}$/ t>#$"('dPd@u? %	3xt$@t ~33%5
+t%5} |(@'(' u"D D5D4"D &
+ " |$ 4pe
+"|T; =<>;<p %
+
+<;;<N`$b`$`$?u?dP=>?TdE@7$EEE%0tEEt??%d=P>=>-=>p=E0?`=E>=+} |>
+0$??.@t|>=
+} =>`?@t??%<p<; ~"0T\`$|`$p`$|`$`$%`$6p$H"T,VP$p`",,"@Dtt"WFUHPG_RV_YP 
+9:LOT
+D% } "9OfinI	 
+t 
+0D
+1D	2D	 E	 
+pecxnoitE	 
+
+tix C"\[ba^] su_u`u~ j1}Ja|}a|1*1)epGDDG""
+u Cu"TGTHOTJILKG"T%TTHONMPO"DT DTttT$t "T0c  |0| ~} (~?$~3.~~ /~+~'~~-0~/~)~~  #~h ~`s! ~u^u"]HI u"aububp^e]ea]`b^aab"' ~]u Y^u" ~",u"]u~"g^1 ]u^u"" ~6"]u"H^uB ~u`u_ ""        "    Iy@e               0                         ?  @ H  ?    8     "atKLt
+ 0T0Q  `"t " TT t`1DaD D@TTT t ~ t5t~t+~*TOT	DTt	jt?TV0'%0Tt$QX 'TX'|Tt$Qx 'Tx'T0%T$tQQ 'T&Q'T$tQa 'TQa     'Tt$Qp 'TQp 'Q 'TQ ' Q'TQ      T"t$tT&d@.t0/&T0"" } |##~  pd# ~@ | {L}~{ ~d# ``d#a0(at tttt@tttttttt(@tttTT0?T<{ zxTT~Kx 33ON0T< z{xTTKx ~33NO0T<{ zxTT~Kx 33ON0T<{ zxTT~Kx 33ONTTOT%T"O%$'&(,T$`$`ipt)([0y%U@L$ 4t,-$'&' 4&Ut*,-U%+$-,\](L*M+)$'&' 4&t(%)$$%$ 4()` d0>8d#pT3(OT33TT33,OT"!tAa TD 
+It*\t&Jt+tt,0t" t%tDDT\DD	Tt_^]
+tt`TDDTTDTTD     TT3D:DD;DDTD<DT=DDDT8DDTTDIDTTtJKPDTTDDRTTIuDvDTtDDDD"txxxxxvxvtgtptt t@t@t t6tD""aMA 
+nitinIcA 
+ 
+tON		TAM- 
+HC~0  T  !0 0_u"~`u 0T3T_u"B`uTu_u_uL`Q`u_u""G`u
+0  T T0/dT!` T!04xT% MT1mT`D5TT1OT 1T`oD5T T333T1OT/pd1)D?T@/TT1@D?DTDDu1TvOT1TTvOT/TTwO1TpdT_u"y`u@T1`,`2p_u"``uu_uu"=``u_"[u`u_]u"V^u" "Tu0`u_"~  ]u" ^u`s ~u^u"]p^ebea`]^a]bbac"cTu]u8^0	dTa`dTa`
+n^_o0 T0gT\0?1DT00T	D1T10?T0?TD1@qaDcac n
+0T1Do'0T1
+DT(o0TT1Do0T1TTcDc00T1Dn?T	0D1?0nT$00T1 D
+"10DTT1Dcc0c ~u]u3^D4~"&T	@D"0T$T	Tx
+0T$xT$p`jpd~pdaDV=plxxpfpfx7@Dvx,x@ t@ 	T33TT0O@D4"   "        		D!XR		
+x%:			 d%XTx% :T	 
+siDxA	 
+-lib	 
+DC-SL 
+khDP		uaF- 
+tlKCA	 
+D-A-C	 
+KCXR		=MSF 
+d%-PN	tiaW		 
+SFXTd%=MA	 
+
+seR-		 01 >x 0 - s - DF/ DHS/ MEE/ P- Ed%:S 
+]u3^uT T  TDtxT/T$34 u xEOKattL  /T!TTDD"D(`suuuu|xdTdddT  T #     ?T T .~p^e]e]`Iq^Tdd0 ~Dddtebp^`]eaa]b^abdTd10 ~#T | ~DddtT0Tx	
+Dccxxc	pTxcTx~x@`dccT&0x x@ ccD v~xvtTxt TT333cOTccTcOTcOTTTccO0d)20)T=T~T} | 
+x9$>}"|PD=Dx"TtT l ~"r.~40 txv4v#?TqtTT  t]uP^u$"?T'00 '^ ?TV3DTTT3O!TDT3T  DT tt,tt TT3D!TOT3TT3D  DT Ttt,tt >3%T%#NT333TOT " ~"xtxvv*vvzxvlkvxxulvgfhTTTTN33OT3(T  ~~Pp }}MT^MTTTTN33OT3TTcOTc
+TTT#cq c
+T'0?tx'PvxclvTTTcucO^u']xvt6vT
+`dxlkdM0E@TTkkOlkx]u@^u(klx 'v	@x@ d cwxxpF#40?T5DxqT%3x$4w*x!T#Tpo`D5xxxqvvxlvxvxlvv*v'q) hp7`cyx	0vz%vzP0dvzx v DD!hu cx0vzvT!Thz%P0dzxvvT!uTch0vzxvTT!hz"P0dzxvv  D!u D0"h ~,+D#T?qvtxxLvvzcvT0Tc333TT cOTTTcOTtcPcT !tt]uj^u#c TzP4 ~D]u^u$vzx"v#0"@ ~D@DDkk@xT`d]u3^udL0lkx@)]u2"^uxTkkpleke]u`3^uDk"k@A  ~sHvx$g$```p$gu3k0Tk(TldpNgukTl
+dupNggg=`$$}`!p`$	Ak
+lk TOT
+TTTOx\(lT  Pp ~~x6`NTOTT?TTOlkxT
+kldg`kl4 DP ~ |gDk3TT33cOTcc T T333TTccOfT0dx	@ x>p0?T-T$0T T0u*]uu"^^u#]"jT`du]u 3^~\ xkfld`$|`$app$aa`(T P p ~N~TT`_NfuO0 T)0fu`*T  Tfufu$ff?`)p`[p`$`$outu
+onnDounnTnnn DtonTToOTTo?ToOTTooOTTo%%oOTToTTooODnnxKyT	xno `TOT333noTTnnOf ~ |fpdf ET[0ncoTTTnnOno Tfu&0!cTTnOTnnodu0TplekexMpvU@Tc`oTf; 0T(]u+^u fT  D4"klx~"y xT1xP ~x1T ~1T ~1T0 ~ ~1dTpT~0  ~1?T~0  ~T1 |u^u.]"TTu_u""`            001	esab 1T- 
+SN  ~"        PSA		d%:CGA 	d%:%:M H 	d
+d%:bA	 
+tsiaW	  
+tiixE		 
+t01CDD	 
+001C	 
+0
+NCIHT	 	 
+D
+CGA:P	 
+d% XE	 	 
+C CDA
+REB 	
+	 b      b    K K    G(%0+V<6GA3Q?LZUb^mjfpmAvs}zx})|b~0  8(4$<,2":*
+6&>.1!9)	5%=-3#;+7'?/QPSR,,,%8-,59.<-5"<"333"30d ~2|g  	 ~ |h~  |i ~j |0 0"QjT"Du-]u0"^1
+ vtx"vtuP^u.]1"}33jT33iEOT h~ TgT0"OQz { ~QQjD0k
+]uh^u'0"Q1z { ~QQ?cuDj0k`chc
+Dju"^u']"$ 4 Ld{"p z$#&%+'(u )u'fP&Tpd#pk< 3n%~$ 4t$)) 4(())$4(( $% k"~ 3 k0>.ti: ~>k0@tQiuz{|} Q +juD^u-]"YTj~~Q |  }$#&%&$%'#)( 0u*u@1u3u 232@@ +.,,1@0--23@3%../<=/<==</?>*.)98*/);:+t7@ %+@$ 4t67$%+^ 4t54+/$%4 t67 t$%+ 44t:53;63RS7PQ 1?>3345RSPQ 1 C+B:A9@8?>336S7QRP 1:3;43S5QR1P  GFEDKJ=H<KIIJw1HJKHIC%K5JKJBA5I5HIH@HI(.O'KJH<KI=IJw1HJKHIKKCBJIJIA@HIH/H'(JO8KI9HJKHIKw1IJKHKG%F5JIJIE5D5HIH.HKKJ9H8KIIJw1HJKHIGKJKJFEIHIHDHIK/1.++%-/+.a,0101%3323a2."'(u%5"('*)-u0+- -%,%@t
+++,+,+H@.,/+'(/O,.'(+O)*.,/)*+/K,.0K-@-"@)*u%5"Tj $%433$% 4>/%$ 4q")gu@^u-]]u"/^u"q"g@u+]uu"B^^u"]i"]lp$m$#>%(tgmmll5iuj$pml$>$ju#$$#>ji 1/0#$,+p,,+,+,+p,,p++/,p+,+0,,p++1+"$% 433SQRP!/ -.%+, $433RSPQ !///>.=-.,-,<./0u-423E11324BpB4u	2311 4023!134121 ~%0000 ~x0SuRuPQ4 !23%144432535211$u"2%'&#u#((P$$(%((@%(%''&&5##@@hpml)	hu*$*)>ghm%(t5mll'0x&/1%$)* ~_cuhji"p:d`u:y@{	zxv'v	 txx		tt	t8pq+`"9	jD08D ~ 	t		ut^u/]"TjTDtlmtnto ~"Oguhujui lu mumlf$e>ktp>tt6tt@tCtBDq"u!]u"^mnmnTjm"n`s ~u^u,]+DdTp   0-]uk^up^ebea`]^a]badb"Tdd"kTtt\_^]`\~tEeGgtt`k"t5t51t=kp>Lt.t=	tt8tttt     ttt67tt6jTtlmntophgiu luj mu`$"p
+u#]uu"J^^u*]]u"i^u-0"% ~D~", T  Tu_u~"`C ]u/^u" ~"Iu lu miug]uh]^u""g]u@f^u.0d"0 u!]u"^F0d# ~#U |fpefe#pk%u$$u%u phhu%(tgmmll5ml$>f0e>h ~} |t%$%%@$5%%$x$$%%> ~"] lu mu]ug^u!l"m$>Mtlm $>Mtlm!$>Mtlm"$>Mtlm#$>Mtg $ % ]u&Y^u-tg"m%(l5m"l`	wxhA`vxA`vx	`vx	p	`x	vxpyP&yx6txx{x @ pxx"'  ]uOY^u-  ""    seT		 
+tteS	 
+puBL				 
+LOC	
+d%=G		  
+EBixE	 
+tOMA	SN NC	 
+DI D 
+ELWDC	
+TIADC	 
+AEM
+D% DDC 
+enoIDC e-GA
+tixDC	 
+TESPDC x%-KR	 
+ d%:%:O S  d d%:%:D P  d
+D%:am	 ehct  
+d! ~ xT% TTM1OTuDT1TvODDDTTDDTDTDyD1TOTDDTDTDDDTTDDTzoT ~`TTzOT  T+ ?T#T yTTT]u^u$`s" ~ u"]u^ D   9  1x$  T T ?T]up^u$^ebap`]ea]b^ba0" ~ T T ?Tu0^u ]]u"^u"0"! ~T@@TQ`oTup^u$]"TTDuDTDTTDDDTTvDTOTDTDTDTT DDT T DD  @ `Yt,LlDDDTT!AatDDTT@DTDDT	@D
+	 	
+T		DDT   T  	TTD	DD	DTTD	D	DD >  	 m	 ~"(TT u `u_ ~"0vx`sDwx3T   u0^u*]x0vp']u^u']u^up^ebea`]^a]bbavx~"m utvt5t~tttttD 
+					t					5t	t			t	t	
+					tt		   	  	t			tt		t	ttt		tt		tt	tttt	*t							tt	t]]>	d]` P  Ct					StBt					Rtt t	"		"	~0: 0" ~ Dvtxv vwxx04vttvP)]u"^uu%5%" &5 9%6~:&u 9:%u4&3%'*%&*3'3*/u)0u  &u21	1@28)%&*1(3'(3,3+@)708:$/59977*d) @,3+ d6&Pdd'@D858dd'P ~;~d)P+>d65@dd''P8D58dd'@ ~~TT88N1f`&_1%.-3%487H'3%4-.'@ ~H8~~ 8 ~8 ~|7  ~-. 3'(,)+1*1?1~@@ ~0%50//'1"p3 ~87D883%478"H'		u$e40" ~0Mvtxv&ut  A@ Lt@LA&u"##'"0a#MQ"vx0?T;~$$|#  } }ddP"#_1$~U  $##"@"x@Tvtx ~Y%"&u'$5
+u-<)( | ~}} dd1P%x_1%''&&5	()&' ~"aTT _u `u	"	eu$4 ""        B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t`s  ~T "      T
+  0?T&~epb`aebet&tp`ae^]^ebap`]ea]b^ba{xTtT l ~"C `q	T/T$34 u zxEO#;1ttxvvu"]u"^T?'00 '&UxB t! T  DTT"$t,tt @t!T  D TtT"$,tt >T3%%T#NT333T"O~#0& xxvv$DDDT 0wx 	@ p&]u^uT`d	00txvvv	v%]us^u 0T# 'x;1
+vx"$vyx @ px"vx$vT{xDpT#Tpo`D5{x ~D12#T0?8 ~~: "!tAaT D It
+*t\&tt,0t"t %tDDTTD	DDTt 
+		
+tt
+DUDTVT0DWDTXt\Dt_^
+t]t`TDDTTDD T    TTD34T:DD;DD<=DD8DDDDTtTDDDTtT&$T`"ptyDTDTtyyDDDTDTDIDTTtJKLDTMDTTNDTO&DPDT<DRDTITD0" ~TTxvT0Dt`DtTDTTTTNT3OTTT3TNT33OTTTTNTObtT#TSTO#ToTTTOT>`ddT7`ux @ pu"^u"] ~TTD5"Ttxv"vv	v"DDu&]u0"^ ~<tTTTT_u"`u   "            001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tixM		 =LLD 
+d%`s ~* u!]uX^vx~xv|xvtxvv71T 0?T t]uP^u,  T "     T 
+?Tu0^u,]ebp^`]eaa]b^abx"T tTl"	 ~1$]uh"^u!AtaT DD` t0t" t%t&t
+*.tDDTDT
+	 	
+D	DT	DDTUDDTVDTTWDTtX\DDT_^]`TDDTTDDT T    TTD3:DD;DDD<DD=DDT8DDTT6DDT7TD6TTDDDDDDTTT0DDDTDtTDDTDtTtTT`dP    ~tCt  dpLBttDDttD"#?T0'0'= &x *t!tt6t,t( t!tt,6tt >T3%%#NT33T3OT "~] T  Tvx$vT/T$34 u EO}xD DD@DD TD DDCDpT@ T0. ' T#T`o'vx1$v[PvxT$vGPx$T#Tpo`D5x ~:#?T~0  ~!@&]u"^uGd@}xP
+"dP}x0" ~ # vvxx
+vvD D wxPpF
+vx#@ G@
+TT TOT ~"Ox) | 3 ~G |]u^u( ~"wTTxxDT X    R  JT0?>T # T0x Pu$]ux"^`|@(]u"^uu,]u~"^h ~xG#T$DT(DTT'VDTD0TWDXtuP^u&]]u">^u,\0"W ~x vvdvD!CDBDT#D$DT(DTTVD0DTWDXtPu&]ux"^Fw]upo^u+90"Q ~x vvvT$'T+TTVD0DWDT@%zuP^u&]wx"pFF.]uP^u']u^u*.T@Dp1(]u"^u!}DT.TTTO12"#3"##"."D/"#0.
+!T " ~A;vvxv DDD!DTTT"DD!DT#DD'DTDT(DD)DT*DD)TT$DDt%D$+Dt-@D&TDTT!'T+T.TDDTt/t0.TDTt/0T.DTD3xT33t%%/0.DTD@@t/0.$T@DDDTDDCDTDBDTT@%]uP^u&wx"3pF.DT ~@A12]u^u*vzx"v~z0K vxv v!
+DD#DT$DTDT'(DTD)+TDT,tTVD0DWDTXt%z@P&]u"^uwxpFFPu']u0"^ ~>]vvxv )?TR0T0D"0DTDT T%" D)T0?q ~3ewxpF! ~u^u']
+"#}~|T@F6P.TTTMTTTTOT&
+*0" ~}p|x#T&$T`"ptyDTDTtyyD DDD DDTTTT%"uP^u&]_u"o`uu&]usu^ ~"~t?tDTTTt t>u_u""`AGIG		 
+-IFLemiT 
+!rteS	 
+pu
+PW	GA	 	 
+C =G	  d%E	 
+ 
+CX0KO	O	 
+ 
+1K2KO	O	 
+ 
+3KCDA	E	 
+S-CX # 
+COL	 
+1K:p		 	d%d%:t:m 	m 	x	d%:%:d 	 
+DKCOL	 
+2L>-	EKCO	 
+DKCOL		
+3NGISd% :NL	 
+PUKxE	  
+tiDM		%=LL 
+d	Fu		#t&dT	+t`t&T 3TT33	OT					t	0ttt___>	
+`d P ~ |Ct					Stt				 >p#t		@			Ptt				0	tt"	"Bt			t	0"R ~!{x`txvvv@v{xtt{xPu`^u(]]u"^u' ~"TtDt tTTTtu_u"`~c`s  ]u^u!0tKtLtxxDvxx\v&T@v{xT0 {x{xpDx P ~Y(`TxpT % P(T @"Du"]u 5^T"      T
+  0?T"]u5^up^ebea`]^a]bbaq" {{q3DT	O	"	 	jt		t		t	t	&T`d	tt		t		t	t t		tt	{qq{|xP%{q@{qq	8 ~x vtt}vP$]u"x^u  ~> vtxvv v{dq	t		t				tt		&dT`	tt{x`	tt		6tt	t4t	&T`d		ttt@@t	xF/.P1&@D+&dT`t)xD+Tt!D)T/P/'@D&T`dtlDxTtlDT	1P/)@D&dT`tDtx&TtDTu	1P/`	)@Z	D&T`dt6		DXtx&Z	Tt6		DPX	Tdxx	` vvdvvuP^u']	YD"u"	1$2%&'(`	)*a	#+%#$$ 
+x ##"	D$/0%&'(	)*^_	+	d""`
+	T/0"D ~xvt	vT{x33TT3	OT	T	@t1@@		@`uP^u#]t"P	Du*]u0"^ ~vtxvG@
+
+	@	@
+v	P
+tuP^u(]0" ~! vtx"
+vtx?P vtov4P&TT @D~ `{x)]u"2^uu#]u"^Gt""%| @@"%|t%et5""T|$TT OTtt/|TT O|$TT@OTTt|tT/T`0O ~&'~"t, "%| |""@0" ~2 vtx12vtSPu#]u"^t	&TP)0?T|x@	tt			0" ~QVDT	t					txvvS1  dx@xxTx e@(FQPHP(	?P(u	P( 6Q> /Q/ 	Q/ Q/m	~^ x >  	 m						]u^u+0 ~d@"dP 0" ~Jvtxv	DD	)0?TLTPTTTOT~TPTTTTO~tx2} |x(pLp{	PVTPTT0D	t{xPu`^u+]]u"^u)0"P ~x vt
+v)0?TqtuP^u,]"u"o
+#uu$u%``p$TtTTt$%4 t#"T@=%4P$TTTTL"#TTTLT t%%%$5% t$##""5da`0" ~W`ttDDtTTTxxvvxx"`xU30~~$xh ~x | ~xp |x	v ~ ~x{ | ~x$3xPxv.]uPX^uxH~P x dtxP%xxPxdPu^u#]xTdxpTOTt%T%OTx$pd$xTTTOTt33TO?Tx$xx0"xTpD333DTt"Tpx33
+DT3Dx333FT"  ~vxvx$xddx@x
+$xx$Tx$T333T$$O$T3$T33T$$Otxv vH
+p/]u~;^u tP#]u"^u  TTOT xx@D0" ~TT@Dx"p ~&x |xPBu/]u^x7)P3TTT.Ou#]ux^TTT"O~0 u `u_suju"]u	5^TDD	T"D   "    ART	 
+KCAB		IS_D	 
+G:d%	d%  d%   Bd  D%  mpp D% 		 
+----
+ 
+-1 
+Y`	#	s	p  ~D	`Q DDTPDDDD  D%TTOtKtLTCPDD		tunu%ud1e0?T)0`e)A pde);0eueGTtfHDRQTSGDt%t`QDTTTTNT3OTTTTNT333OTTTNTOTbt1T ?tPiukumuljuFnu `nQ  T @:  2   T (?Tt pe_e*tt`	%t@P"T5D~``_"\[t	 Tp1T`	"`	tx"vv ~P|i 	k3TTOT%i>$ 4t#"%uapkp$a```$H~a "#uml}|Pj~j|  m%et5mlliyF$%4 t"#xx-/pi $ ~3%u0$
+$#P%T$	OT, ~#"$ ~0k$ |3}kpdki3$T3 ~i2pijTTT!O ~n;	"@tGg@
+@
+	^
+	U@vL@
+FDP(;P(	P(u	2()P1!@@@`	@xxxd ~	@"""T $T T~ ~T{ {pT"	"TT#
+pTTT}}$CCdoT333$%dnT%OTTmO##$ThpT$"TO$T$JpT$" "tfh1 ?T@f eE	TN@DhdT=pTDDT		T@DT	D	 DT	`t{.~ht0/	TTG~.	g@t1@@	@`	P_*g	"h0TDD"DTT" D-h0DT""tfheEf	 T@DTh`(($Thph t(x
+/@x`
+d0{DTT	TDT	T0D@DDtT0`
+Tht*thp$T-dx
+`Xpd`{x	SD	DDD		DD	D	DD		@D	tT	thpxh h 0t	GDTuDu("<<hThp,pT}	|$Th i` hf"0eEhYh@TDh0D	th/ eQthtgp$Th 	`eEfq QqYQDAeEfq AqYhD 	VAD	tthDTxqXvh	 Ef eDAt 	e	 	e	h	 f eEDAt	g			g hf	 eEDAtb		,tt		tt	 hf	 eEDA#T0?t!t!tAa hf	 eE@t		t		 hf	 eE|$}h	 Ef eoaRthu*ufu" gtfghip`puu*	"_tt			"tfh f0eExoaphtI0xTThxh@xh@hxThFhh,Lhhl"DT	DT	Tt		tt		tf"eE0@DT""!Aat5,LlTDt		dd		d hhh
+TDDGT a~GDD		tthT,uuYq-ti x 0`{DT	tt	tTtu-uJt	t	fT`f=
+ g  	ttt
+T
+  g 		tt	DT<t	&gA0-u_Ju0hJG"TTTTHOZY\[thG"Dh0Tt	"t			tt	{x"L`0T>
+ g  g0<)&ThtT	0g0g_AthBtfeE0@DT&0h.'0@thGTf{0eE h"<	DT	`D	DT	DT	D	tth%u"uT DD	D DD	TDT"TG}	|{x`xvv~~Tuu&"fTGDHVUXWtg"TGH D^]`_ti"PtDTTfeE0@DT g0"!pdT`TTTOTTT	"TPTTxN	{t`	tT	pd	920	D	t		Tt		t		dd	""d    taD		 
+aDAB	GIS_	
+ 
+KOL	d% :		 
+:LVL
+d% P		  :RW
+ D%S		  :RNd d%	 
+BORF	D% :mpp 		 
+:QELD%  	 
+ EFD			 :CSoL	 
+RSoL	s 
+ ~;` xx}$uu>uu%u1?T0Td)0`d); pdd)50dudGTDHRQTSDG`DtTDTTTTNT3OTTTTNT333OTTTNTOTbtmQc3~`c  TD    >  6T,   ?Tpc"ettp`e'ettp`e%lA}PTGTtfhTT!T!TtUDTDTTDDT5D[~`_\[0"xpxda`FY[#Z$$x#$x#<-$%5$##F!|}$% %@%TTT!O.@DT1~&x xp~ &2 ~G) |~5  |% ~$C#&@x"dGpFR ~.T"T".OTY ~12""@
+xPdNpF_ ~.DT T""T. ~OY12""~@] F@<""@f ~GxP}~@
+o "}x"tf0dE!DDGDD$u"lutfE dGTtf+0ft">f|}GuDu%_"TTTGfutu$P}">|GT%T%THORQTStff"t dE>ff0t"tf dEft0epe_GDu$u"l#?T 6tt,t6t,!TtD"D!Dt,tTeu>P}f|$DGu.u%h"
+t@0hiu2)DGD@TGjDD0htTVGTE"jD@T@TDCDT`thuguu&"vth0(0h<h h2*0tgg@i$DD'tUpg" phpT"A)tUTVPTNTVT@T$T'gu")
+GDT@tAth	DtTVD^u@tu'h] g@ 0tg^`A("gkh&0tU)Tt
+tthu+u('u"uDDp`ptfhTD DDCpD@"0ht0kg'0ht	g"'0h	tu hg@ 0tgthhgA`gkh A1pg'$g	iE&PhPp"@Dt!)tt'tTtt't!tgu|$}`1GDt*thu(u}"	|GTTTTHOZY\[th"TTtUtE@@DDTD DCpDD@	thu%u""   "             ~	b001Xesa
+SN " |xvvvvT D DT@DTT`Dt5t~)T t~t
+
+~QDDT"p&T@Dtt2t			 
+			
+	t	t			t	&dT	t`t		tt		     		t		t		tt		t"`" >  	 m		t	tt		tt?t		tt		t3t	`"e&T@T"T
+`DDTttDDTTDDDTDtTTDDDTtTTt&T`$"ptyDTTDytyD"0'"x0' &x	 DD 0'"x0' &x	 DD "   "    rP4neveiL treknrrE 	 roewoPgnirwoD 	 
+newoPgnir
+pU   p `s" ]u{^uKt$tLebp^`]eaa]b^ab0" ~D    T]u^u  ~"+Tt_u"`u   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.bin b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.bin
new file mode 100644
index 0000000000000000000000000000000000000000..0185231e034c260614736f2c9cb9104a493b7570
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy11g_a2x.bin
@@ -0,0 +1,275 @@
+;222 222  2                  |                            !     m                   Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs   "   N(  $  D.   0	+'-! !3!2!/3*F Y!l! !m#! !"%! '"Mt#z-E ,"$$ !D ! !" 3 3!F!^Y!v !    ! !(. ") "u/33@" u/@3P""
+"P"		"t"
+P"	"	"us`Au\qq1CDuu~pq"~Apq$4$T4$ 4"uuuK"ttL""4^2N_`D ~"09        "S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""Cc uc#00
+ ~/t 4
+cc2c uc TTT0T$Tpp$$pp$p$$>p`${8 T0D DD   8T TTD    (%T OT   TT3 OT T TOTTOTT  OT?TT 0=8  T8D 8 D  8T` TT OT8 `T8Tp8]dT
+`TpTT*
+`o+*TOTT8$T$!`$4`$=`$_`$d`$g`qpTT ZTQTDTp`TE#T"+4T cc2$T$"`9`$>`bp\pYpT"Ep@p$T","@D}yettp`ee	tp`e"uc c tf-@p\e`e_` [`ssY[Z\`[_[\5\t
+0D40?T+& UuVV%5V`UU UuVuV+	uV Uc c2c uc ft@21c c2ttTTdtTT?dtx@x)@xpx%xvxxT`QxAQT`xATQx`AWX$t 4,@ ,tAPtB3xTX`_T,tX^QT`xtH@3BW9`Qx'@tB3TWQt`3B`d!TT6cR\TDB"S	T$`t3_S"0+@T]TtT3T_" uccf0TD D  tfcc2uu52uu52uu52	 `G	p""t   $~}%/ t>$%")(dPd@u? %	3xt$@t ~33%5
+t%5} |)@()( u"DT3T3TND5%%T4"O &
+ " |$ 4pe
+"|T; =<>;<Dp %:
+
+<8;8;<N`$b`$`$?u5?d:P=>?TdE@7$EEE%0tEEt??%d=P>=>-=>p=E0?`=E>=+} |>
+0$??.@t|>=
+} =>`?@t??%<p<C;"$T$n`pp$	```$`$4p$5FXT^_",V$P`p",,@D"tt"WFYHPG_RV_Y2A_9P 
+2:LOT
+D% } "9OfinI	 
+t 
+0D
+1D	2D	 E	 
+pecxnoitE	 
+
+tix C"\[ba^] su_u1`u~%1/ }Na|}a|=1f1)epGDDG"TGTHOTJILK"T0c 0 | | ~}9"
+uu CG"T%TTHONMPO"DT DTttT$t (~"N$~ppD.~~p 0~p+~pp	'~~p-2~p/~pp3*~~p  #~pm ~pp`s% ~u^u"]LM u"aubybp^e]ea]`b^aab"5+ ~]u ]^u" ~"0u"]u~"k^5 ]u^u"" ~:"]u"L^uF ~u`u_ ""    
+a    Iy@	e               0                        ?  @ H    ?      8      |##}~ Qd# p~@|Q{L} ~{Q~#Q`dd#n!`(!0nt ttt@tttttttt(t@tttTT0?T< z{xTTKx ~33NOT<0z{ xTTx ~K33NO0T< z{xTTKx ~33NO0T< z{xTTKx ~33NOTTOT%OT$"&%(',T$`$`ipt)(0y[U@L$%4 t,-$'' 4&&*,UUt+-$%-,\]L*M+()$'' 4&&t()$%$% 4$() dA`08d#pT3(OTT3T333T,"O"atKtL
+ T00  `"t "T Tt  Da@DDTTTt~6t~LttT*OT	DTt	jtTV0?'0T%t$R 'TRjT't$p 'TpB'%0Tt$X 'TX 'Th     'T$tp 'Tp  'T ' 'T      "'T$t&hTdt@.0/&0T ""!tAa TD 
+Yt*lt&tt,t" t%tDDTDg
+DTuT$5u-{x<juTTO<-$?iT-
+$3?htktRtQ
+tRtQD9@DADDDTDBDTtCtD>DTTDTDTTUtVT[DDTD]TTT{DT|DtDDDDt"xxxvxvxxttgpttt @t@t tt6D ""aMA 
+nitinIcA 
+ 
+tON		TAM- 
+HC ~u^u ]0"6 ~T  0 A u0`u_ "=T30Tu`u_"BT_uL`uu_uu"Q``u_0"G 
+T  0T/T`dA 0TJ!x%T TMT1`m5DT1OT T1`oT5D 33TT31OT/dT)pT1@D?T/1D?TT@DD{DT1T|OT1|OT/TT}OT1dTpTu`u_@"y1,`T`2pu`u_"`_u~`u_u""[`u_u"V`uu ]u" ^ 0T_u"`u`s ~u^u ] p^ebea`]^a]bba5c"cTu]u8^0	dTa`dTa`
+n^_o0 T0gT\0?1DT00T	D1T10?T0?TD1@qaDcac n
+0T1Do'0T1
+DT(o0TT1Do0T1TTcDc00T1Dn?T	0D1?0nT$00T1 D
+"10DTT1Dcc0c ~u]u3^D4~"&T	@D"0T$T	Tx
+0T$xT$p`jpd~pdaDV=plxxpfpfx7@Dvx,x@ t@ 	T33TT0O@D4"   "        		D!XR		
+x%:			 d%XTx% :T	 
+siDxA	 
+-lib	 
+DC-SL 
+khDP		uaF- 
+tlKCA	 
+D-A-C	 
+KCXR		=MSF 
+d%-PN	tiaW		 
+SFXTd%=MA	 
+
+seR-		 01 >x 0 - s - DF/ DHS/ MEE/ P- Ed%:S 
+]u3^uT T  TDtxT/T$34 u xEOKattL  /T!TTDD"D(`suuuu|xdTdddT  T #     ?T T /.~p^e]e]`Iq^Tdd0 ~9Dddtebp^`]eaa]b^a5bdTd10 ~#T | ~99Dddt_0Tx	
+Dccxxc	pTxcTx~x@`dccT&0x x@ ccD v~xvt_xt TT333cOTccTcOTcOTTTccO0d)20)TRCT~T} | 
+x9$>}"|PDRCDx"TtT l ~"r.~40 txv4v#?TqtTT  t]uP^u$"?T'00 '^ ?TV3DTTT3O!TDT3T  DT tt,tt TT3D!TOT3TT3D  DT Ttt,tt E3%T%#NT333TOT " ~"xtxvv*vvzxvlkvxxulvgfhTTTTN33OT3(T  ~~Pp }}MT^MTTTTN33OT3TTcOTc
+TTT#cq c
+T'0?tx'PvxclvTTTcucO^u']xvt6vT
+`dxlkdM0E@TTkkOlkx]u@^u(klx 'v	@x@ d0cwxBpFDT#0?TD5TTxqT%3x$4w*x!T#Tpo`D5xxxqvvxlvxvxlvv*v'q) hp7`cyx	0vz%vzP0dvzx v DD!hu cx0vzvT!Thz%P0dzxvvT!uTch0vzxvTT!hz"P0dzxvv  D!u D0"h ~-+D#T?#vtxLvvzxvc0Tc33TT3Tc TTOTTccOtcPTt !ut^u#]cj TzP ~4uD^u$]zx"vv0" ~#@D@Dkk@DxdT]u`3^udL0lkx]u2@%^u)x"kkTleepu`k^u]k3k@D " ~AHvx$g$``$`gu3pkT(0lkTpNdgukTldpN
+gug`$g}`=p$$AA`
+kkl TTOT
+TOTx\l(T P  ~~p6`NTxTTOTT?OkTlx
+kgl`dkl D4 ~|gP9 DTkT333cOTccT  T33T3TccOfT0dx	 x@>p?T-0T$0T 0T*]u"^uu#]u"j^T`d]u 3^u\ ~xlk`$f`$dp|pa$aa`(T  Pp ~~NT_NTfu`O0T0 )u`*f T Tfuufff?`$p`:p`$l`$uo
+ounnDounTnnn DnonTToOTToTo?OTTooOTTo%%oOTToToOTnonDxKyTx	no` OT3T33noTnOT ~n|ff9 df Ep0T[noTcTTnnOno Tfu&0!cTTTnnOnodu0TleepxMpkU@vTcoTf;` 0T]u+^u(f   T4"Dkxl"y ~xT1xP ~x1T ~1T ~10T ~~ T1pdT0 ~ ~1T0? ~~ 1|T9 u.]u"/^TT_u"`u   "        rP4neveiL treknrrE 	 roewoPgnirwoD 	 
+newoPgnir
+pU   p `s" ]u{^uKt$tLebp^`]eaa]b^a5b0" ~D    T]u^u  ~"+Tt_u"`u   "PSA		d%:CGA 	d%:%:M H 	d
+d%:bA	 
+tsiaW	  
+tian # :emLDDV
+D%_t # :epytam 
+xirr # :swo652  # 
+uloc:snm 
+1 
+D% xE	  
+ti1CD		 
+001CD 
+00NCI	T	 
+ 
+DHCGA	P	 
+d% :E	 
+ 
+CXCDA	REB   
+{^ ^  o   oG %0+(<6GAVQ?LZU3b^jfpmmvszxA})|}~b  (0$8,4"<*
+2&:.6!>)	1%9-5#=+3';/7P?RQS,,,8-%,5.<9-5"<"33330d" ~2g  | ~9|h	9  ~ |i~9  |j09 "j1T333iT3hEO~  gTOT0" QTpD]u"J^u+0" { QzQ ~QDpq
+0qu']u0"^1 {QQz ~cuQp?Dq0q
+`cpcD']u""^u$ 4 dpLz{" $&%('ul+*u) (P'TU$%,$ 4t**$4)) *$)*) 4%& "" kt ~z{k0 |X}Qi ~ {{k0 z}|uQQi+Dp]uM^u."Tp$% 433%$ 4/%>$ 4"p~TQ  ~}|# %$&%&#$('u*)1u 0 2u@3u@3 2@.,+1,@0-3-@2./3%<./==<</=>.?)*8/9)*:+;@ @t7$%+ 46t%+7$ 4t5/4%+$ 4t6t7%+ $ 4t45;:336S7QRPQ1>3?43S5QR1PQ+ :C9B8A>@3?63RS7PQQ1;:3345RSPQQ1 GFEDJH<KI=JK1HIKIJ%KHKCB5J5IJIA@5HIH.H'(J<KI=HJKHIK1IJHCKJKJBAIHIH@HI(/'KJH8KI9IJ1HJKHIG%KJKJF5E5IHIHD5HI.JH8KI9JK1HIKIJKHKGFJIJIEDHIH/H.+%1-+/Z.,+0K01%313232"7(.'u%5'")(-u*0--+%!,t
++%@,+,H@++/.,(+'./(,'*+)/.*,)+./,0--@@*")u%5q")g]u@y^u/"]u""E^uqgu@^u+]]u"s^u"pi"l$m>$g#m%(t5mull$iljpm$>$ju#$$#>ij 01/$+#,,p,+,p+,+,+,+p/,,p++,0+,+p1+"$%4 33SQRPQ!./,-%+ $433RSPQ/Q!//.>.=-<,-/,-.0u34122E1B3B4	p4u23 1103412!3412~1 %000~0 x0uSuQR!P4Q234%134342515221$u"%u'&##((P$($(@%%('%(5'&&##@@lh	pm*)hu$>*)tghm%(l5ml0&'x/$1*%b)Nd#~0  |#f9efep#&phhu%(tgmmll5ml$>f"e ~Bh~B%$&ulq 'u(')&**+3S%QR$!P0Q./,-00,u0/ ~/.,%05+*/$'&' 4&*+))(p@ (lQ"gu@^u/]d"00 "]u"-^uststTpst ~"ugiuhjuu lul m$mfe>t<tGHtKtJL" ~BqQu"]u"-^TpTDtrtsttu~" iuh"j:p`d:@u{y	'vzx vt	xx	t	tt		t8pq%`"9Q ~pD8	0D t		tu0]u0"B^!vtxv t"Pu/]u"^~`s ]u>^u-DdT p  0u/]ubO^p^e]ea]`b^adba5d"TTd"kttgjihkg~tEeGgttk"`t;1t;Cttt>ttRQt
+tRQtt<=tt<pTtrsttuvhgiu luj mu`$"p
+u#]uu"O^^u,]]u"k^u/0"% ~D q~N,  9 ~=~ M   ~Z Tpu'&$u# %u &'3x3 $4($) 4%#$$%$ 4)p)@d(p(Eu#u%u $(  ~)#h$%% 4$$ 9)p)((@@ p''&&P ~"m T  Tu_u~"` ]uE^u" ~"u lu miug]uhs^u" ~"u lu m,]ug"^uml$>Mtml $>Mtml!$>Mtml"$>Mtml#$>Mtg$ % & .]u"M^u(tgmm%l5	"lh`wxI`xvI`vx	`vx	x	`vxx	yxPx&y6xtx{x @ "pxx' O .]u"M^u   "    seT		 
+tteS	 
+puBL				 
+LOC	
+d%=G		  
+EBixE	 
+tOMA	SN NC	 
+DI D 
+ELWDC	
+TIADC	 
+AEM--- % 
+-C 
+DnoDDC 
+eGAIDixe-	 
+tESDCC 
+T-KPD 
+x%%:R	O  d d%:%:S D  d d%:%:P 	 
+Dctam
+deh   ~! x%T TMTT1OD{1T|OTDDTDTDDDTTDDT1TODDDTTDDTDTDDTT`o ~2TTTO T+ ?T#  TTTTu$]u"^~`s  ]u^u" D 9  1  x $  T ?TpTu$]ub^p^e]ea]`b^aab"5~0   T ?T0T ]u"^uu"]u0"^ ~!T@@`oTQpT$]u"^uTT{DDTTDDTDDT|DTTTODDTTTD DTD TDTD   @ `Yt,LlDDDTT!AatDTD@DTDTT@D
+Dt
+
+
+
+
+	t	T	TD	DD	DTT	DDt	 x/ Ex/ x/	 xt	/ ~"(TT u `u_ ~"0vx`sDx(wT   0u(]u|^0vx]upO^u%]uD^u%^ebap`]ea]b^ba5vx"~0: 0" ~ Dvtxv vwxx04vttvP%]u"^u				"u%50" ~/Mvtxvt{   ~@t@~{#"vx0?T ~CU$ ~$ |#}} dd#P$"L*~[  9$#
+0"	"#*##@""@vxTtx~_ "&%  56&9% ~::{99u%43%&l*&'%l*33'*)u /u&0 	1u21@2&U(1%l*'(33(,+3@%(87$05:9/797 *d)3@ ,d+&Pd6d'@88Dd5d' ~~P;d)>Pd+5@6dd''PD88d5'~d~@ T8NTe`81%&L*.-3%478%4.3@- ~84 ~8~3 8 ~27 | ~9.9- '(3)+1*,?11@@~ ~%00//5&1p3 ~"7888D3%487"%g ~T T_u "`us ~{t| tt6tttttDt
+
+
+	
+			
+t
+		5t
+	
+t	t
+		t
+	
+	
+t		t
+t		tt			tt		tttt		tt		tt	tttt	*t			tt	y]	]d]C`P   t		C			St%	Bt			Rt	 t"t		u$e4"		u$e4%"&u'$5
+u-<)( | ~}} dd1P%xLQ%''&&5	()&'  ""    B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t`s  ~T "      T
+  0?T'~ebpb`aebewt'tp`ae^]^ebap`]ea]b^ba5{xTtT l ~"C `(q	T/T$34 u zxEO#;1ttxvvu"]u"$^T?'00 '&_xL t! Tt!EttT  D6t,tttJ t! DT T -!tEt./tt,6ttt ET3%%T#NT333T"O~#0& xxvv$DDDT 0wx 	@ p']ub^uT`d	0x	0vtvtx]u^u& 0T# ';1
+vxx"$vyx @ "pvxx$vTxDpT{#poT`5xD{~D12 #0?T ~8: ~"!AtaT D Yt
+*lt&tt,t" t%tDDTDT
+DDTuT$5u-<
+TuTO:+$?
+
+T+3
+$
+
+	t`DDTabDTctgDTu$5u-<juTT+O:$?iT+$3?
+htkRttQR
+ttQ9D:TD@DADBDCDD>DDDTtTDDDTtT&$Tp`"tTDDTtDDDTDTDTDTTUtVTWDXDTYDTTZ&DT[D<D]DTTTD0" ~TTvxT0Dt`DtTDTTTTNOT3TTTN33TOT3TTTTNOTtbT#^TOT#TToTOTdT>`dTx7` u @p]u"$^u" ~TT5D"Txvt"vtx"DDu']u0"w^ ~<tTTTT_u"`u   "001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tixM		 =LLD 
+d%`s ~* u!]uX^vx~xv|xvtxvv71T 0?T t]uPf^u-  T "     T 
+?Tu0^u-]ebfp^`]eaa]b^a5bx"T tTl"	 ~1$]uh"^u!AtaT T DD t0t" t%t&
+t*,tDDTTDTT
+TTOT
+
+
+T
+	t
+DDTD
+DTD`DTatTbDctDgDTTTjTTTOiThkttRQt
+tRQtD9D@DADDBDDDCD>DTT<DD=TDT<TTDDDDDDTTTDDDTtTDDDTtTtTd` P  ~ 9Ct "t	  pLdBt "t	Dt$t"D#T?'00 '&=x* t!tt8tt, (t!tt8t,t ET3%%T#NT333T"O  ~` TT xvv$TT3/ $4 uEOx}D DGDDHDTLDT pDKDGT 0T, ' T#T`o/'vx$v[TPvx$vO$PTx#oT`p5Dx8 ~#0?T ~ ~!@u(]u"^Odx@
+}P"dP}x ~"wTTxxDT d    ^  VT0?JT / T'0x 1T ?Pu$]ux"^`|@(]u"^uu-]u0"f^ ~UWvvxdv 'DDKDJ)DTT*DT.DtaTbDctuP^u&]wx"!pF+]u"^u~20Q vxv v*T-TT1tabDT@z]uP!^u&wx".pFNP&]u^u*]uo^u4DT@p7u(]u"^D'}4TTTTO"78"#3##""4D"56#4
+'"T~ 0# vxv vvx
+ D xDFwPpx
+v #@O@
+T OTT OT ~"x) | ~93|O9 u(]u "^(A; ~x vvvD%D'DDTT(DT'DD)DT-DDTD.DT/DD0DT/DT*DTD+t*DD1@t3,DDT%T'TT-T1T4DTDt5t64TDT5t64TDDTx333Tt%%56T4@DDt5@64T*DGDHDTTLDTKDDJDTGTP%&]u"!^uwx3pF4@DT ~A78*]u9xo^uvz0"v ~sKvvx
+v 'DDT)D*DTD-T.DT/D1TDTt2tabDTct%z@P&]u"!^uwxpFNPu']u0"(^ ~>]vvxv )?TR0T0D"0DTDT T%" D)T0?~q ~3ewx9pF! ~u^u+]
+"}~|T@N6P.TTTMTTTTOT&
+* ~"hO~x)TT*D.DT-TtaTbDctP%u&]uu"!^^u,]pTKOTTTJO0LT DTH0DTT"D " ~Jp|x#T&T`$"ptDTTDtD DDD DDTTTTT0OMHDTTJLDT pDKD%"uP^u&]_u"!o`uu&]usu!^ ~"~t?tDTTTt tEu_u""`    AGIG		 
+-IFLemiT 
+!rteS	 
+pu
+PW	GA	 	 
+C =G	  d%E	 
+ 
+CX0KO	O	 
+ 
+1K2KO	O	 
+ 
+3KCDA	E	 
+S-CXD% 
+::   D% MP	 	 
+UKCOL	 
+1%:p	t 	d	d%:x:m :m 	 	d%D%:dL	 
+2KCO		 
+OL>-DEKCL	 
+3KCOS		
+:NGI d% KNL	 
+PUixE		 
+tLDM	d%=LN 
+	}	A6-&p^NP3 $t	&Td`	+tt&TT 333TT	O		0	tty__C	`d_
+ P~| 9 t		#			Ctt				 p$	= t			@t					0		tt"	""t			t	0"B ~!{x`txvvv@v{xtt{xPu`^u(]]u"N^u( ~"TtDt tTTTtu_u"`~c`s  ]u^u"0tKtLtxxDvxx\v&T@v{xT0 {x{xpDx P ~Y(`TxpT % P(T @"Du"]u M^T"      T
+  0?T"]uM^up^ebea`]^a]bba5q" {{q3DT	O	"	 	t		t		t	t	&T`d	tt		t		t	t t		tt	{qq{|xP%{q@{qq	8 ~x vtt}vP$]u"^u  ~*> vtxvv v{dq	t		t				tt		&dT`	tt{x`	t
+t	t	t	&T`d		ttt@@t	xN/7P7/@~&pD1&dT`t/Dx1TtD'/TP/8@~0'pD&dT`tuxDTtuDT	P/	:@~2)pD&dT`txD&tTtDT	}:P/f	2@	~L)p`	D&T`dt?		D^tx&`	Tt?		DV^	Tdxx	` vvdvvuP^u']	D"u"	7$8%&	'(	f	)*g	#+%#$$ 
+x ##"	D$56%&'( 		)*de	+	d""`
+	Tx"<`{P}P$4D$4T/t>0" ~/Dvtxv	xTT{T333	T	OT&t	@7@@	@f		]uP^u#t"P	uD^u)]0" ~vtxvO@
+@
+	
+		@~P
+t]uP^u(0"! ~x vt"
+vttx<Pv vP&1T T@"D`{x)]u"^uu#]u"^Ot""%| @@"%|t%et5""T|$TT OTtt/|TT O|$TT@OTTt|tT/T`0O ~&'~"t, "%| |9""@0" ~2 vtxQ2vtPu#]u0"^ ~Jvtxv	DD	)0?TLTPTTTOT~TPTTTTO~tx2} |x&pLp{	PaT
+PTT	tP`{x,]u"C^uu*]u"^t	&TP)0?T|x@	tt			 "V ~DT	D		D	D	DT		T	T	T~t	vtx v Qdx@xu#"xTxz`N^PUP	P}	L CPE+/ +/ +/	 +t	 ~/^x9 #p##"p"Eb ~"#9 E  	 t		tP,]u	C^u"d@"dP 0" ~Pvtx
+v )?T0tP)0?T-]u"^uu$u&u
+%'u`$`pTtTTt%$ 4t%$TB@P6p9'&TTTKT%$TTTTKF@P	@d7'2p&TTTTK$%TTTKT'% t5't&&%% $5%$`dM0"i ~T	`DTT	O0	T`DT	0DTT"D"	m@D	MDMtT	T0OM	DT	`TDT	D	DT	Du.]u0"W^ ~WottDDtTTTxxvvxx"`x=30~~$xw ~x | ~9x |x9	 ~ ~x | ~9x$3x9Pxv0]uP@^uxH~P x dtxP%xxPxdPu^u#]xTdxpTOTt%T%OTx$pd$xTTTOTt33TO?Tx$xx0"xTpD333DTt"Tpx33
+DT3Dx333FT"  ~vxvx$xddx@x
+$xx$Tx$T333T$$O$T3$T33T$$Otxv vH
+p1]u~#^u tP#]u"^u  TTOT xxD0" ~TT@Dx"p ~+x |x9PG1]u^u7x)P3TT.OT#]ux^uTTOT	0" ~1 _uj`uusu^u"]	MDTD	DT"$u7%uuT $ 4	@t&'T %$%%3''&&5%%et5%$$?TuT$  4 @&!""ART	 
+KCAB		IS_D	 
+G:d%	d%  d%   Bd  D%  mpp D%  CGA D%  tiB D% 		 
+----
+ 
+-7 
+	df	.	s	p  ~D	Q DDD  D%TTOtKtLTKPDtmlu%uu10?Tt	t%tQDTTTTNT3OTTT3TNT33OTTTTNTObt1?T tPugjuiNkuuhull `nQT @    :  2T(   ?Ttpee-tt`t	%@!;PTD5T)TTT~``_"\[t	 Tp7T	f	"f	tx"vv ~P|g9 	i3TTOT%gN$ 4t%$'u ia@"s((##""##z#\ ~%$ajk}|hhP ~ |%et9kkjj5ga$%V 4t$%xx-/pg  ~3$=ug$  4T |, ~g u
+$4TT | ~94'u0&
+&#P'T&	OT< ~%$&9 ~@i$ |3}ipdig3$T3 ~gBpghTTT!O ~lK	"@tOg@
+@
+	^
+	U@~L@
+NDP(;P(	P(}	2()P7!@@	@f	@xxxd ~	@"""T &T T~ ~T{ {pT$	$TT%
+pTTT}}&CCdoT333&%dnT%OTTmO%#$ThpT$$TO$T$JpT$" "thl1 ?Tuh P**TpdwDT	TT	pTOT	OT	@D0	TDT`	0DTDTDmlt)/l*0t	U/TGT*/e4t	@7@@	@f		-P	"e`{x;DT	TDt		tTtu'ut	t 
+dUtT
+  j 
+d 	`tt	0	DT	t0TDj0u-u'0". D(0 DD"TT{x">`T00
+  j Ttl	T0jj0lBtth0@DT'r0k0GTtl@TG1(ttxp{	h0tPp0h "0T"t'D		T`DT	D	DT	D	DTmDtluu%"GT	|}6x{xv`v~~mTu,u"f 0!T	|}6l  0hf_f@TDl)0D	tl5 	 T	 Dt	atltj d0T` hQ	t`	 	 DT	utu*lRtthh Q+0l	Dtlaj0T ?"5tGDTDt	
+f ffDT DGT~maDGDmltTuu&QTT	TO n &h0 D@
+D"TT"DTxXvl0h! !t	k		k	l h !t	m		m	l  h!			t l hz#?T0t!!ttAal h 	<t	t		 l h}|$6 l hIARtl.u&u"dTGTTHOTZY\[tlGD"GTDHVUXWj"tt
+T	TDT		tt		tt	"thl hQ!@D0l00Tpl tx@
+xU
+dGp0@tT	TDTT	DTDTx
+`dpd{x:	5`D	DD	D
+t		TmTtlxp 0	 tGDTDuOu)"O1thjlnp`puu-"thl 0hxAplI70xtTfxTf@xf@TfFxf"ft			t		tG"THDRQtTtSth"TGH D^]`_tn" TD	DD D	DTT"0TDD"DTT	"TPTTxN	{t`	tT		&0	D	t		Tt		"   "taD		 
+aDAB	GIS_	
+ 
+KOL	d% :		 
+:LVL
+d% P		  :RW
+ D%S		  :RNd d%	 
+BORF	D% :mpp 		 
+:QELD%  	 
+ EFD			 :CSoL	 
+RSoL	s 
+ ~>` xx}$uuuu%uWmDtl1T0?`DtTDTTTTNOT3TTTN33TOT3TTTTNTOQbt33`cc ~  T F@  8   T .?T$ t pcpee&tt`peWe%tA`@q22ATGTthlTT!T!Tt`
+tRtQT)TTTDD<tTD5~_[[`0"\axpdx`F!ade#$x#$#$x-<$$%#5N#}!|% $%@%TT!OT4T@D7 ~&xxp ~9&8~9) O | ~9|%59 C ~#$9&a@x"Fd ~GpRT4T""T4 ~OY78"9"@
+xPFd ~Np_T4 D"T"4OTY ~789""@ ~]N@<"" ~@fOP}x@
+ ~ox""}th0!D0DGDD$u"u|P}TGT%%HOTRQTSth"E}e|6DGuu%h"t TGth0ht"gTTTGthu$u"th 0htdpd0GuDu$"
+tR"Dth eE0ht"+tRTPdueE|$}G6Du$u"lhh@ hDDTDTDdT`gu,	|}DGDDDGTTpTKOTJOTL0TT D0HTDTDTmtl]TDT0hTaGTG"@DTtlful'uuT
+`T)G"TTTTHOZY\[tl`"tTaPTNTaT@*TT-u"u&DDp`pthlHDTLDT TJKpDG"Dl&0tfpfPpi`M`p$J=DTt/5tl$fg(tPPfp]"itl!0*DD-t`s0l.162TDTT
+`T10lf,tgf&@D*D-`tpf"&DGt't/t-t%TTOTt%t-t'fu|$}`&DG*ttl)u"ul70Is`filgtt`iu'u`Tm"0ltff&pfu"|}
+	&DGGTtI	tlDt'aDTTT=OTTmuu(l"tt00f.!i0lt	f"&DTTt`mDDGD@THDTL DJTDKpDGl	tT<tu%u""W               "             ~	b001Xesa
+SN " ~|xvvvvD D @D`Dt5t~)T t~t
+
+~QDDT"p&T@Dtt2t			
+
+
+	
+	
+	t
+t	
+	t
+&dT	t`t		tt		
+tt		t		tt		tt" "` E 	 	t		tt	tt	t	tt		tt		tt	`"e&T@T"T
+`DDTtttDDTDTDDTDtTTDDTDtTTt&T`$"ptTDTDtD"'0"x0 '&x	 DD '0"x0 '&x	 DD   ""001	esab 1T- 
+SN  ~"        P~~11YHPI_G5V1_9RV_22A_40T_~50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.bin b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.bin
new file mode 100644
index 0000000000000000000000000000000000000000..02b88a078b85fbf73a4e0540ada7d49ea6287cd3
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a1x.bin
@@ -0,0 +1,215 @@
+N 222 222T"               .                       ;	   uNuu~Q"~!  "   Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs Q"#%%&&(!(!'|$ '3!F!Y!|$!''l&!! !#  "#$z.% !"#z$.%!X !"%!X !"%C & !C!&!%y  %3!F!Y!y !-'-'l ! !m`u1TQBQ4[DTD T qDC"   "    "S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""C(. ") "u/33@" u/@3P""suuu"$4$T4$ 4"c uc $00 ~/t 4 cc2uc c HH@TTuI $@4tI% pI
+HT0H$Tpp$$3pp$;a|pp$$p`$T%0$5DDD0TT*%TtNI%rp ~~3TTTNTT%rt vID TTMNTTTNTT?TNTrtI%` TDD$5~T~` TTTN{`$5
+p$5
+I$d`p
+pI{(Thh
+T(OTIpT/oOT.TnoT/OTnTT.OH$T$$`$G`$``rpT!$5TD $5T3p
+!`$I|4$5TpI
+c c2$5T" ucc Ju Ku te@@eSpQPeR` X`XSPRCQT0TKJPLQ@@[e]\p Ze`bb\`[]ZD0TTJKZL[|t
+0D4
+0tDt1c c24^2_pNt^r_`ND" ucc te21@c c2ttTTdtMT?Tdtx@Mx@NO$4t *@ t*PtA3BTA$%4TTOt`_*kTOQM`xtP@3BAQN`xt+@3BNT`Qt3
+B`d!TT6RTcTBZD"S0)%3t3/>ttT3_%33/t>tT^"uc ceT"0D D@D D! !tecc23hTTtHt/>	TMTM%3	%5	q"$5$T$(`F`$R`ap]p$5T	"p<d$>5T	,"@Dl"@D$5"
+$5q$5$T$`?`$K`\p$`$`$`Kp$	`	@p$5"@D,l@D"
+$5"BT0/t &   |$ 4pe"T |>=@?>=p W%
+M
+>K=K>=$$N`$b``AuHdAPM?@AGTd@7$GtGG%0GG%tAA?dP@@?-?E@p?0@A+`?E@?
+} |0$tAA.B? |@
+}?@`A%BtAA>p>"V=! ~L	 	`Gp"" $37T`"2YHPV_F2 
+9RLOTPD% : 
+9Of}""PZQT[^UV_`WXuaubucuYRuuSu]u\1$ ~\  Q1}1h|}1a|11` Gt"pDGGD"tt ttD$u$ut ~"#%~%~&~~&(~(~'~~|$'~$~|'~~'&~T0c 0 | | ~}(LC"u Cu"TGTHOTJILKG"T%TTHONMPO"xxxt0tt0tt t tt6D  ""                Ix e                                         ?  @ H ?   :<fC  x333 $t>&%} |1$3r$$&$|%5{H} 1`d$d$!`$&`(%5x 3ThHT/tt>t/>t/tt>t/>t/tt>t/>t00?TTC0T0C0TC ~3x3&$%5TTNO&% DT'")(1*$22(15,$251T`$ep$+0y,[U@$%H 4/t*0*$4)) /Ut-.0U(0'/\]L-.+,M**$4)) t+,$(( 4''+,dA` 08$2513pdT32($15TOT3333T,$215T"Ot  $  ""niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN RA	  
+se>-		 01 F- 0H- DE/ D- EE%:SP	 
+dCA-C	 
+KFXR	%=MS	 
+dW-PN
+tiaT		 MSFX
+d%=bA	 D-li 
+ 
+ ~\VuGWu `X" ~\ u VuYu|WeUpW`VeTTV	uUWTYUY`Y" ~\T   !0 0 T0TTdT!)p!D[e$ttp`Ze)tAp_e^etA`uRu"ST@ ~\uQSuRrx"V
+  TT 0!T a %T OT1`mT5DTT1OT 1oT`D5 3TT331OT1`TpQuRu"SuQSuRVu"t|Wu  "T
+0uQSuR$"z ~\Td ~d!\0	dTza`dTza`
+x^_0
+T1'DxT
+01DTx(0T1TDxT01TTddD00T1Dx0?T	0D1x60T$01DT 
+01TDT1vrx ~\(x1xT ~P0x\10T ~26 ~\10?T ~: ~\1?T |dLD ~"dGvx\x`$$`xpxv0TTd	pN
+vxxx5`$?p$x
+ TOT
+TTTOxxdx`4~ DxO |L xDTT333dOTddT  T33T3TddOxT ~"[x\xx`$G`0$D`=p0vx1T xvvxT vvxx$$%`$`x7p
+vDx
+vT DxTOT ~xe | ~Lqx\txvv*vxxxvvvxlghhgTTTN3TT33OghTTdOTd
+TTT""        niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN DI	  
+ELeRA		 
+s >-	0 01DF- DH- EE/ P- Ed%:SC	 
+KCA-		 
+SFXRd%=MN	 
+aW-P 
+tiXT		=MSF 
+d%ibA	
+D-l~ 
+  \ `u`"au`b  ~u\au `cuae_^p	``e^`cu_a^_"c`c ~\T!0!!!!02!0T2T`u")auRT@ ~\1u\ux"o]s@
+T @0T!@ TaT%@OTqmT`DuTTqOT@qT`oDuT@T333TqOTqp`1\u"]u1u\uu"~]au `"T@
+01u\u"] ~$\`c! ~\T! u `u"aTk ~k(\pIdTza`KdTza`JHx^_0
+Tq'DxT
+0qDTx(0TqTDxT0qTTkkD00TqDx0?T	0Dqx60T$0HqDT J0qTDTqvsx ~\/xqxT ~P7x\q0T ~9= ~\q0?T ~A ~\qFT |kLD ~"kNvx\x`$$`xpxv0TTd	pN
+vxxx5`$?p$xJ TCOTJTTTMOxxdx`Pt~ DxV |L MxDTT333kOTkkT  T33T3TkkOxTH ~"bx\xx`$G`0$D`=p0vx1HT xvvHxT vvxx$$%`$`x7p
+vDx
+vT DxHTOT ~xl | ~Lxx\xvv*vxxvvvxlHnoonTTTN3TT33OnoTTkOTkJMTTT""        inI	 
+0t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2 T$0u$  TTDbDDTTT~1  ~1+t(@DTEtt"j0?T+'01X:Xx1x')01QQ1a1a1pp1&"Tdt@.0/&0T ""	 p ~"\ " vvxt!t"t!t#'tt()t*)tt$%tt+-@tt&tt!'t+z{Qz {xQuttuQ@z {}QT$@DDDDDTCDTDTBDT@"DT3O`T./0."xt  t0t"t %t&t
+*!DTtDTtttUttVWtXt\t_^]`Tt     3:t;<=tt	t8tt76ttu0xTT333DvT/TTwOt0tttttTT`d
+ P~|M L tCt BttDDttDX" ~`%Vu\uEWu Yu0Wu&VeUpW`VeTTV	uUWTYUY`Y" ~\# T T ?T0DVu Wu%%Vu""Wu`Y, ~\DTT  VuWu&pY"~I5 \ xT% 3TOT0TO0Du1TvOTtDyDzT`oT ~B;TTzOT  T' ?TT yTTVuWu& ~"\FuSuR ""            inI	 
+1t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2@T!0u$!T@TbDD DTT~T1@~1`+tH	hDoT		
+tt	"jt?T+0g0X1X:1xx)g01QQa11a1p1p"Tfd@.t0/fT0""  	p ~" !\vx"N	tP	tQ	P	ttR	V	tW	tX	tY		tXtS		tTtZ		@t\tU		tNtP		tVZ	z{ {QzxQuttuQz {}@QTS		DoDDs	DT	TrDDTq	Do	"TDTO`T3]		^_	]	"Axt@`t0tBbE tetFfJtjaTDtDT )	(	'	*	t	&	tt	t	t	t		tt				.	Tt-	,	   	  -,	b	i	tj			ktl	ttg	ttf		tetpxT333DToTTOTtt0tttt>	=	TT	d>
+`P M ~ |E	LCtG	I	K	t0	1	2	3	 tE		B	G	I	Kt01	2	3	=	DDtM	tD"~`b `u\Bau%cu0!u&`u_apae`e^`	`_a^cu_^c"c ~`#@\ T ?TT0u Dau%``u"au%`c" ~\,DTT!u au&`c"Fp5 ~\@xT%3@TTOpTOpDTqOTtDDCTAoT ~`;ABTTTO@ T' ?T TTCuTau&` ~"F\u\u""$]B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`X  Vu\Wu Yuv&~PepU`TeUet&tp`TeWVWeUTp	`VeTVYuUWTUxYT{ tTl" ~Q\1#T/T$34 u zxEOtxvvutWu!V"?T0'0'c &xP t! TT  DT"$t,TDTDTTN!t  DT Tt"$T,DTTTDT>T3%%#OTY" ~#`&vxx\$vDDD T0wx 	@ pu&VuWT	`d0x0tvvvv	u%VuKWT 0#'
+ xx1vvx"$ y @pxx"vv$pT{xDT#Tpo`D5{x1 ~\2#?T~08  ~\:"\T D It
+*\t&tt,0t" t%!DTDTDDDTt
+ttUDDTtV0TWDtXxD\_t^t]
+t`Tt     34Tt:;	tt<=DD8DDuDDDTtTDDDTtT&$T`"ptyDTDTtyyvT0x33TT3vOT/TTwOTttItJKLDTMDTTNDTO&DPDT<DRDTITD"~;`Y \DD D5DD4TTvx0TDt`DtTTTTN3TOTTTTTN333OTTTTTNOTbtdT>`dTx7` u @pVu"Wu! ~\TT5D"Ttxvv"vv	"DuDWu&VY" ~`<\tTTTTurxSuR"t  It
+*t\&Jt+tt,t0" t%!DTDTt\tt_^
+t]t`tt     tt3:t;	t<ttt=	tt8ttItJKtPtRtIuTvDttt ""B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`b  `u\au cuv&~Pep_`^e_et&tp`^ea`ae_^p	``e^`cu_a^_xcT tTl" ~Q\1cT/T$34 u xEOxvvutau!`"?T0g0gc fxP Ata@TT` DT"$Ltl0DD?TDTD NatA@ DT`TtL"$Tl DTD0DD?T	mT3%%cOTc" ~#`&vx\$vDDD@T0x 	@ pu&`uaT	`d0x0vvvv	u%`uKaT@0cg
+ x1vvx"$  @px"vv$pTxDTcTpo`Dux1 ~\2c?T~08  ~\:"\AT@D`ItJjF\tftLtl0tBbE teaDTDT DD&	DT	t)(	'	
+tt*		DDTt		0TDt		xD	t	t		
+t.	Tt-	,	   	  -,	b	c	Tti	j		ttk	l	DDg	DDDDDTtTDDDTtTf$T`"ptDTDTtTpx33TT3OToTTOTttx		tyz	{	DT|	DT	T}DT~	&D	DT<D	DTx	TD"~;`c \DCD DuDDtTTx0TDCt`DtTTTTN3TOTTTTTN333OTTTTTNOTbtdT>`dTx7`  @p`u"au! ~\TTCuD"Txvv"vv	"DuDau&`c" ~`<\tTTBTTusx]u\"$At@`ItJjtF\fJtKkttLltB0b tEeaTDDT0Dt	t	t	t		
+tt.		t-,	    -	 	t,tb			itj	ttk	ttl		tg	tt	txty			ztt		txDTtt"t   "            001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix ~ \	Q!Vu"OWu#T?'00 '&Kx8 t!TDTTDT6t,t6t!DTTTTD6t,t>T3%%T#"O~}`Y \T  Tvx$vT/T$34 u EO|xt0D@D DDDT pDCD@T 0T ' T#T`o'vx$v[TPavx$vG$PTx#oT`p5Dx ~\#0?T ~ ~\\!@kQu&Vu"gWGdx@
+|P"dP|x`Y" ~\;vvxQLuPkWu"Vvx"/p@t. ~A12%VuLx;Wuvy~"vw \TxwD  T#0Tx PkQ!Vu"OWu{xkQ`Vu@Wu"'Vu""Wuh ~\xG}#T$Dt(T'V7ttWXtPkQ"Vu"Wuu$Vu"W~H`YW vx\dvt!CDDBt#$DT(t7tVWtXQtuPkWu"Vvx"upWu&VY" ~,`Qvvx\$T'TT+7tVtWr@kQyuPaWu"Vvx".pFPu#VuWu%Vu;W.@DT1upWu"V"t!T}.1$2$%3%$%$D.$/0%.
+t!Y" ~Z`p{x\&T`$"ptyTDTDtyy?t*tT"PkQu"Vuu"WSuR"VuuWu"X~Y`YK vx\
+vt!t#T$DDT't()Dt+,ttV4tWXt@kQyuPaWu"Vvx"pFPu#Vu"W~*`X  Vu\Wu Yuvxx{x}vtxvvvx` FT0T ?tuPaWu'VPvu'VuUWpWeVeTV	`UWTYuUTx"YTtT l"~`Y# vx\x
+vvD  Dpvxx
+vN#@ G@
+T OTT OT ~"x) |~L3 G |"VuL"Wu;`Y] ~x\vv)0?TPT0DT"0D DT%DT" )?T03G ~Lepvx ~\!u#Vu"HW}~
+|T6@F.PTTTMTTTTTO&
+*~"~ \tt?DTTrx tt>Ru"Su   "taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	"" 
+`X" ~5\ D DD5D4~xxdu|veu u fuwg`DtTDTTTM3TOTTTTTN333OTTTTTNOTtb@vext"tpg`fe ewttpg`fe 1!q@wPTGTtfhTT!T!TDTDTTDDTD5~RPS0"Qwaxpdx`FAYZ%&x%&%&x-<&&%%5F%}q!|&' ''@TTT!O.DT@(1 ~wxpL ~(2 ~L|GL * ~ |'~L8 %&(L@"wadxpF ~G\G.T$T$.OT ~N12$L
+$P@dxpF ~N\T.T D$$TT.~ON 12L$$@R ~\F	@<[ ~\""@f ~GxP|~@
+o "\|x)"*dPd?@u	 %3|x@t$~t 33%5
+t%5 |}|*@)*)u"    "001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix`c  ~\;vxeuPau"`x"/p@t]	 ~A`		a%`uLx7auv"vv	dx@
+P"dPx`c" ~}\@TT`xvv$TT3/ $4 uEOxto	DD DTs	 Dr	pDDTo	T@0Qg  Tc`oTgxQvvW$axPPvvv	$x$PTcTpo`Dux ~!Qc\T0? ~\X`u@cau&c"?Tg00 gKfx 8tAa?TD0DDT DtL6tl6taADT DTD?0Dtl6tLm	3%T%Tc"Ow ~\CTxD@ T#0Tx `uPau x"`u@au ``u"au' ~"\	Qj `u"auh ~\xv	R	TS	DtW		TV	7tt		tP"`u"auu$`u"a~H`cW x\	dvtPr	DDq		tRS	DTW	t7t		t	tuPau"`x"upau&`c" ~,`Qvx\S	TV	TTZ		7tt	n@uPaau"`x".pu	Pu#`uau%`u7a]	@DT`	upau `	"tPT}]	`	$a	$%3%$%$D]		$^_	%]	
+tP	c" ~Z`px\fT`$"ptTDTDt?t*tT"Pu"`uu"a]u\"`uuau"b~Y`cK x\	
+vtPtR		TSDDTV		tWX	DtZ	[	tt		4t	t@uPaau"`x"pu	Pu#`u"a~*`b  `u\1au#cuxxxvxvvx`@BT0CT ?uPaau'`Pvu'`u_apae`e^`	`_a^cu_^x"cTtT l"~`c# x\x
+vvD@`Dpxx
+vN#@ v	@
+T@OTT`OT ~"x) |~L3 v	 | `uL"au;`c] ~x\vi0?TLTB0DTb0DE DTeDT" i?T03? ~LepxX	u#`u"Da}~J|FT	6@u.PTTTMTTTTTOFfJj~"~ \tt?DTCTsx`ttm	\u"$]u   "        taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	"" 
+`b" ~5\ CD DDuDtxxkuvlu u muwn`DtTDTTTM3TOTTTTTN333OTTTTTNOTtb@vext"tpn`me ewttpn`me 1!q@wPTGTtgiATTaTAaT-	DTD,	TTDDCTDu~\Z]0"[waxpdx`FAYZ%&x%&%&x-<&&%%5u	%}q!|&'`''@TTTaO]	DT	@(` ~xpL ~(a	 ~L	|vL * ~ |'~L8 %&(L@"wadxpF ~G\G]	T$T$]	OT ~N`		a$L
+$P@dxpF ~N\T]	T D$$TT]	~ON `	a	L$$@R ~\u		@<[ ~\""@f ~	vxP~@
+o "\x)"*dPd?@u	 %3|x@t$~t 33%5
+t%5 |}|*@)*)u"    "				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT 0dD4 ~\=u$Vuu"WWu'VY"`ex	0@ px@T/0?0Tg&hT T0u Vuu"WWu V"IT`du$VuYW`xKpd Te0xTdTTOhg Tvx+%!`YTdTTxOhge i!jTijxpf[pfx@vhjiTd`oTxL 0TVu;PWu'dx.pT d d#``D4"jixxY"`#dKq d
+T'0?tx'PavxdlvTTTdudOWu$Vx)vt6vT`dxxWeO0jix@TTiOjfpxpf@u'VuPWjixx '7aavx	@@aJa0ed}xw Fw4p#0?TD5xVqT~%3$wx*4x!T#Tpo`D5xxQqvxx"lvvxvxlvv*v'"KqT?0'0'_ &x L3DT!tt  8tt,tTTDDTTJ3DT!t8t  tt,tTDTTDT>%T3%#OT`Y" ~+\ t#?TtxVqvvvzxLvd0Td3TT33Td TTOTTddOtPadT !ttu VudIWT az ~P)\Du!Vux"Wvz"v~5`Y tx\v4v#?TqVtTx r TtuPaWu!VVu"Wu$TT   TDyDTTT3/ $4 uE~xO%`Xuguiuhju|x*YuTeeeTe@v T~ 'pWe`VeV/WTee~!0  jiLDeetWeUTp	`VeTVYuUWTUYTee0T ~,# ~EgheLeDtT0Tx	
+Dddxx	pTddxTx|x@add`Td&0}x @ xdDv|xdv ttTx T333TTddOdTdOTdTTOTddOx"T tTl"$`Y5 ~\DghDx@@DxdTVu`Wu$eQ0jipfxfxpu2@Wu Vx"nxTjipf`f$VuxWu@D"TRu"Su   "            				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT. 0kDt ~\=u$`uu"aau'`c"`l3x	0@ pxM@T/0?0Tn&oT PT0u `uu"aau `"IT`du$`uca`x8Kpd!Te0NxTkTTOonN Tvx+%!`cTkTTxOonl p!qTpqxpf[pfx@vhqpTk`oTxL!0T`u;Pau'dx.pT!d!d#``Dt"qpxxc"`c=kKq k
+T'0?x'PavklvTTTkukOau$`x)v6vT`dxxWlO0qpx@TTpOqfpxpf@u'`uPaqpxx g7aa	@@aJa0lk}xw F4pc0?TDuxVqT%3$x*4x!TcTpo`DuxxQqvx"lvvxlvv*vg"KqT?0g0g_ fx L3DTAatt@`8ttLltDT0D? DTDJ3DTaAt8t@`ttLltT DD0DD?Tm	%T3%cOT`c" ~+\ tc?TxVqvvvxLvk0Tk3TT33Tk TTOTTkkOPakT K!ttu `ukIaT a ~P)M\Du!`ux"av"v~5`c x\v4vc?TqVtTCx!s!TuPaau!``u"au$MTT!@!TDTDTT3/ $4 uExO%`bunupuoqux*cuTlllTl@v@T~ 'pae``e`/aTll~!0  qpLDlltae_^p	``e^`cu_a^_cTll0T ~,c ~EnolLlDt	0Tx	
+Dkkxx	pTkkxTxx@adk`Tk&0x @ xkDvxkv t	tx T333TTkkOkTkOTkTTOTkkOx"T tTl"$`c5 ~\DMnoDx@@DxdT`u`au$lQ0qppfxfxpu2@au `x"nxTqppf`f$`uxau@D"T\u"$]u   "             DC	ELDIC	 
+IAWD	 
+TEMDC% 
+AC 
+DnoDDC 
+eGAIDixe-	 
+tESDCC 
+T-KPD 
+x%%:R	O  d d%:%:S D  d d%:%:P 	 
+Dctam
+deh`X DxwvxT  
+u0Wu&VxA0vp&VuWu&VuWupWeUeT	`VWTVYuUUTvxY ~"\3uvt t ~ Q~Qtt5Q~ttttDt 
+					t					5t	t			t	t	
+					tt		     		t		t		tt		tt		ttt		tt	ttt*tt								tt	t]	]d]>`P   t		C			StQt		B			Rtt t"}%$/ t>%$	"			"~/`Y tx\vvQut  a@ t@aaQu$%%
+0q$$%vxbT;0?& ~& |%} }dPd%&$ ~L &%%@$$@vxTtx~ "\('  78(;' ~<<;L;u'65'(()'3)3,1u+2u  (u43	3@4'(3)*33*.-5@X:9$215<;;9,9+ d3@ .d-&Pd8d)@D::d7d)P ~~+;d>Pd-5@d8)Pd'D:7:dd) ~~@TT::Na`3'(/%60:595%6/0@D ~: ~G:K ~F:Q~EW  |9~L] /05L)*.+-3,3?3~@@ ~2%5211"3~!p5c \:9D:6:5%9:"u%5	"	eu$4"		u$e4"~`Y  "\~ `Y
+ tx\v vvwx04vtxvatVuPWu" ~"\'TT T! u!SuR'")(u
+$5u-*<+| ~ } }dd1P'x|))%(5	(+(*) ""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.bin b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.bin
new file mode 100644
index 0000000000000000000000000000000000000000..273a6b0b94f89e3ba84f86f5b05ec26e7cb9973d
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/fw_phy22f_a2x.bin
@@ -0,0 +1,239 @@
+?222 222T"               |                 y
+     >     Q                       Tt TtTtTtTt Tt(Tt0TtT8t@TtHTtPTtTXt`TthTtpTtxs Q"E#%%B&?&(!(!(s+ (3!F!Y!{+!E)E)l&!! Q!<#  "#$z.% !"#z$.%!X !#%!X !# %C & !C!&!e&  &3!F!aY! !((l ! !m(. ") "u/33@" u/@3P""ppttts`hus`Eu|qBQ1[QT4DDT  qCDuu~qQ"~!q$4$T4$ 4"uuu""" ~"!     "S    SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC "SC ""Cuc c 0$0t ~/ 4c c2 ucc HTH@IT@u $4% tIIpH0TTHqT x	f  &T&0$5DDDT*0%TNTI%zt ~~pTT3TNTTztvI%  DTMTTTNTTNT?TNTI%zt`T DD$5T` ~~TTNT`$Q5p$5I$	d`pQpI(T
+hhTT(OIpT/oOT.TnoT/OTnTT.OT*oTI	`pTTj$`oI$+5+$5pI*$5T*$5TTOH$T$*`$M`$e`$p``T!$5T R$5TAp`$I/%+$54$5TpIc c2$5T"$51$5$T$u`!p!p`$!``$`$
+`$!$5dyp$5T]\`$@p$5",@DDl"@$5"T3hTtHt/>TOOTu%5"1$5T(`$F`$$R`ap]p$5T"<d>p$5T"@D,l@D$"5"uc c u Ju Ktf@@pQeSeR` P`XXPRQSC0TTKJLQP9@@]p[eZe\` b`bZ\[]TD0TKJL[Z90t
+4D0t
+tDqq cc2x333+$>t|  3-	-<`} |/tt>T0?x333+$t>"4^2N_pt^rN_`D"c uc ft@2c c2ttTTdtMT?TdtxM@x@NO$ 4*t@ t*Pt3BT$%4TO_Tt`*OkT`Mx@tP3ABN`xt+@3BNT`tB3d
+`TTT6RcTBZD"S)03%t3t/>Tt3_%3t3/>tT^" uccf0T"D @D  DD!!tfcc2uuund
+9en2uuuypo9y2uun
+ugfn92uuuyqry9B20Tt / & $ |4 ep"T= |?>@>=p %!
+	
+E>=>=`$`$Q`$fAudAP?@AGTd@7$GtGG%0GGtEAA%d?P@?@-?Ep?E@0EE@A+`?|@?
+} $A0BtA.?} |@
+@?AA`A%BtE>Ep>="	 	`Gp""$3T `7"2YHPA_F2 
+13LOTPD% : 
+9Of}""PZQT[^UV_`WXuaubucuYRuuSu]u\1$ ~ S1}1|}1a|11` Gt"pDGGD"tt ttD$u$ut ~"E#%~%~B&~~?&(~(~(~~s+(~+~{E)~~E)&~(T0c |0  }| ~C"u Cu"TGTHOTJILKG"T%TTHONMPO"xxxt0tt0tt t tt6D  ""                Ix e                                         ?  @ H ?   :<fC  x333 $t>&%} |Q$3z$$&$|%5{H} Q`d$d$!`$&(%50!3hTTtH/>t/tt>t/>ttt/>t/tt>t/>t0t@ttttt00?TTC0T0C0TC ~3x3&$%5TTNO&% DT'")(1*$22(15,$251T`$ep$+0y,[U@$%H 4/t*0*$4)) /Ut-.0U(0'/\]L-.+,M**$4)) t+,$(( 4''+,dA` 0G8$2513pdT32($15TOT3333T,$215T"Ot  $  ""        niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN RA	  
+se>-		 01 F- 0H- DE/ D- EE%:SP	 
+dCA-C	 
+KFXR	%=MS	 
+dW-PN
+tiaT		 MSFX
+d%=bA	 D-li 
+ 
+ ~VuGWu `X" ~ u VuYu|WeUpW`VeTTV	uUWTYUY9`Y" ~T   !0 0 T0TTdT!)p!D[e$ttp`Ze)tAp_e^etA`uRu"ST@ ~uQSuRzx"V
+  TT 0!T a %T OT1`mT5DTT1OT 1oT`D5 3TT331OT1`TpQuRu"SuQSuRVu"t|Wu  "T
+0uQSuR$"z ~Td ~d!0	dTza`dTza`
+x^_0
+T1'DxT
+01DTx(0T1TDxT01TTddD00T1Dx0?T	0D1x60T$01DT 
+01TDT1vzx ~(x1xT ~P0x10T ~26 ~10?T ~: ~1?T |dD ~"dGvxx`$$`xpxv0TTd	pN
+vxxx5`$?p$x
+ TOT
+TTTOxxdx`4~ DxO | xDTT333dOTddT  T33T3TddOxT ~"[xxx`$G`0$D`=p0vx1T xvvxT vvxx$$%`$`x7p
+vDx
+vT DxTOT ~xe | ~qx|xvv*vvxvxvxlvvxhghgTTTTNT333OhgTTdOTd
+TTT"   "            niaMnI 
+ 
+tiitcA 
+evA/DCTSIB
+SN DI	  
+ELeRA		 
+s >-	0 01DF- DH- EE/ P- Ed%:SC	 
+KCA-		 
+SFXRd%=MN	 
+aW-P 
+tiXT		=MSF 
+d%ibA	
+D-l~ 
+   `u`"au`b  ~uau `cuae_^p	``e^`cu_a^9_"c`c ~T!0!!!!02!0T2T`u")auRT@ ~1u\ux"o]{@
+T @0T!@ TaT%@OTqmT`DuTTqOT@qT`oDuT@T333TqOTqp`1\u"]u1u\uu"~]au `"T@
+01u\u"] ~$`c! ~T! u `u"aTo ~o(pIdTza`KdTza`JHx^_0
+Tq'DxT
+0qDTx(0TqTDxT0qTTooD00TqDx0?T	0Dqx60T$0HqDT J0qTDTqv{x ~/xqxT ~P7xq0T ~9= ~q0?T ~A ~qFT |oD ~"oNvxx`$$`xpxv0TTd	pN
+vxxx5`$?p$xJ TCOTJTTTMOxxdx`Pt~ DxV | MxDTT333oOTooT  T33T3TooOxTH ~"bxxx`$G`0$D`=p0vx1HT xvvHxT vvxx$$%`$`x7p
+vDx
+vT DxHTOT ~xl | ~xxxvv*vvxvxvxlvvxHsrsrTTTTNT333OsrTToOToJMTTT"   "            inI	 
+0t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2 T$0u$  TTDbDDTTT~1  ~1t(*TOTGDTtMjt"0?T'+01X:X1x)x'01QQ1a1ap11p"&Tdt@/.0&0T" "	 p"  ~x" v~t%'(tt')t-tt./t0t/t*t+t1t3@t,t%t't-{1zQz {Qxutu {Qz {}@QT*DGDHDTTLDTKDDJDTGTT"D`T34O56"4t x tt0" t%t&t
+*!DTtTDtt`tttatbtctgtjihktRQt
+tRQt9@tABtCtt>tt=t<t{0xT333DT|/TT}OTttttTd
+`P  ~ |MCt "t	 Bt "t	Dt$t"D`X ~uWu%VYuG0 &Vu-WupWeUeT	`VWTVYuUUT9"Y~`Y#   T ?T0T Du%Vuu"WWu%VY" ~`,DTT  u&Vu"-W~`Y5 DT`oT ~;TTOT  T' ?TT TTVu-Wu& ~"FuSuR ""            inI	 
+1t        ULT	  Ptse	 
+DteS	 
+puDP		
+nwoL		 	 
+BOC		d%=LE	 
+
+tixM		 =LLD 
+d%2@T!0u$!T@TbDD DTT~T1@~1`tHhTjOTv	DT	|	t	t"j0?T+g01X:Xx1xg)01QQ1a1a1pp1f"Tdt@.0/f0T ""	 p ~" "!vxtT			VtWtV		tX\	tt]		^t_	^	ttY	Z	tt`	b	@tt[	T	ttV	\	t`	z{Qz {xQutu { {Q}@zQY	TDv	D	TwDT{	Dz	DTDy	DT	TvT"DT3	O`cd	e	"c	A@xt`tB0tb tEeFtftJjaTDtT D4	3	2	5		t*	t1	ttt		tt		tt				t		tt		
+th	o	p	tq	tr	ttm	tl	ttk	tpx33TDT3oTTOTtttC	tTA	C	
+`d P ~ |MCtK	M	O	Q	8	t:	;	<	 	BtKM	O	Q	t8			:	;	<DAS	ttD`b" ~u%`ucuDa0!`u*au&ae_^p	``e^`cu_a^9_"c`c# ~@T ?T 0T D%`u"auu%`u"a~`c, DTT! &`u"*au`c5 ~DCTAoT ~`;ATTTO@ T' ?T TTCuTau&` ~"*Fu\u""$]B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`X  VuWu Yu&~PepU`TeUet&tp`TeWVWeUTp	`VeTVYuUWT9UxYT tTl" ~Q1#T/T$34 u xEO|xvvutWu!V"?T0'0'c &xP t! TT  DT"$t,TDTDTTN!t  DT Tt"$T,DTTTDTET3%%#OTY" ~#`&vx$vDDD T0x 	@ pu&VuWT	`d00|x	vv|x%Vu>Wu 0T# 'x1
+v"$vx @ px"v$vTxDpT#Tpo`D5x ~12#T0?8 ~~: " TD t
+I*\t&tt,t0" t%!DTDTDDDTt
+ttD`DTaTbDtcxDgjtith
+tktRtQtR
+tQt9T:@t	tABtCD>D{DDTDtTDDTDtT&$Tp`"tTDDTt|T0xT333TT|OT/TT}OttTUtVTWDXDTYDTTZ&DT[D<D]DTTTDY" ~N`DxDTzT3TND5%%4OTTTx~T0Dt`DtTTTTTNT3OTTT3TNT33OTTTTNTObtT`dT>7`d}x @ "pu!Vu ~WTTD5"Tv|xv|x""DDVuWu&`Y" ~<tTTTTxRuzSu"t  
+It*\t&Jt+tt,0t" t%!DTDTgtttjih
+ttkRttQR
+ttQ9t@tA	ttBtCttt>ttTUtVt[]ttT{|DTttt  ""B01		 
+TuteS	 
+pkniL
+pU-L		 -knissoLL	 
+-kninwoD		 
+ IDM 
+ XixE	 
+t~`b  `uau cu$~PeUp_`^e_ejt$tp`^ea`ae_^p	``e^`cu_a^9_xcT tTl" ~1cT/T$34 u xEOxvvutau!`"?T0g0gc fxP Ata@TT` DT"$Ltl0DD?TDTD NatA@ DT`TtL"$Tl DTD0DD?T	tT3%%cOTc" ~#`&vx$vDDD@T0x 	@ pu$`uUaT	`d00x	vvx"`uau@0Tc gx1
+v"$vx @ px"v$vTxDpTcTpo`Dux ~12cT0?8 ~~: "~N`c DCDT{x3TNTuD%%tOTTTx0TCDt`DtTTTTTNT3OTTTTNT333OTTTNTTObtdTT>``dx7 @ p!`u"~au TCTu"DTxvvx""DuDau$`c"j ~`<tTTBTTu{x]u\"$AT@D`ItJjF\tftLtl0tBbE teaDTDT DD1	DT	t43	2	
+tt5		DDT		DT	xt	Dt		
+t		tt		t
+t		tth	i	Tto			tptq			rDmDDDTDtTDDTDtTfT`$"ptTDTDtTpxTT333TOToTTOt	tt			TDT	D	DT	DT	&TD<DD	T	TD"At@`JItj\tFfKJtktLtl0tBbE teaTDDT0Dt	tt		
+t		tt		t
+t		tth	o	p	tt		tqttr	ttm	t	tt			tt		tTDttt""001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix ~ 	Q!Vu"OWu#T?'00 '&Kx8 t!TDTTDT6t,t6t!DTTTTD6t,tET3%%T#"O!pY ~ TT xvv$TT3/ $4 uEOx0tGDDTHDL DTKpDDGT 0T'  T#oT`x'v[$vxTPv$vOx$PT#poT`5xD~ #0?T ~! ~Qu@rWu&V"Odx@P
+"dxP"`Y; ~xv~rQLVuPWu"~x"/p@t4A ~78u$VuxWvv ~"wTxDT / T'0x 1T ?PrQu!Vux"OW`@rQ"Vu"Wuu(Vu"MW~H`YW ~xdvt'KDDJt)*DT.ttabtcQtuPrWu"V~x"upWu'VY"a ~,`Qv~x*T-TT1tatb6@rQuPWu"V~x".pNPu#Vu[Wu$VuW4@DT7upWu"V"t'T}47$8$%3%$%$D4$56%4
+t'Y" ~X`Kv~x'
+tt)*DTDT-.tD/t12ttabtcrQ@P"Vu"Wup~xNVuPWu# ~"hOx)*DT.tT-tatbtcrQVuPWu"%Vu"WuTpTKOTJOTL0TT D0HT"DDT"pY ~Jpx&T`$"ptDTTDt?tt*TT0OMHDTTJLDT pDKDrQ"VuPWu"Ru"uSuWu"VXu`X" ~* u VuYuW~xxvxv|xxv`~ 0T ?T|P(VuMWuVuPMWu(WeUTp	`VeTVYuUWT9U"Y`Y# ~xx
+v~vD D ~x
+vNpx#@ O@
+TT TOT ~"Ox) | 3 ~O |VuWu"`Y" ~;]v~x)?TP0T0D"0DTDT T%" D)T0? ~3e~x ~p!%Vu"	WuTxtT l~
+"|}T6@N.PTTTTMTTTOT&
+* ~"~t?tDTTzxt tEuSuR ""            taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	 
+A6-&p^NP3 `X ~n xDTzT3TND5%%4OTxx%duu3eugu&fmDtl0x0`DtTDTTTTMOT3TTTN33TOT3TTTTNTObtt$@pgefe(tt`pgefe&tAA`@BQ@qAATGThtlTT!T!TDRDQ)TTTTDD<tTD5~RPS0"Qxaxpd`F/a%de&&x%x%&-%<&&%%5N|}!&' '@'TTT!O4@DT7~(x p~ (8 ~O |~*  |' ~&8%(@x"adGpFG ~4T$T$4OTN ~78$$@
+xPdNpFT ~4DT T$$T4 ~ON78$$~@R N~	@<[ ""~@f OxP
+ ~@o"x)"*dPd@?u	 %3x$@t ~t33%5
+t%5} |*)@*)u" T u $4@t47u$%T  ~%$%$ v@$!"th0!D_DGDDu%du}"e|PGT%T%HOTRQTSth"iE}|eDG&du"geuth TGhth0t-"TTTGhuteu%d"3th 0hthhp_-DGdueu%#"T?t 6t,tt,6T!R
+tD"th Eih0t"D!Dt,tRuTPhiE|$}eGuDeu%d"
+tl@(TDT"dT`lu	|}DGDDDGTTpTKOTJOTL0TT D0HTDTDTmtl0lt(TaGTG"@DTtljul(fuguT
+`T*G"TTTTHOZY\[tll"tQ0l602U1TDTT
+`TQ0ltj*j@l*D-Dt`pj"t`TaPTNTaT@T*T-fu"gu(DDp`phtlTHDL DTJTKpDDG"tl0t0mjl0tj
+ju"	|}'GDGTtIl	tDt'aDTTTT=ODTmT)fu"gul90T`ImQjltg`tfumgu*m"Tl0tjpj"DGt't/t-t%TTOTt%t-t'ju|$}`'DG*ttl)fu"/guDTTt`mDDGD@THDTL DJTDKpDGl	tT<tu&fu"g0lj&tpjPp`mH`Kp$=DT/tkj3tljl$PPjp'""m            001	
+XTbeS	 
+putaW	 
+PtiM		 X ID	 
+ 
+CGAA		 %=CGP  d%=RW	 
+d
+0KOL		 % :C	 
+d
+1KOKO	 	 
+2
+3KOKO	 		
+4 d% arT	 
+kcnyS		 
+cnwoDE	 
+
+tix`c  ~;vxeuPau"`x"/p@tc	 ~Af		g$`uxauv"v~	dx@
+P"dPxpc"~! T@`Tvx$vT/T$34 u EOxt	DvDw	DT	T{ DDz	Dp	Tv@TQ0 g TcT`oQgvx$vWPvxP$v~	Px$TcTpo`DuxQ ~(c?T~0 @'`u"	aucT?g00 gfKx8 tAaD?TD0DT D6tLlt6taADDT ?TD0D6tlLtt	T3%%Tc~"Ow TCxD@ T/0T'x q ?TP `u"aux``u@au (`u""Eau	 ~Qju `u"a~H`cW x	dvtVz	DDy		tXY	DT]	tt		t	tuPau"`x"upau'`c"~ ~,`QvxY	T\	TT`		tt	2@uPau"`x".p}	Pu#`uWau$`uac	@DTf	upau `	"tVT}c	f	$g	$%3%$%$Dc		$de	%c	
+tV	c" ~X`KvxV	
+ttX	Y	DTD	T\]	tD^		t`a	tt			t@P"`u"aupx}	`uPau# ~"h~	xX	Y	DT]	tT\		tt		t`uPau"%`u"auT	pTzOTy	OT{	0TT D0w	T"DDT"pc ~FpxfT`$"ptDTTDt?tt*TT0~	|	w	DT	Ty{	DT	 pDzD"`uPau"\u"u]uau"`bu`b" ~* u#`ucuDaxxvxvxxv`@0TC ?TP(`uEau`uPEau(ae_^p	``e^`cu_a^9_"cTxtT l`c" ~#
+vxvx@DD`xvNpx
+@ ~	#
+@TT@OTT`"O) ~x | ~~	3 |uau `c" ~;`]vxiTL0?B0DTbDT0TE DTe Di"0?T~3e x	p`uau%~J"|F}T6@}	.PTTTTMTTTOTFfJj ~"~t?tDCTT{xt`tt	u]u\ ""$    taD	
+ 
+aOL		% :K	 
+dLVL	d% :		 
+:RWP D% 		 
+:RNS d%  
+BdRF		% :Opp D	 
+mQEL	%  : 
+ DFD			 :EDAB	GIS_		 
+CSoL	 
+RSoL	 
+A6-&p^NP3 `b ~n CxDT{T3TNDu%%tOTxx%ouu6puru&qoDtnpx0`DtTDTTTTMOT3TTTN33TOT3TTTTNTObtt$@preqe(tt`preqe&tAA`@BQ@qAATGTjtnTATaATaTD		DiTTTTDD<tTCDu~\Z]0"[xaxpd`F/a%de&&x%x%&-%<&&%%5}	|}t!&'`'@'TTTaOc	@DTf	~(x p~ 	(g ~~	 |~*  |' ~&8%(@x"adGpFG ~c	T$T$c	OTN ~f	g	$$@
+xPdNpFT ~c	DT T$$	Tc ~ON	fg	$$~@R 	}~	@<[ ""~@f ~	xP
+ ~@o"x"uT $ 4tc		@uf%$ T~$ %%$v $@"a*)dPd@u? %	3xt$@t ~33%5
+t%5} |*@)*) u"tj!0DGbDDuDpu%oP}"|GT33TT3HOTVUXWtj	"tt}|hDG&ou"kputj TGjtj0t1"TTTGjutpu%o"6tj 0jtsspb1DGoupu%c"TL?t 6tlAttl6Ta	
+tD"tj t	tj0t"DAaDtL	ltuT	Pstt|$}hGuDpu&o"
+tn@(TDT"dT`wu	|}DG DDDv	TT	pTzOTy	OT{	0TT D0w	TDTDTotn0nt(T	GTv	"@DTtn	uu(qu"ruT
+`T*G"TTT3HOT^]`_tn"tn0Q0nZ162TDTT
+`TQ0nu*twu@	DY\	Dt	up	"tT	PTNT	T@Y	TT\	u"ru(qDDp`ptjnw	DT{	DT	 Tyz	pDv	"Dtn0t0xu0ntuuu"|}
+	' DGv	Ttx		tnDtV		DTTTl	OTD?TToquru)n"90?T`x	Qux	t		tuxru*qoTn"0tupu"v	DtV	^	tt\	T	tT33T3OTtT		t\tV	uu|$}`' DG*ttn)qu"4ruDTT	toDDv	D@	TwDT{	 Dy	TDz		pDvn	tT<tu&qu"r0nu&tpuPp`xH`Kp$l	DT^	tvu3tnuw$PPup'""x    				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT 0dD4 ~=u%Vuu"WWu)VY"7`ex	0@ px@T/0?0Tg&hT T0u Vuu"WWu V"IT`du%VuYW`xKpd Te0xTdTTOhg Tvx+%!`YTdTTxOhge i!jTijxpf[pfx@vhjiTd`oTxL 0TVu;Wu(dx.pT d d#``D4"jixxY"`#d$ d
+T'0?|x'PvdlvTTTdudOWu%Vx*v|6vT`dxxWeO0jix@TTiOjfpxpf@u(VuWjixx ':a~	@@Ma eMa dxx4pF#T0?5Dx/T%3x$*4!Tx#oT`p5Dxvx*lvxvvv~xlv*')$ axp8`d|x	0v&vP0evx v DD!x dv0vxvTT!x&eP0vxvTT!vxdx0vvT!Tx"P0exvv  D!x D"v?T0'0's &x` T3DTO T3!TT3D t 8t tt,TDTDTT^T3D!TOT3TT3D t 8t tt,DTTTDTET3%%#OTY" ~+` t#?Tx/v|xLvvvdT0TdT333T dTOTTdOT|dPdT !tt VuIWuTd ~P) D!Vu"Wuvx"v5`Y ~x4v|v#?T/tTzxT | Pu!Vuu"WWu%VTT  T DyDTTT/ $34 uExO`Xgu*uhujuixxYu+eeTTee@  T)~We7ep`VWVe(Te0 ~!i jeDetpWeUeT	`VWTVYuUUT9eYTe0T ~,# ~hgDeet_0Tx	
+Dddxxd	pTxdTxx@`dddT&0x x@ ddD vxvt_xt TT333dOTddTdOTdOTTTddO0e)20)TRCT~T} | 
+x9$>"PDRCD&"TxtT l`Y" ~$5Dhgx@D@DxdTu`Wu%Ve0iQjfxpxpf2@u Vu"nWxxTijpffVu`Wu%Dx"@TRuSu  ""        				%:XR	 
+xXT		 :d% 
+x%DxT	 
+si-SL	
+khCP		 aF-D
+tluCA	 
+D-KN		 AM-O
+HCT. 0oDt ~=u%`uu"aau)`c"7`p3x	0@ pxM@T/0?0Tr&sT PT0u `uu"aau `"IT`du%`uca`x8Kpd!Te0NxToTTOsrN Tvx+%!`cToTTxOsrp t!uTtuxpf[pfx@vhutTo`oTxL!0T`u;au(dx.pT!d!d#``Dt"utxxc"`c=o$ o
+T'0?x'PvolvTTTouoOau%`x*v6vT`dxxWpO0utx@TTtOufpxpf@u(`uautxx g:a	@@Ma pMa oxx4pFcT0?uDx/T%3x$*4!TxcoT`puDxvx*lvxvvvxlv*gi$ axp8`o|x	0v&vP0pvx vA DDax ov0vxvTATax&pP0vxvTATavxox0vvTAaTx"P0pxvvA  Dax D"v?T0g0gs fx` T3DATO T3aTT3D t@8t`tLtl0DD?TDTD ^T3DaTOT3ATT3D t@8t`tLtl DTD0DD?T	tT3%%cOTc" ~+` tc?Tx/vxLvvvoT0ToT333T oTOTToOToPoT K!tt `uIauTo ~P) DM!`u"auvx"v5`c ~x4vvc?T/tCT{xT!!Pu!`uu"aau%`MTT!!T@DTDTT/ $34 uExO`bru*usuuutxxcu+ppTTpp@@ T)~ae7ep``a`p(Tp0 ~!t upDptpae_e^	``a^`cu__^9pcTp0T ~,c ~srDppt	0Tx	
+Dooxxo	pTxoTxx@`dooT&0x x@ ooD vxvt	xt TT333oOTooToOToOTTTooO0pi20	)Tr	T~T} | 
+x9$>"	PDr	D&"TxtT l`c" ~$5MDsrx@D@DxdTu`au%`p0tQufxpxpf2@u `u"naxxTtupff`u`au%Dx"@T\u$]u  ""         DC	ELDIC	 
+IAWD	 
+TEMDC% 
+AC 
+DnoDDC 
+eGAIDixe-	 
+tESDCC 
+T-KPD 
+x%%:R	O  d d%:%:S D  d d%:%:P 	 
+Dctam
+deh`X Dx~xT  
+u0Wu&Vx{0~p"VuWu"VuWupWeUeT	`VWTVYuUUT9~xY ~"3{|t ttt5ttttDt
+
+
+
+				
+t
+		t
+	5
+t	t
+		t
+	
+	
+t		tt		
+tt		t		tt	tt		ttt		tt	ttt*tt				tt	y]	]d]C`P   t		C			StQt		B			Rtt t"				`Y" ~ `Y" ~ 
+ v|xxvv0|xv4v|Pu"Vu"W~/`Y |xvvQ{t  a@ |@aQ{$%%
+0q$$%~xT;0?& ~& |%} }dPd%&$ ~ &%%@$$@~xT|x~ "('  78(;' ~<<;;u'65'(()'3)3,1u+2u  (u43	3@4'(3)*33*.-5@P:9$215<;;9,9+ d3@ .d-&Pd8d)@D::d7d)P ~~+;d>Pd-5@d8)Pd'D:7:dd) ~~@TT::Na`3'(/%60:595%6/0@D ~: ~:K ~:Q~W  |9~] /05)*.+-3,3?3~@@ ~2%52113~!p5c :9D:6:5%9:"u%5	"	eu$4"		u$e4"')(u
+$5u-*<+ ~ |} }dd1P'x)%(5)	(+*(~")' TT  T!Ru!"Su   "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --git a/arch/mips/cpu/mips32/vrx200/gphy.c b/arch/mips/cpu/mips32/vrx200/gphy.c
new file mode 100644
index 0000000000000000000000000000000000000000..4be6c2633fc3fb70ca227d95e998c944d01c2b8c
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gphy.c
@@ -0,0 +1,59 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+
+static inline void ltq_gphy_copy(const void *fw_start, const void *fw_end,
+				ulong dst_addr)
+{
+	const ulong fw_len = (ulong) fw_end - (ulong) fw_start;
+	const ulong addr = CKSEG1ADDR(dst_addr);
+
+	debug("ltq_gphy_copy: addr %08lx, fw_start %p, fw_end %p\n",
+		addr, fw_start, fw_end);
+
+	memcpy((void *) addr, fw_start, fw_len);
+}
+
+void ltq_gphy_phy11g_a1x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy11g_a1x_start;
+	extern ulong __ltq_fw_phy11g_a1x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy11g_a1x_start, &__ltq_fw_phy11g_a1x_end,
+			addr);
+}
+
+void ltq_gphy_phy11g_a2x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy11g_a2x_start;
+	extern ulong __ltq_fw_phy11g_a2x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy11g_a2x_start, &__ltq_fw_phy11g_a2x_end,
+			addr);
+}
+
+void ltq_gphy_phy22f_a1x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy22f_a1x_start;
+	extern ulong __ltq_fw_phy22f_a1x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy22f_a1x_start, &__ltq_fw_phy22f_a1x_end,
+			addr);
+}
+
+void ltq_gphy_phy22f_a2x_load(ulong addr)
+{
+	extern ulong __ltq_fw_phy22f_a2x_start;
+	extern ulong __ltq_fw_phy22f_a2x_end;
+
+	ltq_gphy_copy(&__ltq_fw_phy22f_a2x_start, &__ltq_fw_phy22f_a2x_end,
+			addr);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/gphy_fw.S b/arch/mips/cpu/mips32/vrx200/gphy_fw.S
new file mode 100644
index 0000000000000000000000000000000000000000..69c89ffacc5bb26d65e2a00fdf1f4f98aa1e15be
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gphy_fw.S
@@ -0,0 +1,28 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <asm/asm.h>
+
+	.section .rodata.__ltq_fw_phy11g_a1x
+EXPORT(__ltq_fw_phy11g_a1x_start)
+	.incbin "fw_phy11g_a1x.bin"
+EXPORT(__ltq_fw_phy11g_a1x_end)
+
+	.section .rodata.__ltq_fw_phy11g_a2x
+EXPORT(__ltq_fw_phy11g_a2x_start)
+	.incbin "fw_phy11g_a2x.bin"
+EXPORT(__ltq_fw_phy11g_a2x_end)
+
+	.section .rodata.__ltq_fw_phy22f_a1x
+EXPORT(__ltq_fw_phy22f_a1x_start)
+	.incbin "fw_phy22f_a1x.bin"
+EXPORT(__ltq_fw_phy22f_a1x_end)
+
+	.section .rodata.__ltq_fw_phy22f_a2x
+EXPORT(__ltq_fw_phy22f_a2x_start)
+	.incbin "fw_phy22f_a2x.bin"
+EXPORT(__ltq_fw_phy22f_a2x_end)
diff --git a/arch/mips/cpu/mips32/vrx200/gpio.c b/arch/mips/cpu/mips32/vrx200/gpio.c
new file mode 100644
index 0000000000000000000000000000000000000000..b9f209ac4fb2f02c73327443643a034c2b13c335
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gpio.c
@@ -0,0 +1,138 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gpio.h>
+#include <asm/lantiq/io.h>
+
+struct ltq_gpio_port_regs {
+	u32	out;
+	u32	in;
+	u32	dir;
+	u32	altsel0;
+	u32	altsel1;
+	u32	od;
+	u32	stoff;
+	u32	pudsel;
+	u32	puden;
+	u32	rsvd1[3];
+};
+
+struct ltq_gpio_regs {
+	u32				rsvd[4];
+	struct ltq_gpio_port_regs	ports[3];
+};
+
+static struct ltq_gpio_regs *ltq_gpio_regs =
+	(struct ltq_gpio_regs *) CKSEG1ADDR(LTQ_GPIO_BASE);
+
+int gpio_direction_input(int gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	/* Switch to input */
+	ltq_clrbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+
+	return 0;
+}
+
+int gpio_direction_output(int gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	/*
+	 * Reset open drain and altsel configs to workaround improper
+	 * reset values or unwanted modifications by BootROM
+	 */
+	ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	if (value)
+		ltq_setbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+
+	/* Switch to output */
+	ltq_setbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+
+	return 0;
+}
+
+int gpio_get_value(int gpio)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+	u32 val;
+
+	val = ltq_readl(&ltq_gpio_regs->ports[port].in);
+
+	return val & (1 << pin) ? 1 : 0;
+}
+
+int gpio_set_value(int gpio, int value)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (value)
+		ltq_setbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].out, (1 << pin));
+
+	return 0;
+}
+
+int gpio_set_altfunc(int gpio, int altsel0, int altsel1, int dir)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (altsel0)
+		ltq_setbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].altsel0, (1 << pin));
+
+	if (altsel1)
+		ltq_setbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].altsel1, (1 << pin));
+
+	if (dir) {
+		ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+		ltq_setbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+	} else {
+		ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+		ltq_clrbits(&ltq_gpio_regs->ports[port].dir, (1 << pin));
+	}
+
+	return 0;
+}
+
+int gpio_set_opendrain(int gpio, int od)
+{
+	unsigned port = gpio_to_port(gpio);
+	unsigned pin = gpio_to_pin(gpio);
+
+	if (od)
+		ltq_setbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+	else
+		ltq_clrbits(&ltq_gpio_regs->ports[port].od, (1 << pin));
+
+	return 0;
+}
diff --git a/arch/mips/cpu/mips32/vrx200/lowlevel_init.S b/arch/mips/cpu/mips32/vrx200/lowlevel_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..cc352698f7a344f02f748be6c4b13bdabe5b66f5
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/lowlevel_init.S
@@ -0,0 +1,21 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+NESTED(lowlevel_init, 0, ra)
+	move	t8, ra
+
+	la	t7, ltq_cgu_init
+	jalr	t7
+
+	la	t7, ltq_mem_init
+	jalr	t7
+
+	jr	t8
+	END(lowlevel_init)
diff --git a/arch/mips/cpu/mips32/vrx200/mem.c b/arch/mips/cpu/mips32/vrx200/mem.c
new file mode 100644
index 0000000000000000000000000000000000000000..a8dd0408f5d1a3d0f275bdc41375b4ec008e4e9d
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/mem.c
@@ -0,0 +1,58 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CCR03_EIGHT_BANK_MODE	(1 << 0)
+#define LTQ_CCR08_CS_MAP_SHIFT		24
+#define LTQ_CCR08_CS_MAP_MASK		(0x3 << LTQ_CCR08_CS_MAP_SHIFT)
+#define LTQ_CCR11_COLUMN_SIZE_SHIFT	24
+#define LTQ_CCR11_COLUMN_SIZE_MASK	(0x7 << LTQ_CCR11_COLUMN_SIZE_SHIFT)
+#define LTQ_CCR11_ADDR_PINS_MASK	0x7
+#define LTQ_CCR15_MAX_COL_REG_SHIFT	24
+#define LTQ_CCR15_MAX_COL_REG_MASK	(0xF << LTQ_CCR15_MAX_COL_REG_SHIFT)
+#define LTQ_CCR16_MAX_ROW_REG_MASK	0xF
+
+static void *ltq_mc_ddr_base = (void *) CKSEG1ADDR(LTQ_MC_DDR_BASE);
+
+static inline u32 ltq_mc_ccr_read(u32 index)
+{
+	return ltq_readl(ltq_mc_ddr_base + LTQ_MC_DDR_CCR_OFFSET(index));
+}
+
+phys_size_t initdram(int board_type)
+{
+	u32 max_col_reg, max_row_reg, column_size, addr_pins;
+	u32 banks, cs_map;
+	phys_size_t size;
+
+	banks = (ltq_mc_ccr_read(3) & LTQ_CCR03_EIGHT_BANK_MODE) ? 8 : 4;
+
+	cs_map = (ltq_mc_ccr_read(8) & LTQ_CCR08_CS_MAP_MASK) >>
+		LTQ_CCR08_CS_MAP_SHIFT;
+
+	column_size = (ltq_mc_ccr_read(11) & LTQ_CCR11_COLUMN_SIZE_MASK) >>
+		LTQ_CCR11_COLUMN_SIZE_SHIFT;
+
+	addr_pins = ltq_mc_ccr_read(11) & LTQ_CCR11_ADDR_PINS_MASK;
+
+	max_col_reg = (ltq_mc_ccr_read(15) & LTQ_CCR15_MAX_COL_REG_MASK) >>
+		LTQ_CCR15_MAX_COL_REG_SHIFT;
+
+	max_row_reg = ltq_mc_ccr_read(16) & LTQ_CCR16_MAX_ROW_REG_MASK;
+
+	/*
+	 * size (bytes) = 2 ^ rowsize * 2 ^ colsize * banks * chipselects
+	 *                 * datawidth (bytes)
+	 */
+	size = (2 << (max_col_reg - column_size -1)) *
+		(2 << (max_row_reg - addr_pins -1)) * banks * cs_map * 2;
+
+	return size;
+}
diff --git a/arch/mips/cpu/mips32/vrx200/mem_init.S b/arch/mips/cpu/mips32/vrx200/mem_init.S
new file mode 100644
index 0000000000000000000000000000000000000000..b30e5bbbc6e040b575bc92856612c0d57d4a8944
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/mem_init.S
@@ -0,0 +1,124 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* Must be configured in BOARDDIR */
+#include <ddr_settings.h>
+
+#define LTQ_MC_DDR_START		(1 << 8)
+#define LTQ_MC_DDR_DLL_LOCK_IND	1
+
+	/* Store given value in MC DDR CCRx register */
+	.macro ccr_sw num, val
+	li	t1, \val
+	sw	t1, LTQ_MC_DDR_CCR_OFFSET(\num)(t0)
+	.endm
+
+LEAF(ltq_mem_init)
+	/* Load MC DDR module base */
+	li	t0, (LTQ_MC_DDR_BASE | KSEG1)
+
+	/* Put memory controller in inactive mode */
+	sw	zero, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+
+	/* Init MC DDR CCR registers with values from ddr_settings.h */
+	ccr_sw	0, MC_CCR00_VALUE
+	ccr_sw	1, MC_CCR01_VALUE
+	ccr_sw	2, MC_CCR02_VALUE
+	ccr_sw	3, MC_CCR03_VALUE
+	ccr_sw	4, MC_CCR04_VALUE
+	ccr_sw	5, MC_CCR05_VALUE
+	ccr_sw	6, MC_CCR06_VALUE
+	ccr_sw	7, MC_CCR07_VALUE
+	ccr_sw	8, MC_CCR08_VALUE
+	ccr_sw	9, MC_CCR09_VALUE
+
+	ccr_sw	10, MC_CCR10_VALUE
+	ccr_sw	11, MC_CCR11_VALUE
+	ccr_sw	12, MC_CCR12_VALUE
+	ccr_sw	13, MC_CCR13_VALUE
+	ccr_sw	14, MC_CCR14_VALUE
+	ccr_sw	15, MC_CCR15_VALUE
+	ccr_sw	16, MC_CCR16_VALUE
+	ccr_sw	17, MC_CCR17_VALUE
+	ccr_sw	18, MC_CCR18_VALUE
+	ccr_sw	19, MC_CCR19_VALUE
+
+	ccr_sw	20, MC_CCR20_VALUE
+	ccr_sw	21, MC_CCR21_VALUE
+	ccr_sw	22, MC_CCR22_VALUE
+	ccr_sw	23, MC_CCR23_VALUE
+	ccr_sw	24, MC_CCR24_VALUE
+	ccr_sw	25, MC_CCR25_VALUE
+	ccr_sw	26, MC_CCR26_VALUE
+	ccr_sw	27, MC_CCR27_VALUE
+	ccr_sw	28, MC_CCR28_VALUE
+	ccr_sw	29, MC_CCR29_VALUE
+
+	ccr_sw	30, MC_CCR30_VALUE
+	ccr_sw	31, MC_CCR31_VALUE
+	ccr_sw	32, MC_CCR32_VALUE
+	ccr_sw	33, MC_CCR33_VALUE
+	ccr_sw	34, MC_CCR34_VALUE
+	ccr_sw	35, MC_CCR35_VALUE
+	ccr_sw	36, MC_CCR36_VALUE
+	ccr_sw	37, MC_CCR37_VALUE
+	ccr_sw	38, MC_CCR38_VALUE
+	ccr_sw	39, MC_CCR39_VALUE
+
+	ccr_sw	40, MC_CCR40_VALUE
+	ccr_sw	41, MC_CCR41_VALUE
+	ccr_sw	42, MC_CCR42_VALUE
+	ccr_sw	43, MC_CCR43_VALUE
+	ccr_sw	44, MC_CCR44_VALUE
+	ccr_sw	45, MC_CCR45_VALUE
+	ccr_sw	46, MC_CCR46_VALUE
+
+	ccr_sw	52, MC_CCR52_VALUE
+	ccr_sw	53, MC_CCR53_VALUE
+	ccr_sw	54, MC_CCR54_VALUE
+	ccr_sw	55, MC_CCR55_VALUE
+	ccr_sw	56, MC_CCR56_VALUE
+	ccr_sw	57, MC_CCR57_VALUE
+	ccr_sw	58, MC_CCR58_VALUE
+	ccr_sw	59, MC_CCR59_VALUE
+
+	ccr_sw	60, MC_CCR60_VALUE
+	ccr_sw	61, MC_CCR61_VALUE
+
+	/*
+	 * Put memory controller in active mode and start initialitation
+	 * sequence for connected DDR-SDRAM device
+	 */
+	lw	t1, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+	li	t2, LTQ_MC_DDR_START
+	or	t1, t1, t2
+	sw	t1, LTQ_MC_DDR_CCR_OFFSET(7)(t0)
+
+	/*
+	 * Wait until DLL has locked and core is ready for data transfers.
+	 * DLL lock indication is in register CCR47 and CCR48
+	 */
+wait_ready:
+	li	t1, LTQ_MC_DDR_DLL_LOCK_IND
+	lw	t2, LTQ_MC_DDR_CCR_OFFSET(47)(t0)
+	and	t2, t2, t1
+	bne	t1, t2, wait_ready
+
+	lw	t2, LTQ_MC_DDR_CCR_OFFSET(48)(t0)
+	and	t2, t2, t1
+	bne	t1, t2, wait_ready
+
+	jr	ra
+
+	END(ltq_mem_init)
diff --git a/arch/mips/cpu/mips32/vrx200/pmu.c b/arch/mips/cpu/mips32/vrx200/pmu.c
new file mode 100644
index 0000000000000000000000000000000000000000..b2b57b9b4cdd2b85e1ee8cc661646fb195b3840d
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/pmu.c
@@ -0,0 +1,131 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PMU_PWDCR_RESERVED		((1 << 13) | (1 << 4))
+
+#define LTQ_PMU_PWDCR_PCIELOC_EN	(1 << 31)
+#define LTQ_PMU_PWDCR_GPHY		(1 << 30)
+#define LTQ_PMU_PWDCR_PPE_TOP		(1 << 29)
+#define LTQ_PMU_PWDCR_SWITCH		(1 << 28)
+#define LTQ_PMU_PWDCR_USB1		(1 << 27)
+#define LTQ_PMU_PWDCR_USB1_PHY		(1 << 26)
+#define LTQ_PMU_PWDCR_TDM		(1 << 25)
+#define LTQ_PMU_PWDCR_PPE_DPLUS		(1 << 24)
+#define LTQ_PMU_PWDCR_PPE_DPLUM		(1 << 23)
+#define LTQ_PMU_PWDCR_PPE_EMA		(1 << 22)
+#define LTQ_PMU_PWDCR_PPE_TC		(1 << 21)
+#define LTQ_PMU_PWDCR_DEU		(1 << 20)
+#define LTQ_PMU_PWDCR_PPE_SLL01		(1 << 19)
+#define LTQ_PMU_PWDCR_PPE_QSB		(1 << 18)
+#define LTQ_PMU_PWDCR_UART1		(1 << 17)
+#define LTQ_PMU_PWDCR_SDIO		(1 << 16)
+#define LTQ_PMU_PWDCR_AHBM		(1 << 15)
+#define LTQ_PMU_PWDCR_FPIM		(1 << 14)
+#define LTQ_PMU_PWDCR_GPTC		(1 << 12)
+#define LTQ_PMU_PWDCR_LEDC		(1 << 11)
+#define LTQ_PMU_PWDCR_EBU		(1 << 10)
+#define LTQ_PMU_PWDCR_DSL		(1 << 9)
+#define LTQ_PMU_PWDCR_SPI		(1 << 8)
+#define LTQ_PMU_PWDCR_USIF		(1 << 7)
+#define LTQ_PMU_PWDCR_USB0		(1 << 6)
+#define LTQ_PMU_PWDCR_DMA		(1 << 5)
+#define LTQ_PMU_PWDCR_DFEV1		(1 << 3)
+#define LTQ_PMU_PWDCR_DFEV0		(1 << 2)
+#define LTQ_PMU_PWDCR_FPIS		(1 << 1)
+#define LTQ_PMU_PWDCR_USB0_PHY		(1 << 0)
+
+struct ltq_pmu_regs {
+	u32	rsvd0[7];
+	u32	pwdcr;		/* Power down control */
+	u32	sr;		/* Power down status */
+	u32	pwdcr1;		/* Power down control 1 */
+	u32	sr1;		/* Power down status 1 */
+};
+
+static struct ltq_pmu_regs* ltq_pmu_regs =
+	(struct ltq_pmu_regs *) CKSEG1ADDR(LTQ_PMU_BASE);
+
+u32 ltq_pm_map(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_PM_CORE:
+		val = LTQ_PMU_PWDCR_UART1 | LTQ_PMU_PWDCR_FPIM |
+			LTQ_PMU_PWDCR_EBU;
+		break;
+	case LTQ_PM_DMA:
+		val = LTQ_PMU_PWDCR_DMA;
+		break;
+	case LTQ_PM_ETH:
+		val = LTQ_PMU_PWDCR_GPHY | LTQ_PMU_PWDCR_PPE_TOP |
+			LTQ_PMU_PWDCR_SWITCH | LTQ_PMU_PWDCR_PPE_DPLUS |
+			LTQ_PMU_PWDCR_PPE_DPLUM | LTQ_PMU_PWDCR_PPE_EMA |
+			LTQ_PMU_PWDCR_PPE_TC | LTQ_PMU_PWDCR_PPE_SLL01 |
+			LTQ_PMU_PWDCR_PPE_QSB;
+		break;
+	case LTQ_PM_SPI:
+		val = LTQ_PMU_PWDCR_SPI;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_pm_enable(enum ltq_pm_modules module)
+{
+	const unsigned long timeout = 1000;
+	unsigned long timebase;
+	u32 sr, val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_pmu_regs->pwdcr, val);
+
+	timebase = get_timer(0);
+
+	do {
+		sr = ltq_readl(&ltq_pmu_regs->sr);
+		if (~sr & val)
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int ltq_pm_disable(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_pmu_regs->pwdcr, val);
+
+	return 0;
+}
+
+void ltq_pmu_init(void)
+{
+	u32 set, clr;
+
+	clr = ltq_pm_map(LTQ_PM_CORE);
+	set = ~(LTQ_PMU_PWDCR_RESERVED | clr);
+
+	ltq_clrsetbits(&ltq_pmu_regs->pwdcr, clr, set);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/rcu.c b/arch/mips/cpu/mips32/vrx200/rcu.c
new file mode 100644
index 0000000000000000000000000000000000000000..86a3e59ca2d43fec8b752cf9860a8055afe9dac2
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/rcu.c
@@ -0,0 +1,176 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/cpu.h>
+
+#define LTQ_RCU_RD_GPHY0	(1 << 31)	/* GPHY0 */
+#define LTQ_RCU_RD_SRST		(1 << 30)	/* Global SW Reset */
+#define LTQ_RCU_RD_GPHY1	(1 << 29)	/* GPHY1 */
+#define LTQ_RCU_RD_ENMIP2	(1 << 28)	/* Enable NMI of PLL2 */
+#define LTQ_RCU_RD_REG25_PD	(1 << 26)	/* Power down 2.5V regulator */
+#define LTQ_RCU_RD_ENDINIT	(1 << 25)	/* FPI slave bus access */
+#define LTQ_RCU_RD_PPE_ATM_TC	(1 << 23)	/* PPE ATM TC */
+#define LTQ_RCU_RD_PCIE		(1 << 22)	/* PCI-E core */
+#define LTQ_RCU_RD_ETHSW	(1 << 21)	/* Ethernet switch */
+#define LTQ_RCU_RD_DSP_DEN	(1 << 20)	/* Enable DSP JTAG */
+#define LTQ_RCU_RD_TDM		(1 << 19)	/* TDM module interface */
+#define LTQ_RCU_RD_ENMIP1	(1 << 18)	/* Enable NMI of PLL1 */
+#define LTQ_RCU_RD_SWBCK	(1 << 17)	/* Switch backward compat */
+#define LTQ_RCU_RD_HSNAND	(1 << 16)	/* HSNAND controller */
+#define LTQ_RCU_RD_ENMIP0	(1 << 15)	/* Enable NMI of PLL0 */
+#define LTQ_RCU_RD_MC		(1 << 14)	/* Memory Controller */
+#define LTQ_RCU_RD_PCI		(1 << 13)	/* PCI core */
+#define LTQ_RCU_RD_PCIE_PHY	(1 << 12)	/* PCI-E Phy */
+#define LTQ_RCU_RD_DFE_CORE	(1 << 11)	/* DFE core */
+#define LTQ_RCU_RD_SDIO		(1 << 10)	/* SDIO core */
+#define LTQ_RCU_RD_DMA		(1 << 9)	/* DMA core */
+#define LTQ_RCU_RD_PPE		(1 << 8)	/* PPE core */
+#define LTQ_RCU_RD_DFE		(1 << 7)	/* DFE core */
+#define LTQ_RCU_RD_AHB		(1 << 6)	/* AHB bus */
+#define LTQ_RCU_RD_HRST_CFG	(1 << 5)	/* HW reset configuration */
+#define LTQ_RCU_RD_USB		(1 << 4)	/* USB and Phy core */
+#define LTQ_RCU_RD_PPE_DSP	(1 << 3)	/* PPE DSP interface */
+#define LTQ_RCU_RD_FPI		(1 << 2)	/* FPI bus */
+#define LTQ_RCU_RD_CPU		(1 << 1)	/* CPU subsystem */
+#define LTQ_RCU_RD_HRST		(1 << 0)	/* HW reset via HRST pin */
+
+#define LTQ_RCU_STAT_BOOT_SHIFT		17
+#define LTQ_RCU_STAT_BOOT_MASK		(0xF << LTQ_RCU_STAT_BOOT_SHIFT)
+#define LTQ_RCU_STAT_BOOT_H		(1 << 12)
+
+#define LTQ_RCU_GP_STRAP_CLOCKSOURCE	(1 << 15)
+
+struct ltq_rcu_regs {
+	u32	rsvd0[4];
+	u32	req;		/* Reset request */
+	u32	stat;		/* Reset status */
+	u32	usb0_cfg;	/* USB0 configure */
+	u32	gp_strap;	/* GPIO strapping */
+	u32	gfs_add0;	/* GPHY0 firmware base addr */
+	u32	stat2;		/* SLIC and USB reset status */
+	u32	pci_rdy;	/* PCI boot ready */
+	u32	ppe_conf;	/* PPE ethernet config */
+	u32	pcie_phy_con;	/* PCIE PHY config/status */
+	u32	usb1_cfg;	/* USB1 configure */
+	u32	usb_ana_cfg1a;	/* USB analog config 1a */
+	u32	usb_ana_cfg1b;	/* USB analog config 1b */
+	u32	rsvd1;
+	u32	gf_mdio_add;	/* GPHY0/1 MDIO address */
+	u32	req2;		/* SLIC and USB reset request */
+	u32	ahb_endian;	/* AHB bus endianess */
+	u32	rsvd2[4];
+	u32	gcc;		/* General CPU config */
+	u32	rsvd3;
+	u32	gfs_add1;	/* GPHY1 firmware base addr */
+};
+
+static struct ltq_rcu_regs* ltq_rcu_regs =
+	(struct ltq_rcu_regs *) CKSEG1ADDR(LTQ_RCU_BASE);
+
+u32 ltq_reset_map(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_RESET_CORE:
+	case LTQ_RESET_SOFT:
+		val = LTQ_RCU_RD_SRST | LTQ_RCU_RD_CPU | LTQ_RCU_RD_ENMIP2 |
+			LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_DMA:
+		val = LTQ_RCU_RD_DMA;
+		break;
+	case LTQ_RESET_ETH:
+		val = LTQ_RCU_RD_PPE | LTQ_RCU_RD_ETHSW;
+		break;
+	case LTQ_RESET_PHY:
+		val = LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_HARD:
+		val = LTQ_RCU_RD_HRST;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_reset_activate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+int ltq_reset_deactivate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+enum ltq_boot_select ltq_boot_select(void)
+{
+	u32 stat;
+	unsigned ret;
+
+	/*
+	 * Boot select value is built from bits 20-17 and bit 12.
+	 * The bit sequence is read as 4-2-1-0-3.
+	 */
+	stat = ltq_readl(&ltq_rcu_regs->stat);
+	ret = ((stat & LTQ_RCU_STAT_BOOT_H) << 4) |
+		((stat & LTQ_RCU_STAT_BOOT_MASK) >> LTQ_RCU_STAT_BOOT_SHIFT);
+
+	return ret;
+}
+
+void ltq_rcu_gphy_boot(unsigned int id, ulong addr)
+{
+	u32 module;
+	void *gfs_add;
+
+	switch (id) {
+	case 0:
+		module = LTQ_RCU_RD_GPHY0;
+		gfs_add = &ltq_rcu_regs->gfs_add0;
+		break;
+	case 1:
+		module = LTQ_RCU_RD_GPHY1;
+		gfs_add = &ltq_rcu_regs->gfs_add1;
+		break;
+	default:
+		BUG();
+	}
+
+	/* Stop and reset GPHY */
+	ltq_setbits(&ltq_rcu_regs->req, module);
+
+	/* Configure firmware and boot address */
+	ltq_writel(gfs_add, CPHYSADDR(addr & 0xFFFFC000));
+
+	/* Start GPHY by releasing reset */
+	ltq_clrbits(&ltq_rcu_regs->req, module);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/spl_sram/Makefile b/arch/mips/cpu/mips32/vrx200/spl_sram/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..1b728752221a16ea2e61dd9c74a6f6128c4142a4
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/spl_sram/Makefile
@@ -0,0 +1,22 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+SOBJS	:= start.o
+SRCS	:= $(SOBJS:.o=.S)
+OBJS	:= $(addprefix $(obj),$(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/mips/cpu/mips32/vrx200/spl_sram/start.S b/arch/mips/cpu/mips32/vrx200/spl_sram/start.S
new file mode 100644
index 0000000000000000000000000000000000000000..f44b5a6b2d78916cab03b63a5861694bf07b9989
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/spl_sram/start.S
@@ -0,0 +1,65 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2003 Wolfgang Denk, wd@denx.de
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <config.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+	.set noreorder
+
+	.globl _start
+	.text
+_start:
+	/* Init Timer */
+	mtc0	zero, CP0_COUNT
+	mtc0	zero, CP0_COMPARE
+
+	/* Disable caches */
+	li	t0, CONF_CM_UNCACHED
+	mtc0	t0, CP0_CONFIG
+
+	/* Initialize $gp */
+	bal	1f
+	 nop
+	.word	_gp
+1:
+	lw	gp, 0(ra)
+
+	/* Initialize any external memory */
+	la	t9, lowlevel_init
+	jalr	t9
+	 nop
+
+	/* Initialize caches... */
+	la	t9, mips_cache_reset
+	jalr	t9
+	 nop
+
+	/* ... and enable them */
+	li	t0, CONFIG_SYS_MIPS_CACHE_MODE
+	mtc0	t0, CP0_CONFIG
+
+	/* Clear BSS */
+	la	t1, __bss_start
+	la	t2, __bss_end
+	sub	t1, 4
+1:
+	addi	t1, 4
+	bltl	t1, t2, 1b
+	 sw	zero, 0(t1)
+
+	/*
+	 * Setup stack pointer at end of SRAM space,
+	 * force alignment on 16 byte boundary
+	 */
+	li	t0, ((CONFIG_SYS_SRAM_BASE + CONFIG_SYS_SRAM_SIZE - 1) & ~0xF)
+	la	sp, 0(t0)
+
+	la	t9, spl_lantiq_init
+	jr	t9
+	 nop
diff --git a/arch/mips/cpu/mips32/vrx200/u-boot.lds b/arch/mips/cpu/mips32/vrx200/u-boot.lds
new file mode 100644
index 0000000000000000000000000000000000000000..97653841086aa7fd91f70eeb4dc9f516f41f245c
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2003 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradlittlemips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text : {
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : {
+		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
+	}
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+	.sdata : {
+		*(.sdata*)
+	}
+
+	. = .;
+	_gp = ALIGN(16) + 0x7ff0;
+
+	.got : {
+		__got_start = .;
+		*(.got)
+		__got_end = .;
+	}
+
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+	.u_boot_cmd : {
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	. = ALIGN(4);
+	__image_copy_end = .;
+	uboot_end_data = .;
+
+	.bss (NOLOAD) : {
+		__bss_start = .;
+		*(.bss*)
+		*(.sbss*)
+		. = ALIGN(4);
+		__bss_end = .;
+	}
+
+	. = ALIGN(4);
+	__end = .;
+	uboot_end = .;
+}
diff --git a/arch/mips/include/asm/arch-danube/config.h b/arch/mips/include/asm/arch-danube/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..1eea72420919962c8754affde2e1520abcb46e45
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/config.h
@@ -0,0 +1,116 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * Common board configuration for Lantiq XWAY Danube family
+ *
+ * Use following defines in your board config to enable specific features
+ * and drivers for this SoC:
+ *
+ * CONFIG_LTQ_SUPPORT_UART
+ * - support the Danube ASC/UART interface and console
+ *
+ * CONFIG_LTQ_SUPPORT_NOR_FLASH
+ * - support a parallel NOR flash via the CFI interface in flash bank 0
+ *
+ * CONFIG_LTQ_SUPPORT_ETHERNET
+ * - support the Danube ETOP and MAC interface
+ *
+ * CONFIG_LTQ_SUPPORT_SPI_FLASH
+ * - support the Danube SPI interface and serial flash drivers
+ * - specific SPI flash drivers must be configured separately
+ */
+
+#ifndef __DANUBE_CONFIG_H__
+#define __DANUBE_CONFIG_H__
+
+/* CPU and SoC type */
+#define CONFIG_SOC_LANTIQ
+#define CONFIG_SOC_XWAY_DANUBE
+
+/* Cache configuration */
+#define CONFIG_SYS_MIPS_CACHE_MODE	(CONF_CM_CACHABLE_NO_WA)
+#define CONFIG_SYS_DCACHE_SIZE		16384
+#define CONFIG_SYS_ICACHE_SIZE		16384
+#define CONFIG_SYS_CACHELINE_SIZE	32
+#define CONFIG_SYS_MIPS_CACHE_EXT_INIT
+
+/*
+ * Supported clock modes
+ * PLL0 clock output is 333 MHz
+ * PLL1 clock output is 262.144 MHz
+ */
+#define LTQ_CLK_CPU_333_DDR_167		0	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_111_DDR_111		1	/* Base PLL0, OCP 1 */
+
+/* CPU speed */
+#define CONFIG_SYS_CLOCK_MODE		LTQ_CLK_CPU_333_DDR_167
+#define CONFIG_SYS_MIPS_TIMER_FREQ	166666667
+#define CONFIG_SYS_HZ			1000
+
+/* RAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_MEMTEST_START	0x81000000
+#define CONFIG_SYS_MEMTEST_END		0x82000000
+#define CONFIG_SYS_LOAD_ADDR		0x81000000
+#define CONFIG_SYS_INIT_SP_OFFSET	0x4000
+
+/* ASC/UART driver and console */
+#define CONFIG_LANTIQ_SERIAL
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* FLASH driver */
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+#define CONFIG_SYS_FLASH_BASE		0xB0000000
+#define CONFIG_FLASH_16BIT
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	50
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+
+#define CONFIG_CMD_FLASH
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_NOR_FLASH */
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_LANTIQ_SPI
+#define CONFIG_SPI_FLASH
+
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_ETHERNET)
+#define CONFIG_LANTIQ_DMA
+#define CONFIG_LANTIQ_DANUBE_ETOP
+
+#define CONFIG_PHYLIB
+#define CONFIG_MII
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#endif
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define CONFIG_SYS_TEXT_BASE		0xa0100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SYS_DISABLE_CACHE
+#else
+#define CONFIG_SYS_TEXT_BASE		0xB0000000
+#define CONFIG_SYS_XWAY_EBU_BOOTCFG	0x688C688C
+#define CONFIG_XWAY_SWAP_BYTES
+#endif
+
+#define	CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#endif /* __DANUBE_CONFIG_H__ */
diff --git a/arch/mips/include/asm/arch-danube/cpu.h b/arch/mips/include/asm/arch-danube/cpu.h
new file mode 100644
index 0000000000000000000000000000000000000000..0ea7b8b2f8fb393ae006fbedc8ee06f5354b42e5
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/cpu.h
@@ -0,0 +1,14 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __DANUBE_CPU_H__
+#define __DANUBE_CPU_H__
+
+extern void ltq_ebu_init(void);
+extern void ltq_pmu_init(void);
+
+#endif /* __DANUBE_CPU_H__ */
diff --git a/arch/mips/include/asm/arch-danube/gpio.h b/arch/mips/include/asm/arch-danube/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..1cffb7ad64a59b6a7fbb2c0d425f11f660d16c82
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/gpio.h
@@ -0,0 +1,13 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __DANUBE_GPIO_H__
+#define __DANUBE_GPIO_H__
+
+#include <asm/lantiq/gpio.h>
+
+#endif /* __DANUBE_GPIO_H__ */
diff --git a/arch/mips/include/asm/arch-danube/soc.h b/arch/mips/include/asm/arch-danube/soc.h
new file mode 100644
index 0000000000000000000000000000000000000000..12c8042e5c18239299a12950ad5cc056e8ab3a30
--- /dev/null
+++ b/arch/mips/include/asm/arch-danube/soc.h
@@ -0,0 +1,39 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __DANUBE_SOC_H__
+#define __DANUBE_SOC_H__
+
+#define LTQ_ASC0_BASE			0x1E100400
+#define LTQ_SPI_BASE			0x1E100800
+#define LTQ_GPIO_BASE			0x1E100B00
+#define LTQ_ASC1_BASE			0x1E100C00
+#define LTQ_DMA_BASE			0x1E104100
+
+#define LTQ_EBU_BASE			0x1E105300
+#define LTQ_EBU_REGION0_BASE		0x10000000
+#define LTQ_EBU_REGION0_SIZE		(64 * 1024 * 1024)
+#define LTQ_EBU_REGION1_BASE		0x14000000
+#define LTQ_EBU_REGION1_SIZE		(32 * 1024 * 1024)
+
+#define LTQ_PPE_BASE			0x1E180000
+#define LTQ_PPE_ETOP_BASE		(LTQ_PPE_BASE + 0x11800)
+#define LTQ_PPE_ENET0_BASE		(LTQ_PPE_BASE + 0x11840)
+
+#define LTQ_PMU_BASE			0x1F102000
+#define LTQ_CGU_BASE			0x1F103000
+#define LTQ_MPS_BASE			0x1F107000
+#define LTQ_CHIPID_BASE			(LTQ_MPS_BASE + 0x340)
+#define LTQ_RCU_BASE			0x1F203000
+
+#define LTQ_MC_GEN_BASE			0x1F800000
+#define LTQ_MC_SDR_BASE			0x1F800200
+#define LTQ_MC_DDR_BASE			0x1F801000
+#define LTQ_MC_DDR_DC_OFFSET(x)		(x * 0x10)
+
+#endif /* __DANUBE_SOC_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/config.h b/arch/mips/include/asm/arch-vrx200/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..63e2f1c4f1d7976f2d884a15d38de9887d3cc6e9
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/config.h
@@ -0,0 +1,167 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * Common board configuration for Lantiq XWAY VRX200 family
+ *
+ * Use following defines in your board config to enable specific features
+ * and drivers for this SoC:
+ *
+ * CONFIG_LTQ_SUPPORT_UART
+ * - support the VRX200 ASC/UART interface and console
+ *
+ * CONFIG_LTQ_SUPPORT_NOR_FLASH
+ * - support a parallel NOR flash via the CFI interface in flash bank 0
+ *
+ * CONFIG_LTQ_SUPPORT_SPI_FLASH
+ * - support the VRX200 SPI interface and serial flash drivers
+ * - specific SPI flash drivers must be configured separately
+ *
+ * CONFIG_LTQ_SUPPORT_ETHERNET
+ * - support the VRX200 internal switch
+ *
+ * CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH
+ * - build a preloader that runs in the internal SRAM and loads
+ *   the U-Boot from SPI flash into RAM
+ */
+
+#ifndef __VRX200_CONFIG_H__
+#define __VRX200_CONFIG_H__
+
+/* CPU and SoC type */
+#define CONFIG_SOC_LANTIQ
+#define CONFIG_SOC_XWAY_VRX200
+
+/* Cache configuration */
+#define CONFIG_SYS_MIPS_CACHE_MODE	(CONF_CM_CACHABLE_NO_WA)
+#define CONFIG_SYS_DCACHE_SIZE		16384
+#define CONFIG_SYS_ICACHE_SIZE		16384
+#define CONFIG_SYS_CACHELINE_SIZE	32
+
+/*
+ * Supported clock modes
+ * PLL0 clock output is 1000 MHz
+ * PLL1 clock output is 393.219 MHz
+ */
+#define LTQ_CLK_CPU_600_DDR_300	0	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_600_DDR_200	1	/* Base PLL0, OCP 3 */
+#define LTQ_CLK_CPU_500_DDR_250	2	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_500_DDR_200	3	/* Base PLL0, OCP 2.5 */
+#define LTQ_CLK_CPU_333_DDR_167	4	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_167_DDR_167	5	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_125_DDR_125	6	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_393_DDR_197	7	/* Base PLL1, OCP 2 */
+#define LTQ_CLK_CPU_197_DDR_197	8	/* Base PLL1, OCP 1 */
+
+/* CPU speed */
+#define CONFIG_SYS_CLOCK_MODE		LTQ_CLK_CPU_500_DDR_250
+#define CONFIG_SYS_MIPS_TIMER_FREQ	250000000
+#define CONFIG_SYS_HZ			1000
+
+/* RAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_MEMTEST_START	0x81000000
+#define CONFIG_SYS_MEMTEST_END		0x82000000
+#define CONFIG_SYS_LOAD_ADDR		0x81000000
+#define CONFIG_SYS_INIT_SP_OFFSET	0x4000
+
+/* SRAM */
+#define CONFIG_SYS_SRAM_BASE		0xBE220000
+#define CONFIG_SYS_SRAM_SIZE		0x10000
+
+/* ASC/UART driver and console */
+#define CONFIG_LANTIQ_SERIAL
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* FLASH driver */
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+#define CONFIG_SYS_FLASH_BASE		0xB0000000
+#define CONFIG_FLASH_16BIT
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	50
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+
+#define CONFIG_CMD_FLASH
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_NOR_FLASH */
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_LANTIQ_SPI
+#define CONFIG_SPI_FLASH
+
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_ETHERNET)
+#define CONFIG_LANTIQ_DMA
+#define CONFIG_LANTIQ_VRX200_SWITCH
+#define CONFIG_PHY_LANTIQ
+
+#define CONFIG_PHYLIB
+#define CONFIG_MII
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH) && defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_LTQ_SPL_SRAM
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SPL_SRAM)
+#define CONFIG_SPL
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_TEXT_BASE		0xBE220000
+#define CONFIG_SPL_START_S_PATH		"arch/mips/cpu/mips32/vrx200/spl_sram"
+#define CONFIG_SPL_MALLOC_BASE		CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SPL_MALLOC_SIZE		(64 * 1024)
+#endif
+
+#if defined(CONFIG_LTQ_SPL_DEBUG)
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZMA)
+#define CONFIG_LZMA
+#define CONFIG_SPL_LZMA_SUPPORT
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+#define CONFIG_LZO
+#define CONFIG_SPL_LZO_SUPPORT
+#endif
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define CONFIG_SYS_TEXT_BASE		0xA0100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SYS_DISABLE_CACHE
+#elif defined(CONFIG_SYS_BOOT_EVA)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#elif defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#else
+#define CONFIG_SYS_TEXT_BASE		0xB0000000
+#define CONFIG_SYS_XWAY_EBU_BOOTCFG	0x688C688C
+#define CONFIG_XWAY_SWAP_BYTES
+#endif
+
+#define	CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#endif /* __VRX200_CONFIG_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/cpu.h b/arch/mips/include/asm/arch-vrx200/cpu.h
new file mode 100644
index 0000000000000000000000000000000000000000..79f4e14614e042de5f723e2748c706dba794fce0
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/cpu.h
@@ -0,0 +1,28 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __VRX200_CPU_H__
+#define __VRX200_CPU_H__
+
+enum ltq_boot_select {
+	LTQ_BOOT_NOR_NO_BOOTROM = 0,
+	LTQ_BOOT_RGMII1 = 1,
+	LTQ_BOOT_NOR = 2,
+	LTQ_BOOT_UART_NO_EEPROM = 4,
+	LTQ_BOOT_PCI = 6,
+	LTQ_BOOT_UART = 8,
+	LTQ_BOOT_SPI = 10,
+	LTQ_BOOT_NAND = 12,
+};
+
+extern void ltq_ebu_init(void);
+extern void ltq_pmu_init(void);
+
+extern enum ltq_boot_select ltq_boot_select(void);
+extern const char *ltq_boot_select_str(void);
+
+#endif /* __VRX200_CPU_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gphy.h b/arch/mips/include/asm/arch-vrx200/gphy.h
new file mode 100644
index 0000000000000000000000000000000000000000..a78556efffa29fef5f9ff6ed36ef5ce1a0b3e2d8
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gphy.h
@@ -0,0 +1,66 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __VRX200_GPHY_H__
+#define __VRX200_GPHY_H__
+
+enum ltq_gphy_clk {
+	/* XTAL 36 MHz input */
+	LTQ_GPHY_CLK_36MHZ_XTAL = 1,
+	/* 25 MHz from PLL0 with divider */
+	LTQ_GPHY_CLK_25MHZ_PLL0 = 2,
+	/* derived from PLL2 output (XTAL is 36 MHz) */
+	LTQ_GPHY_CLK_24MHZ_PLL2 = 3,
+	/* 25 MHz Clock from Pin GPIO3 */
+	LTQ_GPHY_CLK_25MHZ_GPIO3 = 4,
+};
+
+/*
+ * Load PHY11G firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a1x_load(ulong addr);
+
+/*
+ * Load PHY11G firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a2x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a1x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a2x_load(ulong addr);
+
+/*
+ * Set clock source of internal GPHYs
+ *
+ * According registers resides in CGU address space. Thus this function
+ * is implemented by the CGU driver.
+ */
+extern void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk);
+
+/*
+ * Boot internal GPHY with id from given RAM address
+ *
+ * According registers resides in RCU address space. Thus this function
+ * is implemented by the RCU driver.
+ */
+extern void ltq_rcu_gphy_boot(unsigned int id, ulong addr);
+
+#endif /* __VRX200_GPHY_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gpio.h b/arch/mips/include/asm/arch-vrx200/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..7fd87375a4a73e6dcc63e896141214a72db79c79
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gpio.h
@@ -0,0 +1,13 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __VRX200_GPIO_H__
+#define __VRX200_GPIO_H__
+
+#include <asm/lantiq/gpio.h>
+
+#endif /* __VRX200_GPIO_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/soc.h b/arch/mips/include/asm/arch-vrx200/soc.h
new file mode 100644
index 0000000000000000000000000000000000000000..7b8979a7e246f7af2fe6fe13d2dc40e6b730712f
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/soc.h
@@ -0,0 +1,45 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __VRX200_SOC_H__
+#define __VRX200_SOC_H__
+
+#define LTQ_ASC0_BASE			0x1E100400
+#define LTQ_SPI_BASE			0x1E100800
+#define LTQ_GPIO_BASE			0x1E100B00
+#define LTQ_ASC1_BASE			0x1E100C00
+#define LTQ_DMA_BASE			0x1E104100
+
+#define LTQ_EBU_BASE			0x1E105300
+#define LTQ_EBU_REGION0_BASE		0x10000000
+#define LTQ_EBU_REGION0_SIZE		(64 * 1024 * 1024)
+#define LTQ_EBU_REGION1_BASE		0x14000000
+#define LTQ_EBU_REGION1_SIZE		(32 * 1024 * 1024)
+
+#define LTQ_SWITCH_BASE			0x1E108000
+#define LTQ_SWITCH_CORE_BASE		LTQ_SWITCH_BASE
+#define LTQ_SWITCH_TOP_PDI_BASE		LTQ_SWITCH_CORE_BASE
+#define LTQ_SWITCH_BM_PDI_BASE		(LTQ_SWITCH_CORE_BASE + 4 * 0x40)
+#define LTQ_SWITCH_MAC_PDI_0_BASE	(LTQ_SWITCH_CORE_BASE + 4 * 0x900)
+#define LTQ_SWITCH_MAC_PDI_X_BASE(x)	(LTQ_SWITCH_MAC_PDI_0_BASE + x * 0x30)
+#define LTQ_SWITCH_TOPLEVEL_BASE	(LTQ_SWITCH_BASE + 4 * 0xC40)
+#define LTQ_SWITCH_MDIO_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE)
+#define LTQ_SWITCH_MII_PDI_BASE		(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x36)
+#define LTQ_SWITCH_PMAC_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x82)
+
+#define LTQ_PMU_BASE			0x1F102000
+#define LTQ_CGU_BASE			0x1F103000
+#define LTQ_MPS_BASE			0x1F107000
+#define LTQ_CHIPID_BASE			(LTQ_MPS_BASE + 0x340)
+#define LTQ_RCU_BASE			0x1F203000
+
+#define LTQ_MC_GLOBAL_BASE		0x1F400000
+#define LTQ_MC_DDR_BASE			0x1F401000
+#define LTQ_MC_DDR_CCR_OFFSET(x)	(x * 0x10)
+
+#endif /* __VRX200_SOC_H__ */
diff --git a/arch/mips/include/asm/asm.h b/arch/mips/include/asm/asm.h
index 608cfcfbb3eaad36da1e19f539bb3efa5084cfef..4e3bf903d9254853a170574814666cefb829eab8 100644
--- a/arch/mips/include/asm/asm.h
+++ b/arch/mips/include/asm/asm.h
@@ -53,6 +53,7 @@
 		.align	2;                              \
 		.type	symbol, @function;              \
 		.ent	symbol, 0;                      \
+		.section .text.symbol,"x";              \
 symbol:		.frame	sp, 0, ra
 
 /*
@@ -62,7 +63,8 @@ symbol:		.frame	sp, 0, ra
 		.globl	symbol;                         \
 		.align	2;                              \
 		.type	symbol, @function;              \
-		.ent	symbol, 0;                       \
+		.ent	symbol, 0;                      \
+		.section .text.symbol,"x";              \
 symbol:		.frame	sp, framesize, rpc
 
 /*
diff --git a/arch/mips/include/asm/gpio.h b/arch/mips/include/asm/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..04a98ad9291293ff76df67d3e4c5c79abd85861e
--- /dev/null
+++ b/arch/mips/include/asm/gpio.h
@@ -0,0 +1,13 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __ASM_MIPS_GPIO_H__
+#define __ASM_MIPS_GPIO_H__
+
+#include <asm/arch/gpio.h>
+
+#endif /* __ASM_MIPS_GPIO_H__ */
diff --git a/arch/mips/include/asm/lantiq/chipid.h b/arch/mips/include/asm/lantiq/chipid.h
new file mode 100644
index 0000000000000000000000000000000000000000..e602e8c1eadc52f46fbc2d3e87553be87d8b7743
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/chipid.h
@@ -0,0 +1,74 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_CHIPID_H__
+#define __LANTIQ_CHIPID_H__
+
+enum ltq_chip_partnum {
+	LTQ_SOC_UNKNOWN = 0,
+	LTQ_SOC_VRX288_2 = 0x000B,	/* VRX288 v1.2 */
+	LTQ_SOC_VRX268_2 = 0x000C,	/* VRX268 v1.2 */
+	LTQ_SOC_GRX288_2 = 0x000D,	/* GRX288 v1.2 */
+	LTQ_SOC_DANUBE = 0x0129,
+	LTQ_SOC_DANUBE_S = 0x012B,
+	LTQ_SOC_TWINPASS = 0x012D,
+	LTQ_SOC_VRX288 = 0x01C0,	/* VRX288 v1.1 */
+	LTQ_SOC_VRX268 = 0x01C2,	/* VRX268 v1.1 */
+	LTQ_SOC_GRX288 = 0x01C9,	/* GRX288 v1.1 */
+};
+
+extern unsigned int ltq_chip_version_get(void);
+extern unsigned int ltq_chip_partnum_get(void);
+extern const char *ltq_chip_partnum_str(void);
+
+extern void ltq_chip_print_info(void);
+
+#ifdef CONFIG_SOC_XWAY_DANUBE
+static inline int ltq_soc_is_danube(void)
+{
+	return 1;
+}
+#else
+static inline int ltq_soc_is_danube(void)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SOC_XWAY_VRX200
+static inline int ltq_soc_is_vrx200(void)
+{
+	return 1;
+}
+
+static inline int ltq_soc_is_vrx200_v1(void)
+{
+	return ltq_chip_version_get() == 1;
+}
+
+static inline int ltq_soc_is_vrx200_v2(void)
+{
+	return ltq_chip_version_get() == 2;
+}
+#else
+static inline int ltq_soc_is_vrx200(void)
+{
+	return 0;
+}
+
+static inline int ltq_soc_is_vrx200_v1(void)
+{
+	return 0;
+}
+
+static inline int ltq_soc_is_vrx200_v2(void)
+{
+	return 0;
+}
+#endif
+
+#endif /* __LANTIQ_CHIPID_H__ */
diff --git a/arch/mips/include/asm/lantiq/clk.h b/arch/mips/include/asm/lantiq/clk.h
new file mode 100644
index 0000000000000000000000000000000000000000..6d7910e59e06d57bd04b96a857fcf0284c01084c
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/clk.h
@@ -0,0 +1,33 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * Based on Lantiq port in Linux kernel
+ */
+
+#ifndef __LANTIQ_CLK_H__
+#define __LANTIQ_CLK_H__
+
+/* Symbolic clock speeds */
+enum ltq_clk {
+	CLOCK_83_MHZ = 83333333,
+	CLOCK_111_MHZ = 111111111,
+	CLOCK_125_MHZ = 125000000,
+	CLOCK_133_MHZ = 133333333,
+	CLOCK_166_MHZ = 166666667,
+	CLOCK_197_MHZ = 197000000,
+	CLOCK_333_MHZ = 333333333,
+	CLOCK_393_MHZ = 393219000,
+	CLOCK_500_MHZ = 500000000,
+	CLOCK_600_MHZ = 600000000,
+	CLOCK_1000_MHZ = 1000000000,
+};
+
+extern unsigned long ltq_get_cpu_clock(void);
+extern unsigned long ltq_get_bus_clock(void);
+extern unsigned long ltq_get_io_region_clock(void);
+
+#endif /* __LANTIQ_CLK_H__ */
diff --git a/arch/mips/include/asm/lantiq/config.h b/arch/mips/include/asm/lantiq/config.h
new file mode 100644
index 0000000000000000000000000000000000000000..686e5d3680b5e830c265e38bfe6cabdab75e2dba
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/config.h
@@ -0,0 +1,106 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_CONFIG_H__
+#define __LANTIQ_CONFIG_H__
+
+/* Memory usage */
+#define CONFIG_SYS_MAXARGS		24
+#define CONFIG_SYS_MALLOC_LEN		1024*1024
+#define CONFIG_SYS_BOOTPARAMS_LEN	128*1024
+
+/* Command line */
+#define CONFIG_SYS_PROMPT		CONFIG_IDENT_STRING " # "
+#define CONFIG_SYS_CBSIZE		512
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT)+16)
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+
+/*
+ * Enable advanced console features on demand to reduce
+ * flash and RAM footprint
+ */
+#ifdef CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#endif
+
+/* Basic commands */
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_EDITENV
+#define CONFIG_CMD_IMI
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_LOADS
+
+/* Other U-Boot settings */
+#define CONFIG_UBOOT_VERSION
+#define CONFIG_TIMESTAMP
+
+/* Default environment */
+#define CONFIG_ENV_CONSOLEDEV					\
+	"consoledev=" CONFIG_CONSOLE_DEV "\0"
+
+#define CONFIG_ENV_ADDCONSOLE					\
+	"addconsole=setenv bootargs $bootargs"			\
+	" console=$consoledev,$baudrate\0"
+
+#if defined(CONFIG_NET_DEV)
+#define CONFIG_ENV_NETDEV					\
+	"netdev=" CONFIG_NET_DEV "\0"
+#else
+#define CONFIG_ENV_NETDEV					\
+	"netdev=eth0\0"
+#endif
+
+#define CONFIG_ENV_ADDIP					\
+	"addip=setenv bootargs $bootargs"			\
+	" ip=$ipaddr:$serverip::::$netdev:off\0"
+
+#define CONFIG_ENV_ADDETH					\
+	"addeth=setenv bootargs $bootargs"			\
+	" ethaddr=$ethaddr\0"
+
+#define CONFIG_ENV_ADDMACHTYPE					\
+	"addmachtype=setenv bootargs $bootargs"			\
+	" machtype=" CONFIG_MACH_TYPE "\0"
+
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define CONFIG_ENV_UPDATE_UBOOT_NOR					\
+	"update-uboot-nor=tftpboot u-boot.bin && "				\
+	"protect off " MK_STR(CONFIG_SYS_FLASH_BASE) " +$filesize && "	\
+	"erase " MK_STR(CONFIG_SYS_FLASH_BASE) " +$filesize && "	\
+	"cp.b $fileaddr " MK_STR(CONFIG_SYS_FLASH_BASE) " $filesize\0"
+#else
+#define CONFIG_ENV_UPDATE_UBOOT_NOR
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_ENV_SF_PROBE					\
+	"sf-probe=sf probe " MK_STR(CONFIG_ENV_SPI_CS) " "	\
+	MK_STR(CONFIG_ENV_SPI_MAX_HZ) " "			\
+	MK_STR(CONFIG_ENV_SPI_MODE) " \0"
+#else
+#define CONFIG_ENV_SF_PROBE
+#endif
+
+#define CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_CONSOLEDEV		\
+	CONFIG_ENV_ADDCONSOLE		\
+	CONFIG_ENV_NETDEV		\
+	CONFIG_ENV_ADDIP		\
+	CONFIG_ENV_ADDETH		\
+	CONFIG_ENV_ADDMACHTYPE		\
+	CONFIG_ENV_UPDATE_UBOOT_NOR	\
+	CONFIG_ENV_SF_PROBE
+
+#endif /* __LANTIQ_CONFIG_H__ */
diff --git a/arch/mips/include/asm/lantiq/dma.h b/arch/mips/include/asm/lantiq/dma.h
new file mode 100644
index 0000000000000000000000000000000000000000..a962c5b378ac6cc14413cecdcc651d726fa5ef17
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/dma.h
@@ -0,0 +1,96 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_DMA_H__
+#define __LANTIQ_DMA_H__
+
+enum ltq_dma_endianess {
+	LTQ_DMA_ENDIANESS_B0_B1_B2_B3,	/* No byte swapping */
+	LTQ_DMA_ENDIANESS_B1_B0_B3_B2,	/* B0B1B2B3 => B1B0B3B2 */
+	LTQ_DMA_ENDIANESS_B2_B3_B0_B1,	/* B0B1B2B3 => B2B3B0B1 */
+	LTQ_DMA_ENDIANESS_B3_B2_B1_B0,	/* B0B1B2B3 => B3B2B1B0 */
+};
+
+struct ltq_dma_channel {
+	u8 chan_no;		/* Channel number */
+	u8 class;		/* Priority class */
+	u16 num_desc;		/* Number of required DMA descriptors */
+	size_t mem_size;	/* Size of allocated memory */
+	void *desc_base;	/* Aligned and segment mapped descriptor base */
+	void *mem_base;		/* Base of allocated memory */
+};
+
+struct ltq_dma_device {
+	struct list_head list;
+	enum ltq_dma_endianess rx_endian_swap;
+	enum ltq_dma_endianess tx_endian_swap;
+	struct ltq_dma_channel rx_chan;
+	struct ltq_dma_channel tx_chan;
+	void *priv;
+	u8 port;
+};
+
+/**
+ * Initialize DMA hardware and driver
+ */
+extern void ltq_dma_init(void);
+
+/**
+ * Allocate a new DMA client context
+ */
+extern struct ltq_dma_device *ltq_dma_alloc(void);
+
+/**
+ * Register given DMA client context
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+extern int ltq_dma_register(struct ltq_dma_device *dev);
+
+/**
+ * Reset and halt all channels related to given DMA client
+ */
+extern void ltq_dma_reset(struct ltq_dma_device *dev);
+
+/**
+ * Map RX DMA descriptor to memory region
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+extern int ltq_dma_map_rx(struct ltq_dma_device *dev, int index,
+				void *data, int len);
+
+/**
+ * Start RX transfer
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+extern int ltq_dma_read(struct ltq_dma_device *dev, int index);
+
+/**
+ * Check if new data is available.
+ *
+ * @returns length of received data, 0 otherwise
+ */
+extern int ltq_dma_read_poll(struct ltq_dma_device *dev, int index);
+
+/**
+ * Map TX DMA descriptor to memory region
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+extern int ltq_dma_map_tx(struct ltq_dma_device *dev, int index,
+			   void *data, int len);
+
+/**
+ * Start TX transfer
+ *
+ * @returns 0 on success, negative value otherwise
+ */
+extern int ltq_dma_write(struct ltq_dma_device *dev, int index);
+
+#endif /* __LANTIQ_DMA_H__ */
diff --git a/arch/mips/include/asm/lantiq/eth.h b/arch/mips/include/asm/lantiq/eth.h
new file mode 100644
index 0000000000000000000000000000000000000000..d1769735928368ee962b17c415c698fe99186e02
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/eth.h
@@ -0,0 +1,34 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_ETH_H__
+#define __LANTIQ_ETH_H__
+
+#include <phy.h>
+
+enum LTQ_ETH_PORT_FLAGS {
+	LTQ_ETH_PORT_NONE	= 0,
+	LTQ_ETH_PORT_PHY	= 1,
+	LTQ_ETH_PORT_SWITCH	= (1 << 1),
+	LTQ_ETH_PORT_MAC	= (1 << 2),
+};
+
+struct ltq_eth_port_config {
+	u8 num;
+	u8 phy_addr;
+	u16 flags;
+	phy_interface_t phy_if;
+};
+
+struct ltq_eth_board_config {
+	const struct ltq_eth_port_config *ports;
+	int num_ports;
+};
+
+extern int ltq_eth_initialize(const struct ltq_eth_board_config *board_config);
+
+#endif /* __LANTIQ_ETH_H__ */
diff --git a/arch/mips/include/asm/lantiq/gpio.h b/arch/mips/include/asm/lantiq/gpio.h
new file mode 100644
index 0000000000000000000000000000000000000000..87e4fad7c64b69af0c76f4d2211f1e034ca1d54d
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_GPIO_H__
+#define __LANTIQ_GPIO_H__
+
+enum ltq_gpio_dir {
+	GPIO_DIR_IN = 0,
+	GPIO_DIR_OUT
+};
+
+enum ltq_gpio_od {
+	GPIO_OD_ACTIVE = 0,
+	GPIO_OD_NORMAL
+};
+
+enum ltq_gpio_altsel {
+	GPIO_ALTSEL_CLR = 0,
+	GPIO_ALTSEL_SET
+};
+
+extern int gpio_set_altfunc(int gpio, int altsel0, int altsel1, int dir);
+extern int gpio_set_opendrain(int gpio, int od);
+
+static inline int gpio_to_port(int gpio)
+{
+	return gpio >> 4;
+}
+
+static inline int gpio_to_pin(int gpio)
+{
+	return gpio & 0xF;
+}
+
+static inline int gpio_to_gpio(int port, int pin)
+{
+	return (port << 4) | (pin & 0xF);
+}
+
+static inline int gpio_request(int gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(int gpio)
+{
+}
+
+#include <asm-generic/gpio.h>
+
+#endif /* __LANTIQ_GPIO_H__ */
diff --git a/arch/mips/include/asm/lantiq/io.h b/arch/mips/include/asm/lantiq/io.h
new file mode 100644
index 0000000000000000000000000000000000000000..4a08ad20f3945ec5d0aca284807c2848a96681d7
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/io.h
@@ -0,0 +1,38 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_IO_H__
+#define __LANTIQ_IO_H__
+
+#include <asm/io.h>
+
+#define ltq_readb(a)		__raw_readb(a)
+#define ltq_writeb(a, v)	__raw_writeb(v, a)
+
+#define ltq_readl(a)		__raw_readl(a)
+#define ltq_writel(a, v)	__raw_writel(v, a)
+
+#define ltq_clrbits(a, clear) \
+	ltq_writel(a, ltq_readl(a) & ~(clear))
+
+#define ltq_setbits(a, set) \
+	ltq_writel(a, ltq_readl(a) | (set))
+
+#define ltq_clrsetbits(a, clear, set) \
+	ltq_writel(a, (ltq_readl(a) & ~(clear)) | (set))
+
+static inline void ltq_reg_dump(const void *addr, const char *desc)
+{
+	u32 data;
+
+	data = ltq_readl(addr);
+	printf("ltq_reg_dump: %s 0x%p = 0x%08x\n",
+		desc, addr, data);
+}
+
+#endif /* __LANTIQ_IO_H__ */
diff --git a/arch/mips/include/asm/lantiq/pm.h b/arch/mips/include/asm/lantiq/pm.h
new file mode 100644
index 0000000000000000000000000000000000000000..e17fc62c6194ec18ca4df71129b46e7c03103b28
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/pm.h
@@ -0,0 +1,22 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_PM_H__
+#define __LANTIQ_PM_H__
+
+enum ltq_pm_modules {
+	LTQ_PM_CORE,
+	LTQ_PM_DMA,
+	LTQ_PM_ETH,
+	LTQ_PM_SPI,
+};
+
+extern u32 ltq_pm_map(enum ltq_pm_modules module);
+extern int ltq_pm_enable(enum ltq_pm_modules module);
+extern int ltq_pm_disable(enum ltq_pm_modules module);
+
+#endif /* __LANTIQ_PM_H__ */
diff --git a/arch/mips/include/asm/lantiq/reset.h b/arch/mips/include/asm/lantiq/reset.h
new file mode 100644
index 0000000000000000000000000000000000000000..b9bad5434a63eb1f67eeaf488a646eb8956dfb98
--- /dev/null
+++ b/arch/mips/include/asm/lantiq/reset.h
@@ -0,0 +1,38 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __LANTIQ_RESET_H__
+#define __LANTIQ_RESET_H__
+
+enum ltq_reset_modules {
+	LTQ_RESET_CORE,
+	LTQ_RESET_DMA,
+	LTQ_RESET_ETH,
+	LTQ_RESET_PHY,
+	LTQ_RESET_HARD,
+	LTQ_RESET_SOFT,
+};
+
+extern u32 ltq_reset_map(enum ltq_reset_modules module);
+extern int ltq_reset_activate(enum ltq_reset_modules module);
+extern int ltq_reset_deactivate(enum ltq_reset_modules module);
+
+static inline int ltq_reset_once(enum ltq_reset_modules module, ulong usec)
+{
+	int ret;
+
+	ret = ltq_reset_activate(module);
+	if (ret)
+		return ret;
+
+	__udelay(usec);
+	ret = ltq_reset_deactivate(module);
+
+	return ret;
+}
+
+#endif /* __LANTIQ_RESET_H__ */
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index be7e5c65ec1f38e91435844192af5a9637c2b337..07a3cf6051f15c5fbfd73cb2df16d0eac5b1b9c4 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -89,6 +89,20 @@
 #define CP0_DWATCH $19
 
 /*
+ * Additional Coprocessor 0 register names.
+ * These registers are listed for completeness and are intended
+ * for usage in assembly code.
+ */
+#define CP0_EBASE	$15,1
+/* L1 I-Cache */
+#define CP0_ITAGLO	$28
+#define CP0_IDATALO	$28,1
+#define CP0_IDATAHI	$29,1
+/* L1 D-Cache */
+#define CP0_DTAGLO	$28,2
+#define CP0_DDATALO	$28,3
+
+/*
  * Coprocessor 0 Set 1 register names
  */
 #define CP0_S1_DERRADDR0  $26
@@ -395,6 +409,12 @@
 #define  CAUSEF_BD		(_ULCAST_(1)   << 31)
 
 /*
+ * Bits in the coprocessor 0 EBase register.
+ */
+#define EBASEB_CPUNUM		0
+#define EBASEF_CPUNUM		(_ULCAST_(1023))
+
+/*
  * Bits in the coprocessor 0 config register.
  */
 /* Generic bits.  */
diff --git a/arch/mips/include/asm/u-boot-mips.h b/arch/mips/include/asm/u-boot-mips.h
new file mode 100644
index 0000000000000000000000000000000000000000..d54262adae837b5be36deec4e4887f8bba5ee160
--- /dev/null
+++ b/arch/mips/include/asm/u-boot-mips.h
@@ -0,0 +1,12 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2003 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+ */
+
+extern ulong uboot_end_data;
+extern ulong uboot_end;
+
+extern int incaip_set_cpuclk(void);
+extern int arch_cpu_init(void);
diff --git a/arch/mips/lib/Makefile b/arch/mips/lib/Makefile
index 9244f3151a76fa243e672f6b15be7809b45e8172..fc2bb9049db03da0c26c8f9674ec586e4c9bb385 100644
--- a/arch/mips/lib/Makefile
+++ b/arch/mips/lib/Makefile
@@ -34,6 +34,10 @@ else
 COBJS-y	+= bootm.o
 endif
 
+ifdef CONFIG_SOC_LANTIQ
+COBJS-$(CONFIG_SPL_BUILD) += spl_lantiq.o
+endif
+
 SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
 
diff --git a/arch/mips/lib/board.c b/arch/mips/lib/board.c
index d998f0e74904416bcc7890c747b9990698bbb2e3..6d24eeef07130fed421d7a47394b454fcb48948d 100644
--- a/arch/mips/lib/board.c
+++ b/arch/mips/lib/board.c
@@ -31,6 +31,8 @@
 #include <nand.h>
 #include <onenand_uboot.h>
 #include <spi.h>
+#include <spi_flash.h>
+#include <sas/init.h>
 
 #ifdef CONFIG_BITBANGMII
 #include <miiphy.h>
@@ -38,23 +40,24 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-extern int timer_init(void);
-
-extern int incaip_set_cpuclk(void);
-
-extern ulong uboot_end_data;
-extern ulong uboot_end;
-
 ulong monitor_flash_len;
 
-static char *failed = "*** failed ***\n";
-
 /*
  * mips_io_port_base is the begin of the address space to which x86 style
  * I/O ports are mapped.
  */
 unsigned long mips_io_port_base = -1;
 
+int __arch_cpu_init(void)
+{
+	/*
+	 * Nothing to do in this dummy implementation
+	 */
+	return 0;
+}
+int arch_cpu_init(void)
+	__attribute__((weak, alias("__arch_cpu_init")));
+
 int __board_early_init_f(void)
 {
 	/*
@@ -79,7 +82,7 @@ static int init_func_ram(void)
 		print_size(gd->ram_size, "\n");
 		return 0;
 	}
-	puts(failed);
+	puts("failed\n");
 	return 1;
 }
 
@@ -128,6 +131,7 @@ static int init_baudrate(void)
 typedef int (init_fnc_t)(void);
 
 init_fnc_t *init_sequence[] = {
+	arch_cpu_init,
 	board_early_init_f,
 	timer_init,
 	env_init,		/* initialize environment */
@@ -140,6 +144,7 @@ init_fnc_t *init_sequence[] = {
 	display_banner,		/* say that we are here */
 	checkboard,
 	init_func_ram,
+	sas_init_f,
 	NULL,
 };
 
@@ -294,15 +299,19 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	/* configure available FLASH banks */
 	size = flash_init();
 	display_flash_config(size);
+	bd->bi_flashstart = CONFIG_SYS_FLASH_BASE;
 	bd->bi_flashsize = size;
-#endif
 
-	bd->bi_flashstart = CONFIG_SYS_FLASH_BASE;
 #if CONFIG_SYS_MONITOR_BASE == CONFIG_SYS_FLASH_BASE
 	bd->bi_flashoffset = monitor_flash_len;	/* reserved area for U-Boot */
 #else
 	bd->bi_flashoffset = 0;
 #endif
+#else
+	bd->bi_flashstart = 0;
+	bd->bi_flashsize = 0;
+	bd->bi_flashoffset = 0;
+#endif
 
 #ifdef CONFIG_CMD_NAND
 	puts("NAND:  ");
@@ -313,6 +322,14 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	onenand_init();
 #endif
 
+#ifdef CONFIG_CMD_SPI
+	puts("SPI:   ");
+	spi_init();		/* go init the SPI */
+	puts("ready\n");
+#endif
+
+	spi_flash_init();	/* go init the SPI flash MTD */
+
 	/* relocate environment function pointers etc. */
 	env_relocate();
 
@@ -347,12 +364,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
-#ifdef CONFIG_CMD_SPI
-	puts("SPI:   ");
-	spi_init();		/* go init the SPI */
-	puts("ready\n");
-#endif
-
 #if defined(CONFIG_MISC_INIT_R)
 	/* miscellaneous platform dependent initialisations */
 	misc_init_r();
@@ -366,6 +377,8 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	eth_initialize(gd->bd);
 #endif
 
+	sas_init_r();
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;)
 		main_loop();
diff --git a/arch/mips/lib/spl_lantiq.c b/arch/mips/lib/spl_lantiq.c
new file mode 100644
index 0000000000000000000000000000000000000000..ec5aea4bb8bda50b6d3d6e8dad62d6d36f7a3ee0
--- /dev/null
+++ b/arch/mips/lib/spl_lantiq.c
@@ -0,0 +1,287 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <image.h>
+#include <spi_flash.h>
+#include <linux/compiler.h>
+#include <lzma/LzmaDec.h>
+#include <linux/lzo.h>
+
+#ifdef CONFIG_LTQ_SPL_DEBUG
+#define spl_has_console		1
+#else
+#define spl_has_console		0
+#endif
+
+#define spl_debug(fmt, args...)	\
+	debug_cond(spl_has_console, fmt, ##args)
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH) && defined(CONFIG_SYS_BOOT_SFSPL)
+#define spl_boot_spi_flash	1
+#else
+#define spl_boot_spi_flash	0
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_SPL_NOR_FLASH) && defined(CONFIG_SYS_BOOT_NORSPL)
+#define spl_boot_nor_flash	1
+#else
+#define spl_boot_nor_flash	0
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZMA)
+#define spl_has_lzma		1
+#else
+#define spl_has_lzma		0
+#endif
+
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+#define spl_has_lzo		1
+#else
+#define spl_has_lzo		0
+#endif
+
+struct spl_image {
+	ulong data_addr;
+	ulong load_addr;
+	ulong entry_addr;
+	size_t size;
+	u8 comp;
+};
+
+extern ulong __image_copy_end;
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static gd_t gd_data __maybe_unused;
+
+/* Emulated malloc area needed for LZMA allocator */
+static u8 *spl_mem_ptr __maybe_unused;
+static size_t spl_mem_size __maybe_unused;
+
+static void spl_console_init(void)
+{
+	if (!spl_has_console)
+		return;
+
+	gd = &gd_data;
+	barrier();
+
+	gd->baudrate = CONFIG_BAUDRATE;
+	serial_init();
+	console_init_f();
+}
+
+static int spl_parse_image(const image_header_t *hdr, struct spl_image *spl)
+{
+	u32 magic;
+
+	magic = image_get_magic(hdr);
+	if (magic != IH_MAGIC)
+		return -1;
+
+	spl->data_addr += image_get_header_size();
+	spl->entry_addr = image_get_load(hdr);
+	spl->size = image_get_data_size(hdr);
+	spl->comp = image_get_comp(hdr);
+
+	if (spl->comp == IH_COMP_NONE)
+		spl->load_addr = spl->entry_addr;
+	else
+		spl->load_addr = CONFIG_LOADADDR;
+
+	return 0;
+}
+
+static int spl_load_spi_flash(struct spl_image *spl)
+{
+	struct spi_flash sf;
+	image_header_t hdr;
+	int ret;
+
+	/*
+	 * Image format:
+	 *
+	 * - 12 byte non-volatile bootstrap header
+	 * - SPL binary
+	 * - 12 byte non-volatile bootstrap header
+	 * - 64 byte U-Boot mkimage header
+	 * - U-Boot binary
+	 */
+	spl->data_addr = (ulong) &__image_copy_end - CONFIG_SPL_TEXT_BASE + 24;
+
+	spl_debug("SPL: probing SPI flash\n");
+	spi_init();
+	ret = spi_flash_probe_spl(&sf, CONFIG_SPL_SPI_BUS, CONFIG_SPL_SPI_CS,
+				CONFIG_SPL_SPI_MAX_HZ, CONFIG_SPL_SPI_MODE);
+	if (ret)
+		return ret;
+
+	spl_debug("SPL: checking image header at offset %lx\n", spl->data_addr);
+	ret = spi_flash_read(&sf, spl->data_addr, sizeof(hdr), &hdr);
+	if (ret)
+		return ret;
+
+	ret = spl_parse_image(&hdr, spl);
+	if (ret)
+		return ret;
+
+	spl_debug("SPL: loading U-Boot to RAM at %08lx\n", spl->load_addr);
+	ret = spi_flash_read(&sf, spl->data_addr, spl->size,
+				(void *) spl->load_addr);
+
+	return ret;
+}
+
+static int spl_load_nor_flash(struct spl_image *spl)
+{
+	const image_header_t *hdr;
+	int ret;
+
+	/*
+	 * Image format:
+	 *
+	 * - SPL binary
+	 * - 64 byte U-Boot mkimage header
+	 * - U-Boot binary
+	 */
+	spl->data_addr = (ulong) &__image_copy_end;
+
+	hdr = (const image_header_t *) &__image_copy_end;
+	spl_debug("SPL: checking image header at address %p\n", hdr);
+	ret = spl_parse_image(hdr, spl);
+	if (ret)
+		return ret;
+
+	spl_debug("SPL: loading U-Boot to RAM at %08lx\n", spl->load_addr);
+	memcpy((void *) spl->load_addr, (const void *) spl->data_addr,
+		spl->size);
+
+	return 0;
+}
+
+static int spl_load(struct spl_image *spl)
+{
+	int ret;
+
+	if (spl_boot_spi_flash)
+		ret = spl_load_spi_flash(spl);
+	else if (spl_boot_nor_flash)
+		ret = spl_load_nor_flash(spl);
+	else
+		ret = -1;
+
+	return ret;
+}
+
+static void *spl_lzma_alloc(void *p, size_t size)
+{
+	u8 *ret;
+
+	if (size > spl_mem_size)
+		return NULL;
+
+	ret = spl_mem_ptr;
+	spl_mem_ptr += size;
+	spl_mem_size -= size;
+
+	return ret;
+}
+
+static void spl_lzma_free(void *p, void *addr)
+{
+}
+
+static int spl_uncompress_lzma(const struct spl_image *spl)
+{
+	SRes res;
+	const Byte *prop = (const Byte *) spl->load_addr;
+	const Byte *src = (const Byte *) spl->load_addr + LZMA_PROPS_SIZE +
+							sizeof(uint64_t);
+	Byte *dest = (Byte *) spl->entry_addr;
+	SizeT dest_len = 0xFFFFFFFF;
+	SizeT src_len = spl->size - LZMA_PROPS_SIZE;
+	ELzmaStatus status = 0;
+	ISzAlloc alloc;
+
+	alloc.Alloc = spl_lzma_alloc;
+	alloc.Free = spl_lzma_free;
+	spl_mem_ptr = (u8 *) CONFIG_SPL_MALLOC_BASE;
+	spl_mem_size = CONFIG_SPL_MALLOC_SIZE;
+
+	res = LzmaDecode(dest, &dest_len, src, &src_len, prop, LZMA_PROPS_SIZE,
+				LZMA_FINISH_ANY, &status, &alloc);
+	if (res != SZ_OK)
+		return -1;
+
+	return 0;
+}
+
+static int spl_uncompress_lzo(const struct spl_image *spl)
+{
+	size_t len;
+
+	return lzop_decompress(
+			(const unsigned char*) spl->load_addr, spl->size,
+			(unsigned char *) spl->entry_addr, &len);
+}
+
+static int spl_uncompress(const struct spl_image *spl)
+{
+	int ret;
+
+	if (spl->comp == IH_COMP_NONE)
+		return 0;
+
+	spl_debug("SPL: uncompressing U-Boot at %08lx to %08lx\n",
+			spl->load_addr, spl->entry_addr);
+
+	if (spl->comp == IH_COMP_LZMA && spl_has_lzma)
+		ret = spl_uncompress_lzma(spl);
+	else if (spl->comp == IH_COMP_LZO && spl_has_lzo)
+		ret = spl_uncompress_lzo(spl);
+	else {
+		spl_debug("SPL: compression type %u not supported\n",
+				spl->comp);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+void __noreturn spl_lantiq_init(void)
+{
+	void (*uboot)(void) __noreturn;
+	struct spl_image spl;
+	int ret;
+
+	spl_console_init();
+
+	spl_debug("SPL: initializing\n");
+
+	board_early_init_f();
+	timer_init();
+
+	ret = spl_load(&spl);
+	if (ret)
+		goto hang;
+
+	ret = spl_uncompress(&spl);
+	if (ret)
+		goto hang;
+
+	spl_debug("SPL: starting U-Boot\n\n\n\n\n\n");
+
+	uboot = (void *) spl.entry_addr;
+	uboot();
+
+hang:
+	spl_debug("SPL: cannot start U-Boot\n");
+
+	for (;;)
+		;
+}
diff --git a/board/avm/fb3370/Makefile b/board/avm/fb3370/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..321154f8cfb9b732fe5498515f3903fd9439c70a
--- /dev/null
+++ b/board/avm/fb3370/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/avm/fb3370/config.mk b/board/avm/fb3370/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/avm/fb3370/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/avm/fb3370/ddr_settings.h b/board/avm/fb3370/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..4aa301ad73575f33e3da49543df74b568ca13562
--- /dev/null
+++ b/board/avm/fb3370/ddr_settings.h
@@ -0,0 +1,70 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x100
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x0
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000401
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401B04
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1D445D
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x141F04
+#define	MC_CCR40_VALUE	0x142704
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7800301
+#define	MC_CCR58_VALUE	0x7800301
+#define	MC_CCR59_VALUE	0x7800301
+#define	MC_CCR60_VALUE	0x7800301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/avm/fb3370/fb3370.c b/board/avm/fb3370/fb3370.c
new file mode 100644
index 0000000000000000000000000000000000000000..42e157984869ccab85c483e3e8194dc0172d232d
--- /dev/null
+++ b/board/avm/fb3370/fb3370.c
@@ -0,0 +1,102 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/gphy.h>
+
+static void gpio_init(void)
+{
+	/* SPI/CS output (low-active) for serial flash */
+	gpio_direction_output(10, 1);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: external Lantiq PEF7071 10/100/1000 PHY for LAN port 0 */
+	{ 0, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC1: external Lantiq PEF7071 10/100/1000 PHY for LAN port 1 */
+	{ 1, 0x1, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 2 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 3 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: WLAN? */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_addr = 0x80FF0000;
+
+	ltq_gphy_phy11g_a1x_load(fw_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_addr);
+	ltq_rcu_gphy_boot(1, fw_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/board/gigaset/sx76x/Makefile b/board/gigaset/sx76x/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..321154f8cfb9b732fe5498515f3903fd9439c70a
--- /dev/null
+++ b/board/gigaset/sx76x/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/gigaset/sx76x/config.mk b/board/gigaset/sx76x/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/gigaset/sx76x/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/gigaset/sx76x/ddr_settings.h b/board/gigaset/sx76x/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..fc587afef109aea86562555b3f78198ea836a75c
--- /dev/null
+++ b/board/gigaset/sx76x/ddr_settings.h
@@ -0,0 +1,56 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * generated with lantiq_ram_extract_magic.awk
+ *
+ * Copyright (C) 2011 Luka Perkov <uboot@lukaperkov.net>
+ */
+
+#define MC_DC00_VALUE	0x1B1B
+#define MC_DC01_VALUE	0x0
+#define MC_DC02_VALUE	0x0
+#define MC_DC03_VALUE	0x0
+#define MC_DC04_VALUE	0x0
+#define MC_DC05_VALUE	0x200
+#define MC_DC06_VALUE	0x605
+#define MC_DC07_VALUE	0x303
+#define MC_DC08_VALUE	0x202
+#define MC_DC09_VALUE	0x70A
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xC02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xF3E
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xD
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04
+#define MC_DC21_VALUE	0xF00
+#define MC_DC22_VALUE	0xF0F
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x63
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x100
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x514
+#define MC_DC29_VALUE	0x2D89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x2002
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+#define MC_DC46_VALUE	0x0
diff --git a/board/gigaset/sx76x/sx76x.c b/board/gigaset/sx76x/sx76x.c
new file mode 100644
index 0000000000000000000000000000000000000000..554eee9d4e0f23d05c8096e3a5101a7ac028fa59
--- /dev/null
+++ b/board/gigaset/sx76x/sx76x.c
@@ -0,0 +1,66 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Luka Perkov <uboot@lukaperkov.net>
+ */
+
+#include <common.h>
+#include <switch.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/chipid.h>
+
+static void gpio_init(void)
+{
+	/* Activate reset line of ADM6996I switch */
+	gpio_direction_output(19, 0);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* MAC0: Lantiq ADM6996I switch */
+	{ 0, 0x0, LTQ_ETH_PORT_SWITCH, PHY_INTERFACE_MODE_RMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t *bis)
+{
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+static struct switch_device adm6996i_dev = {
+	.name = "adm6996i",
+	.cpu_port = 5,
+	.port_mask = 0xF,
+};
+
+int board_switch_init(void)
+{
+	/* Deactivate reset line of ADM6996I switch */
+	gpio_set_value(19, 1);
+
+	/* ADM6996I needs some time to come out of reset */
+	__udelay(50000);
+
+	return switch_device_register(&adm6996i_dev);
+}
diff --git a/board/lantiq/easy50712/Makefile b/board/lantiq/easy50712/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..321154f8cfb9b732fe5498515f3903fd9439c70a
--- /dev/null
+++ b/board/lantiq/easy50712/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/lantiq/easy50712/config.mk b/board/lantiq/easy50712/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/lantiq/easy50712/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/lantiq/easy50712/ddr_settings.h b/board/lantiq/easy50712/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..e06522674c1a635eff46ca527114051c5140b3bb
--- /dev/null
+++ b/board/lantiq/easy50712/ddr_settings.h
@@ -0,0 +1,54 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define MC_DC00_VALUE	0x1B1B
+#define MC_DC01_VALUE	0x0
+#define MC_DC02_VALUE	0x0
+#define MC_DC04_VALUE	0x0
+#define MC_DC05_VALUE	0x200
+#define MC_DC06_VALUE	0x605
+#define MC_DC07_VALUE	0x303
+#define MC_DC08_VALUE	0x102
+#define MC_DC09_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0x13c
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA04
+#define MC_DC21_VALUE	0xd00
+#define MC_DC22_VALUE	0xd0d
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+#define MC_DC46_VALUE	0x0
diff --git a/board/lantiq/easy50712/easy50712.c b/board/lantiq/easy50712/easy50712.c
new file mode 100644
index 0000000000000000000000000000000000000000..7ecf4265323d3ef39efc8ca98177f45e72f7b5cb
--- /dev/null
+++ b/board/lantiq/easy50712/easy50712.c
@@ -0,0 +1,106 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <switch.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/chipid.h>
+
+static void gpio_init(void)
+{
+	/* SPI/CS output (low-active) for serial flash */
+	gpio_direction_output(22, 1);
+
+	/* enable CLK_OUT2 for external switch */
+	gpio_set_altfunc(3, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* MAC0: Lantiq ADM6996I switch */
+	{ 0, 0x0, LTQ_ETH_PORT_SWITCH, PHY_INTERFACE_MODE_RMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t *bis)
+{
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+static struct switch_device adm6996i_dev = {
+	.name = "adm6996i",
+	.cpu_port = 5,
+	.port_mask = 0xF,
+};
+
+int board_switch_init(void)
+{
+	/* Deactivate HRST line to release reset of ADM6996I switch */
+	ltq_reset_once(LTQ_RESET_HARD, 200000);
+
+	/* ADM6996I needs some time to come out of reset */
+	__udelay(50000);
+
+	return switch_device_register(&adm6996i_dev);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	switch (cs) {
+	case 2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 2:
+		gpio_set_value(22, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 2:
+		gpio_set_value(22, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/board/lantiq/easy80920/Makefile b/board/lantiq/easy80920/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..321154f8cfb9b732fe5498515f3903fd9439c70a
--- /dev/null
+++ b/board/lantiq/easy80920/Makefile
@@ -0,0 +1,29 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/lantiq/easy80920/config.mk b/board/lantiq/easy80920/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/lantiq/easy80920/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/lantiq/easy80920/ddr_settings.h b/board/lantiq/easy80920/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..4aa301ad73575f33e3da49543df74b568ca13562
--- /dev/null
+++ b/board/lantiq/easy80920/ddr_settings.h
@@ -0,0 +1,70 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2007-2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x100
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x0
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000401
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401B04
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1D445D
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x141F04
+#define	MC_CCR40_VALUE	0x142704
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7800301
+#define	MC_CCR58_VALUE	0x7800301
+#define	MC_CCR59_VALUE	0x7800301
+#define	MC_CCR60_VALUE	0x7800301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/lantiq/easy80920/easy80920.c b/board/lantiq/easy80920/easy80920.c
new file mode 100644
index 0000000000000000000000000000000000000000..7b34b02c2bf9c89c1b9a459f37bd287b8fdbcc99
--- /dev/null
+++ b/board/lantiq/easy80920/easy80920.c
@@ -0,0 +1,102 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/gphy.h>
+
+static void gpio_init(void)
+{
+	/* SPI/CS output (low-active) for serial flash */
+	gpio_direction_output(10, 1);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: external Lantiq PEF7071 10/100/1000 PHY for LAN port 0 */
+	{ 0, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC1: external Lantiq PEF7071 10/100/1000 PHY for LAN port 1 */
+	{ 1, 0x1, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 2 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 3 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Lantiq PEF7071 10/100/1000 PHY for WANoE port */
+	{ 5, 0x5, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_addr = 0x80FF0000;
+
+	ltq_gphy_phy11g_a1x_load(fw_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_addr);
+	ltq_rcu_gphy_boot(1, fw_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/board/sphairon/isdn_sip_gw/Makefile b/board/sphairon/isdn_sip_gw/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..df1f52fb76373c2cc91b6d72777798b24122b6b4
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/isdn_sip_gw/config.mk b/board/sphairon/isdn_sip_gw/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/isdn_sip_gw/ddr_settings.h b/board/sphairon/isdn_sip_gw/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..5ec21c03565717be445cd7f1fecd245bfcad1e59
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x100
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x0
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000401
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401B04
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1D445D
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x141F04
+#define	MC_CCR40_VALUE	0x142704
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7800301
+#define	MC_CCR58_VALUE	0x7800301
+#define	MC_CCR59_VALUE	0x7800301
+#define	MC_CCR60_VALUE	0x7800301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/isdn_sip_gw/isdn_sip_gw.c b/board/sphairon/isdn_sip_gw/isdn_sip_gw.c
new file mode 100644
index 0000000000000000000000000000000000000000..91d34eb6d38790d027ee4f9db2a2ff88f4a120f9
--- /dev/null
+++ b/board/sphairon/isdn_sip_gw/isdn_sip_gw.c
@@ -0,0 +1,219 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/gphy.h>
+
+static void gpio_init(void)
+{
+	/* GPIO button WLAN enable (low-active) */
+	gpio_direction_input(45);
+	/* GPIO button board reset (low-active) */
+	gpio_direction_input(46);
+
+	/* SPI CS 0.4 to serial flash */
+	gpio_direction_output(10, 1);
+
+	/* LEDC/LED_ST for LED shift register */
+	gpio_set_altfunc(4, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_D for LED shift register */
+	gpio_set_altfunc(5, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* LEDC/LED_SH for LED shift register */
+	gpio_set_altfunc(6, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* TDM/FSC used as input (FSC slave) */
+	gpio_set_altfunc(0, GPIO_ALTSEL_SET, GPIO_ALTSEL_SET, GPIO_DIR_IN);
+	/* TDM/DO output */
+	gpio_set_altfunc(25, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* TDM/DI input */
+	gpio_set_altfunc(26, GPIO_ALTSEL_CLR, GPIO_ALTSEL_SET, GPIO_DIR_IN);
+	/* TDM/DCL used as input (DCL slave) */
+	gpio_set_altfunc(40, GPIO_ALTSEL_CLR, GPIO_ALTSEL_SET, GPIO_DIR_IN);
+
+	/* Lantiq S-VIP, ISAC-SX */
+	/* Reset line to S-VIP, ISAC-SX */
+	gpio_direction_output(31, 1);
+	/* Interrupt line from ISAC-SX */
+	gpio_direction_input(1);
+	/* SPI CS 1.0..1.3 to ISAC-SX 0..3 */
+	gpio_direction_output(39, 1);
+	gpio_direction_output(32, 1);
+	gpio_direction_output(34, 1);
+	gpio_direction_output(22, 1);
+
+	/* Atheros AR8031 10/100/1000 PHY */
+	/* Reset line to PHY */
+	gpio_direction_output(15, 1);
+	/* Interrupt line from PHY */
+	gpio_direction_input(2);
+
+	/* Zarlink PLL ZL30342 */
+	/* Reset line to PLL */
+	gpio_direction_output(36, 1);
+	/* Interrupt line from PLL */
+	gpio_direction_input(9);
+	/* CLK_OUT2 as input for 25 MHz from PLL */
+	gpio_set_altfunc(3, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* NTR_CLK as output to reference clock 2 input of PLL */
+	gpio_set_altfunc(14, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* SPI CS 1.4 to PLL */
+	gpio_direction_output(37, 1);
+
+	/* USB port0 power enable, must be disabled at startup */
+	gpio_direction_output(41, 0);
+	/* USB port1 power enable, must be disabled at startup */
+	gpio_direction_output(33, 0);
+
+	/* TODO: move to NAND driver */
+	/* EBU.FL_CS1 as output for NAND CE */
+	gpio_set_altfunc(23, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* EBU.FL_A23 as output for NAND CLE */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+
+	/* TODO: move to USIF driver */
+	/* USIF/DIN input */
+	gpio_set_altfunc(11, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* USIF/DOUT output */
+	gpio_set_altfunc(12, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* USIF/CLK output */
+	gpio_set_altfunc(38, GPIO_ALTSEL_CLR, GPIO_ALTSEL_SET, GPIO_DIR_OUT);
+
+	/* Watchdog trigger line for MAX6722, needs clarification */
+	/* gpio_direction_output(8, 1); */
+
+	/* PCI-E CLKREQ, needs clarification */
+	/* gpio_direction_output(44, 1); */
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: Lantiq S-VIP */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC1: unused */
+	{ 1, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 0 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: unused */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 1 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Atheros AR8031 10/100/1000 PHY for WANoE port */
+	{ 5, 0x4, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+
+	ltq_gphy_phy11g_a2x_load(fw_ge_addr);
+
+	ltq_cgu_gphy_clk_src(clk);
+
+	ltq_rcu_gphy_boot(0, fw_ge_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	/* Serial flash at bus 0 (SPI) */
+	if (bus == 0 && cs == 4)
+		return 1;
+
+	/* ISAC-SX 0..3 at bus 1 (USIF) */
+	if (bus == 1 && cs < 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4)
+		gpio = 10;
+
+	else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* ISAC-SX 0 */
+			gpio = 39;
+			break;
+		case 1:		/* ISAC-SX 1 */
+			gpio = 32;
+			break;
+		case 2:		/* ISAC-SX 2 */
+			gpio = 34;
+			break;
+		case 3:		/* ISAC-SX 3 */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 0);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	int gpio = -1;
+
+	/* Serial flash at bus 0 (SPI) */
+	if (slave->bus == 0 && slave->cs == 4)
+		gpio = 10;
+
+	else if (slave->bus == 1) {
+		switch (slave->cs) {
+		case 0:		/* ISAC-SX 0 */
+			gpio = 39;
+			break;
+		case 1:		/* ISAC-SX 1 */
+			gpio = 32;
+			break;
+		case 2:		/* ISAC-SX 2 */
+			gpio = 34;
+			break;
+		case 3:		/* ISAC-SX 3 */
+			gpio = 22;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (gpio >= 0)
+		gpio_set_value(gpio, 1);
+}
diff --git a/board/sphairon/tl7201/Makefile b/board/sphairon/tl7201/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..df1f52fb76373c2cc91b6d72777798b24122b6b4
--- /dev/null
+++ b/board/sphairon/tl7201/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/tl7201/config.mk b/board/sphairon/tl7201/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/sphairon/tl7201/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/tl7201/ddr_settings.h b/board/sphairon/tl7201/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..0a7c41e859fc506f02eeea21c221eea24ef9e0d9
--- /dev/null
+++ b/board/sphairon/tl7201/ddr_settings.h
@@ -0,0 +1,53 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define MC_DC00_VALUE	0x1B1B
+#define MC_DC01_VALUE	0x0
+#define MC_DC02_VALUE	0x0
+#define MC_DC04_VALUE	0x0
+#define MC_DC05_VALUE	0x200
+#define MC_DC06_VALUE	0x605
+#define MC_DC07_VALUE	0x303
+#define MC_DC08_VALUE	0x102
+#define MC_DC09_VALUE	0x70a
+#define MC_DC10_VALUE	0x203
+#define MC_DC11_VALUE	0xc02
+#define MC_DC12_VALUE	0x1C8
+#define MC_DC13_VALUE	0x1
+#define MC_DC14_VALUE	0x0
+#define MC_DC15_VALUE	0xf3c
+#define MC_DC16_VALUE	0xC800
+#define MC_DC17_VALUE	0xd
+#define MC_DC18_VALUE	0x300
+#define MC_DC19_VALUE	0x200
+#define MC_DC20_VALUE	0xA03
+#define MC_DC21_VALUE	0x1600
+#define MC_DC22_VALUE	0x1616
+#define MC_DC23_VALUE	0x0
+#define MC_DC24_VALUE	0x62
+#define MC_DC25_VALUE	0x0
+#define MC_DC26_VALUE	0x0
+#define MC_DC27_VALUE	0x0
+#define MC_DC28_VALUE	0x510
+#define MC_DC29_VALUE	0x2d89
+#define MC_DC30_VALUE	0x8300
+#define MC_DC31_VALUE	0x0
+#define MC_DC32_VALUE	0x0
+#define MC_DC33_VALUE	0x0
+#define MC_DC34_VALUE	0x0
+#define MC_DC35_VALUE	0x0
+#define MC_DC36_VALUE	0x0
+#define MC_DC37_VALUE	0x0
+#define MC_DC38_VALUE	0x0
+#define MC_DC39_VALUE	0x0
+#define MC_DC40_VALUE	0x0
+#define MC_DC41_VALUE	0x0
+#define MC_DC42_VALUE	0x0
+#define MC_DC43_VALUE	0x0
+#define MC_DC44_VALUE	0x0
+#define MC_DC45_VALUE	0x500
+#define MC_DC46_VALUE	0x0
diff --git a/board/sphairon/tl7201/tl7201.c b/board/sphairon/tl7201/tl7201.c
new file mode 100644
index 0000000000000000000000000000000000000000..db71382ccaf3d7da1c74d6afed0bd81932d59c8d
--- /dev/null
+++ b/board/sphairon/tl7201/tl7201.c
@@ -0,0 +1,126 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <switch.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/chipid.h>
+
+static void gpio_init(void)
+{
+	/* GPIO LED power green, off */
+	gpio_direction_output(7, 0);
+	/* GPIO LED power red, on */
+	gpio_direction_output(14, 1);
+	/* GPIO LED internet green (low-active), off */
+	gpio_direction_output(19, 1);
+	/* GPIO LED internet red, off */
+	gpio_direction_output(23, 0);
+	/* GPIO LED VoIP green (low-active), off */
+	gpio_direction_output(10, 1);
+	/* GPIO LED info green (low-active), off */
+	gpio_direction_output(12, 1);
+	/* GPIO LED info red (low-active), off */
+	gpio_direction_output(11, 1);
+	/* GPIO LED FXO green (low-active), off */
+	gpio_direction_output(9, 1);
+	/* GPIO LED DSL green (low-active), off */
+	gpio_direction_output(5, 1);
+
+	/* GPIO button WLAN enable */
+	gpio_direction_input(29);
+	/* GPIO button board reset */
+	gpio_direction_input(30);
+
+	/* TDM/FSC used as input (FSC slave) */
+	gpio_set_altfunc(0, GPIO_ALTSEL_SET, GPIO_ALTSEL_SET, GPIO_DIR_IN);
+	/* TDM/DO output */
+	gpio_set_altfunc(25, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* TDM/DI input */
+	gpio_set_altfunc(26, GPIO_ALTSEL_CLR, GPIO_ALTSEL_SET, GPIO_DIR_IN);
+	/* TDM/DCL used as input (DCL slave) */
+	gpio_set_altfunc(27, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+
+	/* SPI/CS output (low-active) for ISAC-SX */
+	gpio_direction_output(15, 1);
+	/* SPI/CS output (low-active) for ISAC-SX */
+	gpio_direction_output(20, 1);
+	/* SPI/CS output (low-active) for SI3050 */
+	gpio_direction_output(22, 1);
+
+	/* PCI reset */
+	gpio_set_altfunc(21, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* FL_A23 for Flash address pin A22 */
+	gpio_set_altfunc(24, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* FL_A24 for Flash address pin A23 */
+	gpio_set_altfunc(13, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* external interrupt line from ISAC-SX chips */
+	gpio_direction_input(1);
+
+	/*
+	 * External hardware reset line
+	 * Low-active and not really needed because combined with lines for
+	 * Danube HRST_N and Dying Gasp. Thus the line must be always
+	 * driven high.
+	 */
+	gpio_direction_output(28, 1);
+	gpio_set_opendrain(28, GPIO_OD_ACTIVE);
+
+	/* USB port0 power enable, must be disabled at startup */
+	gpio_direction_output(31, 0);
+	gpio_set_opendrain(31, GPIO_OD_ACTIVE);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* MAC0: Lantiq Tantos Switch */
+	{ 0, 0x0, LTQ_ETH_PORT_SWITCH, PHY_INTERFACE_MODE_RMII },
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	printf("%s\n", __func__);
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+static struct switch_device psb697x_dev = {
+	.name = "psb697x",
+	.cpu_port = 5,
+	.port_mask = 0xF,
+};
+
+int board_switch_init(void)
+{
+	printf("%s\n", __func__);
+
+	ltq_reset_once(LTQ_RESET_HARD, 200000);
+	__udelay(50000);
+
+	return switch_device_register(&psb697x_dev);
+}
diff --git a/board/sphairon/vrx_g1/Makefile b/board/sphairon/vrx_g1/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..df1f52fb76373c2cc91b6d72777798b24122b6b4
--- /dev/null
+++ b/board/sphairon/vrx_g1/Makefile
@@ -0,0 +1,28 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/sphairon/vrx_g1/config.mk b/board/sphairon/vrx_g1/config.mk
new file mode 100644
index 0000000000000000000000000000000000000000..2dbfa9d56c2ef7f5340db7c114174c83c0633658
--- /dev/null
+++ b/board/sphairon/vrx_g1/config.mk
@@ -0,0 +1,8 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+PLATFORM_CPPFLAGS += -I$(TOPDIR)/board/$(BOARDDIR)
diff --git a/board/sphairon/vrx_g1/ddr_settings.h b/board/sphairon/vrx_g1/ddr_settings.h
new file mode 100644
index 0000000000000000000000000000000000000000..5ec21c03565717be445cd7f1fecd245bfcad1e59
--- /dev/null
+++ b/board/sphairon/vrx_g1/ddr_settings.h
@@ -0,0 +1,69 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define	MC_CCR00_VALUE	0x101
+#define	MC_CCR01_VALUE	0x1000100
+#define	MC_CCR02_VALUE	0x1010000
+#define	MC_CCR03_VALUE	0x100
+#define	MC_CCR04_VALUE	0x1000000
+#define	MC_CCR05_VALUE	0x1000101
+#define	MC_CCR06_VALUE	0x1000100
+#define	MC_CCR07_VALUE	0x1010000
+#define	MC_CCR08_VALUE	0x1000101
+#define	MC_CCR09_VALUE	0x0
+#define	MC_CCR10_VALUE	0x2000100
+#define	MC_CCR11_VALUE	0x2000401
+#define	MC_CCR12_VALUE	0x30000
+#define	MC_CCR13_VALUE	0x202
+#define	MC_CCR14_VALUE	0x7080A0F
+#define	MC_CCR15_VALUE	0x2040F
+#define	MC_CCR16_VALUE	0x40000
+#define	MC_CCR17_VALUE	0x70102
+#define	MC_CCR18_VALUE	0x4020002
+#define	MC_CCR19_VALUE	0x30302
+#define	MC_CCR20_VALUE	0x8000700
+#define	MC_CCR21_VALUE	0x40F020A
+#define	MC_CCR22_VALUE	0x0
+#define	MC_CCR23_VALUE	0xC020000
+#define	MC_CCR24_VALUE	0x4401B04
+#define	MC_CCR25_VALUE	0x0
+#define	MC_CCR26_VALUE	0x0
+#define	MC_CCR27_VALUE	0x6420000
+#define	MC_CCR28_VALUE	0x0
+#define	MC_CCR29_VALUE	0x0
+#define	MC_CCR30_VALUE	0x798
+#define	MC_CCR31_VALUE	0x0
+#define	MC_CCR32_VALUE	0x0
+#define	MC_CCR33_VALUE	0x650000
+#define	MC_CCR34_VALUE	0x200C8
+#define	MC_CCR35_VALUE	0x1D445D
+#define	MC_CCR36_VALUE	0xC8
+#define	MC_CCR37_VALUE	0xC351
+#define	MC_CCR38_VALUE	0x0
+#define	MC_CCR39_VALUE	0x141F04
+#define	MC_CCR40_VALUE	0x142704
+#define	MC_CCR41_VALUE	0x141b42
+#define	MC_CCR42_VALUE	0x141b42
+#define	MC_CCR43_VALUE	0x566504
+#define	MC_CCR44_VALUE	0x566504
+#define	MC_CCR45_VALUE	0x565F17
+#define	MC_CCR46_VALUE	0x565F17
+#define	MC_CCR47_VALUE	0x0
+#define	MC_CCR48_VALUE	0x0
+#define	MC_CCR49_VALUE	0x0
+#define	MC_CCR50_VALUE	0x0
+#define	MC_CCR51_VALUE	0x0
+#define	MC_CCR52_VALUE	0x133
+#define	MC_CCR53_VALUE	0xF3014B27
+#define	MC_CCR54_VALUE	0xF3014B27
+#define	MC_CCR55_VALUE	0xF3014B27
+#define	MC_CCR56_VALUE	0xF3014B27
+#define	MC_CCR57_VALUE	0x7800301
+#define	MC_CCR58_VALUE	0x7800301
+#define	MC_CCR59_VALUE	0x7800301
+#define	MC_CCR60_VALUE	0x7800301
+#define	MC_CCR61_VALUE	0x4
diff --git a/board/sphairon/vrx_g1/vrx_g1.c b/board/sphairon/vrx_g1/vrx_g1.c
new file mode 100644
index 0000000000000000000000000000000000000000..539098819564e5ab65918d2c339868e5727253fb
--- /dev/null
+++ b/board/sphairon/vrx_g1/vrx_g1.c
@@ -0,0 +1,145 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/gphy.h>
+
+static void gpio_init(void)
+{
+	/* SPI/CS output (low-active) for serial flash */
+	gpio_direction_output(10, 1);
+
+	/* xMII1.MII1_CRS connected to external KSZ8031 PHY */
+	gpio_set_altfunc(47, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+
+	/* COSIC modem reset, low-active, must be asserted at startup */
+	gpio_direction_output(14, 0);
+
+	/* Ralink iNIC WLAN reset, low-active, must be asserted at startup */
+	gpio_direction_output(15, 0);
+
+	/* Ralink iNIC WLAN power, must be disabled at startup */
+	gpio_direction_output(37, 0);
+
+	/* USB port0 power enable, must be disabled at startup */
+	gpio_direction_output(41, 0);
+
+	/* USB port1 power enable, must be disabled at startup */
+	gpio_direction_output(33, 0);
+}
+
+int board_early_init_f(void)
+{
+	gpio_init();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	puts("Board: " CONFIG_BOARD_NAME "\n");
+	ltq_chip_print_info();
+
+	return 0;
+}
+
+static const struct ltq_eth_port_config eth_port_config[] = {
+	/* GMAC0: Ralink iNIC */
+	{ 0, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+#ifdef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	/* GMAC1: not useable */
+	{ 1, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC2: internal GPHY0 with 10/100/1000 firmware for LAN port 3 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC3: not useable */
+	{ 3, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 1 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: not useable */
+	{ 5, 0x0, LTQ_ETH_PORT_NONE, PHY_INTERFACE_MODE_NONE },
+#else
+	/* GMAC1: external KSZ8031 10/100 PHY for WANoE port */
+	{ 1, 0x0, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RMII },
+	/* GMAC2: internal GPHY0 with 10/100 firmware for LAN port 4 */
+	{ 2, 0x11, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC3: internal GPHY0 with 10/100 firmware for LAN port 3 */
+	{ 3, 0x12, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_MII },
+	/* GMAC4: internal GPHY1 with 10/100/1000 firmware for LAN port 2 */
+	{ 4, 0x13, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_GMII },
+	/* GMAC5: external Lantiq PEF7071 10/100/1000 PHY for LAN port 1 */
+	{ 5, 0x19, LTQ_ETH_PORT_PHY, PHY_INTERFACE_MODE_RGMII },
+#endif
+
+};
+
+static const struct ltq_eth_board_config eth_board_config = {
+	.ports = eth_port_config,
+	.num_ports = ARRAY_SIZE(eth_port_config),
+};
+
+int board_eth_init(bd_t * bis)
+{
+	const enum ltq_gphy_clk clk = LTQ_GPHY_CLK_25MHZ_PLL0;
+	const ulong fw_ge_addr = 0x80FE0000;
+#ifndef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	const ulong fw_fe_addr = 0x80FF0000;
+#endif
+
+	ltq_gphy_phy11g_a1x_load(fw_ge_addr);
+#ifndef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	ltq_gphy_phy22f_a1x_load(fw_fe_addr);
+#endif
+
+	ltq_cgu_gphy_clk_src(clk);
+
+#ifdef CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+	ltq_rcu_gphy_boot(0, fw_ge_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+#else
+	ltq_rcu_gphy_boot(0, fw_fe_addr);
+	ltq_rcu_gphy_boot(1, fw_ge_addr);
+#endif
+
+	return ltq_eth_initialize(&eth_board_config);
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	if (bus)
+		return 0;
+
+	if (cs == 4)
+		return 1;
+
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+	case 4:
+		gpio_set_value(10, 1);
+		break;
+	default:
+		break;
+	}
+}
diff --git a/boards.cfg b/boards.cfg
index 1e5b3e05b7ef5ccf17d83c52458ef10b903f94ad..05ec462844d7e4114fbe1eef2e8126d4f8a909c2 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -347,13 +347,29 @@ dbau1000                     mips        mips32      dbau1x00            -
 dbau1100                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1100
 dbau1500                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1500
 dbau1550                     mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550
-dbau1550_el                  mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550
+dbau1550_el                  mips        mips32      dbau1x00            -              au1x00      dbau1x00:DBAU1550,SYS_LITTLE_ENDIAN
 gth2                         mips        mips32      -                   -              au1x00
 pb1000                       mips        mips32      pb1x00              -              au1x00      pb1x00:PB1000
+easy50712_nor                mips        mips32      easy50712           lantiq         danube      easy50712:SYS_BOOT_NOR
+easy50712_ram                mips        mips32      easy50712           lantiq         danube      easy50712:SYS_BOOT_RAM
+gigasx76x_nor                mips        mips32      sx76x               gigaset        danube      sx76x:SYS_BOOT_NOR
+gigasx76x_ram                mips        mips32      sx76x               gigaset        danube      sx76x:SYS_BOOT_RAM
+tl7201_nor                   mips        mips32      tl7201              sphairon       danube      tl7201:SYS_BOOT_NOR
+tl7201_ram                   mips        mips32      tl7201              sphairon       danube      tl7201:SYS_BOOT_RAM
 incaip                       mips        mips32      incaip              -              incaip
 incaip_100MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=100000000
 incaip_133MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=133000000
 incaip_150MHz                mips        mips32      incaip              -              incaip      incaip:CPU_CLOCK_RATE=150000000
+fb3370_ram                   mips        mips32      fb3370              avm            vrx200      fb3370:SYS_BOOT_RAM
+fb3370_eva                   mips        mips32      fb3370              avm            vrx200      fb3370:SYS_BOOT_EVA
+fb3370_sfspl                 mips        mips32      fb3370              avm            vrx200      fb3370:SYS_BOOT_SFSPL
+easy80920_nor                mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_NOR
+easy80920_ram                mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_RAM
+easy80920_sfspl              mips        mips32      easy80920           lantiq         vrx200      easy80920:SYS_BOOT_SFSPL
+isdn_sip_gw_ram              mips        mips32      isdn_sip_gw         sphairon       vrx200      isdn_sip_gw:SYS_BOOT_RAM
+isdn_sip_gw_sfspl            mips        mips32      isdn_sip_gw         sphairon       vrx200      isdn_sip_gw:SYS_BOOT_SFSPL
+vrx_g1_ram                   mips        mips32      vrx_g1              sphairon       vrx200      vrx_g1:SYS_BOOT_RAM
+vrx_g1_sfspl                 mips        mips32      vrx_g1              sphairon       vrx200      vrx_g1:SYS_BOOT_SFSPL
 qi_lb60                      mips        xburst      qi_lb60             qi
 adp-ag101                    nds32       n1213       adp-ag101           AndesTech      ag101
 adp-ag101p                   nds32       n1213       adp-ag101p          AndesTech      ag101
diff --git a/common/Makefile b/common/Makefile
index 2d9ae8c5c92319f666edd859b28903b179e54eec..fefafdb3c4d3c18464976ec816e09873c169b3d1 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -125,6 +125,7 @@ COBJS-$(CONFIG_CMD_MISC) += cmd_misc.o
 COBJS-$(CONFIG_CMD_MMC) += cmd_mmc.o
 COBJS-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
 COBJS-$(CONFIG_MP) += cmd_mp.o
+COBJS-$(CONFIG_CMD_MTD) += cmd_mtd.o
 COBJS-$(CONFIG_CMD_MTDPARTS) += cmd_mtdparts.o
 COBJS-$(CONFIG_CMD_NAND) += cmd_nand.o
 COBJS-$(CONFIG_CMD_NET) += cmd_net.o
diff --git a/common/cmd_mtd.c b/common/cmd_mtd.c
new file mode 100644
index 0000000000000000000000000000000000000000..fa46f63b3b31e7c94520e7b30302a147a7197c33
--- /dev/null
+++ b/common/cmd_mtd.c
@@ -0,0 +1,261 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * Command for read/write/erase via MTD layer
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/err.h>
+#include <linux/mtd/mtd.h>
+
+enum {
+	CMD_MTD_READ,
+	CMD_MTD_WRITE,
+	CMD_MTD_ERASE,
+	CMD_MTD_LOCK,
+	CMD_MTD_UNLOCK,
+};
+
+extern struct mtd_info *mtd_table[MAX_MTD_DEVICES];
+
+#define mtd_for_each_device(mtd)		\
+	for ((mtd) = mtd_table[0];		\
+		(mtd) != NULL;			\
+		(mtd) = mtd_table[(mtd)->index + 1])
+
+static int do_mtd_read_write(unsigned cmd, int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	char *endp, *mtdid;
+	ulong addr;
+	loff_t offset;
+	void *buf;
+	int ret;
+	size_t len, retlen;
+
+	if (argc < 4)
+		return -1;
+
+	mtdid = argv[2];
+	mtd = get_mtd_device_nm(mtdid);
+	if (IS_ERR(mtd)) {
+		printf("invalid MTD device: %s\n", mtdid);
+		return -1;
+	}
+
+	addr = simple_strtoul(argv[1], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	offset = simple_strtoul(argv[3], &endp, 16);
+	if (*argv[2] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	len = simple_strtoul(argv[4], &endp, 16);
+	if (*argv[3] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	buf = map_physmem(addr, len, MAP_WRBACK);
+	if (!buf) {
+		ret = 1;
+		goto done;
+	}
+
+	switch (cmd) {
+	case CMD_MTD_READ:
+		ret = mtd->read(mtd, offset, len, &retlen, buf);
+		break;
+	case CMD_MTD_WRITE:
+		ret = mtd->write(mtd, offset, len, &retlen, buf);
+		break;
+	default:
+		ret = -1;
+	}
+
+	unmap_physmem(buf, len);
+
+done:
+	put_mtd_device(mtd);
+
+	return ret;
+}
+
+/*
+ * Adopted from cmd_sf.c
+ *
+ * This function computes the length argument for the erase command.
+ * The length on which the command is to operate can be given in two forms:
+ * 1. <cmd> offset len  - operate on <'offset',  'len')
+ * 2. <cmd> offset +len - operate on <'offset',  'round_up(len)')
+ * If the second form is used and the length doesn't fall on the
+ * sector boundary, than it will be adjusted to the next sector boundary.
+ * If it isn't in the flash, the function will fail (return -1).
+ * Input:
+ *    arg: length specification (i.e. both command arguments)
+ * Output:
+ *    len: computed length for operation
+ * Return:
+ *    1: success
+ *   -1: failure (bad format, bad address).
+ */
+static int mtd_parse_len_arg(struct mtd_info *mtd, const char *arg, uint64_t *len)
+{
+	char *ep;
+	char round_up_len; /* indicates if the "+length" form used */
+	uint64_t len_arg;
+
+	round_up_len = 0;
+	if (*arg == '+') {
+		round_up_len = 1;
+		++arg;
+	}
+
+	len_arg = simple_strtoul(arg, &ep, 16);
+	if (ep == arg || *ep != 0)
+		return -1;
+
+	if (round_up_len && mtd->erasesize > 0)
+		*len = ROUND(len_arg, mtd->erasesize);
+	else
+		*len = len_arg;
+
+	return 0;
+}
+
+static int do_mtd_erase_lock_unlock(unsigned cmd, int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	struct erase_info instr;
+	char *endp, *mtdid;
+	int ret;
+
+	if (argc < 3)
+		return -1;
+
+	mtdid = argv[1];
+	mtd = get_mtd_device_nm(mtdid);
+	if (IS_ERR(mtd)) {
+		printf("invalid MTD device: %s\n", mtdid);
+		return -1;
+	}
+
+	instr.addr = simple_strtoul(argv[2], &endp, 16);
+	if (*argv[1] == 0 || *endp != 0) {
+		ret = -1;
+		goto done;
+	}
+
+	ret = mtd_parse_len_arg(mtd, argv[3], &instr.len);
+	if (ret)
+		goto done;
+
+	switch (cmd) {
+	case CMD_MTD_ERASE:
+		instr.mtd = mtd;
+		instr.callback = NULL;
+		ret = mtd->erase(mtd, &instr);
+		break;
+	case CMD_MTD_LOCK:
+		ret = mtd->lock(mtd, instr.addr, instr.len);
+		break;
+	case CMD_MTD_UNLOCK:
+		ret = mtd->unlock(mtd, instr.addr, instr.len);
+		break;
+	default:
+		ret = -1;
+	}
+
+done:
+	put_mtd_device(mtd);
+
+	return ret;
+}
+
+static const char mtd_type_str[][12] = {
+	"Absent",
+	"RAM",
+	"ROM",
+	"NOR flash",
+	"NAND flash",
+	"DATA flash",
+	"UBI volume"
+};
+
+static int do_mtd_info(int argc, char * const argv[])
+{
+	struct mtd_info *mtd;
+	const char *str;
+
+	mtd_for_each_device(mtd) {
+		str = mtd_type_str[mtd->type];
+		printf("%-16s - %s, ", mtd->name, str);
+		print_size(mtd->size, "\n");
+	}
+
+	return 0;
+}
+
+static int do_mtd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char *cmd;
+	int ret;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	cmd = argv[1];
+	argc--;
+	argv++;
+
+	if (strcmp(cmd, "read") == 0)
+		ret = do_mtd_read_write(CMD_MTD_READ, argc, argv);
+	else if (strcmp(cmd, "write") == 0)
+		ret = do_mtd_read_write(CMD_MTD_WRITE, argc, argv);
+	else if (strcmp(cmd, "erase") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_ERASE, argc, argv);
+	else if (strcmp(cmd, "lock") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_LOCK, argc, argv);
+	else if (strcmp(cmd, "unlock") == 0)
+		ret = do_mtd_erase_lock_unlock(CMD_MTD_UNLOCK, argc, argv);
+	else if (strcmp(cmd, "info") == 0)
+		ret = do_mtd_info(argc, argv);
+	else
+		ret = -1;
+
+	if (ret != -1)
+		return ret;
+
+usage:
+	return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(
+	mtd, 6, 0, do_mtd,
+	"MTD sub-system",
+	"info\n"
+	"    - show available MTD devices\n"
+	"mtd read addr mtdid offset len\n"
+	"    - read 'len' bytes from MTD 'mtdid' starting at 'offset' "
+		"to memory at 'addr'\n"
+	"mtd write addr mtdid offset len\n"
+	"    - write 'len' bytes from memory at 'addr' to MTD 'mtdid' "
+		"at 'offset'\n"
+	"mtd erase mtdid offset [+]len\n"
+	"    - erase 'len' bytes in MTD 'mtdid' from 'offset'\n"
+	"      +len' round up 'len' to MTD erase size\n"
+	"mtd lock|unlock mtdid offset [+]len\n"
+	"    - lock/unlock 'len' bytes in MTD 'mtdid' from 'offset'\n"
+	"      +len' round up 'len' to MTD erase size"
+);
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 5d864b56ef1a6c534cd52cdf70fb9aeae35e389c..455de4213565b69b2b33eef4df9d53ec70b8404f 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -28,6 +28,7 @@ LIB	:= $(obj)libdma.o
 COBJS-$(CONFIG_FSLDMAFEC) += MCD_tasksInit.o MCD_dmaApi.o MCD_tasks.o
 COBJS-$(CONFIG_APBH_DMA) += apbh_dma.o
 COBJS-$(CONFIG_FSL_DMA) += fsl_dma.o
+COBJS-$(CONFIG_LANTIQ_DMA) += lantiq_dma.o
 COBJS-$(CONFIG_OMAP3_DMA) += omap3_dma.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/dma/lantiq_dma.c b/drivers/dma/lantiq_dma.c
new file mode 100644
index 0000000000000000000000000000000000000000..abda77336ae72f16525b0eaa5dfa27cb62c421c3
--- /dev/null
+++ b/drivers/dma/lantiq_dma.c
@@ -0,0 +1,290 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/dma.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_DNA_CTRL_RESET		(1 << 0)
+
+#define LTQ_DMA_CPOLL_EN		(1 << 31)
+#define LTQ_DMA_CPOLL_CNT_SHIFT	4
+#define LTQ_DMA_CPOLL_CNT_MASK		(0xFFF << LTQ_DMA_CPOLL_CNT_SHIFT)
+
+#define LTQ_DMA_CCTRL_TXWGT_SHIFT	16
+#define LTQ_DMA_CCTRL_TXWGT_MASK	(0x3 << LTQ_DMA_CCTRL_TXWGT_SHIFT)
+#define LTQ_DMA_CCTRL_CLASS_SHIFT	9
+#define LTQ_DMA_CCTRL_CLASS_MASK	(0x3 << LTQ_DMA_CCTRL_CLASS_SHIFT)
+#define LTQ_DMA_CCTRL_RST		(1 << 1)
+#define LTQ_DMA_CCTRL_ONOFF		(1 << 0)
+
+#define LTQ_DMA_CDBA_CDBA_MASK		0x0FFFFFF8
+
+#define LTQ_DMA_PCTRL_DEFAULT		0x1068
+#define LTQ_DMA_PCTR_TXENDI_SHIFT	10
+#define LTQ_DMA_PCTR_TXENDI_MASK	(0x3 << LTQ_DMA_PCTR_TXENDI_SHIFT)
+#define LTQ_DMA_PCTR_RXENDI_SHIFT	8
+#define LTQ_DMA_PCTR_RXENDI_MASK	(0x3 << LTQ_DMA_PCTR_RXENDI_SHIFT)
+
+#define LTQ_DMA_DESCRIPTOR_SIZE		8	/* bytes */
+#define LTQ_DMA_DESCRIPTOR_COUNT	32
+#define LTQ_DMA_DESCRIPTOR_ALIGN	8	/* bytes */
+#define LTQ_DMA_DESCRIPTOR_DATA_MASK	0x0FFFFFF0
+
+enum ltq_dma_desc_owner {
+	LTQ_DMA_DESC_OWNER_CPU = 0,
+	LTQ_DMA_DESC_OWNER_DMA = 1,
+};
+
+struct ltq_dma_rx_desc {
+	unsigned own:1;
+	unsigned c:1;
+	unsigned sop:1;
+	unsigned eop:1;
+	unsigned res1:3;
+	unsigned byte_offset:2;
+	unsigned res2:7;
+	unsigned data_length:16;
+	unsigned data_pointer:32;
+};
+
+struct ltq_dma_tx_desc {
+	unsigned own:1;
+	unsigned c:1;
+	unsigned sop:1;
+	unsigned eop:1;
+	unsigned byte_offset:5;
+	unsigned res1:7;
+	unsigned data_length:16;
+	unsigned data_pointer:32;
+};
+
+struct ltq_dma_regs {
+	u32	clc;		/* Clock control */
+	u32	rsvd0;
+	u32	id;		/* Identification */
+	u32	rsvd1;
+	u32	ctrl;		/* Control */
+	u32	cpoll;		/* Channel polling */
+	u32	cs;		/* Channel select */
+	u32	cctrl;		/* Channel control */
+	u32	cdba;		/* Channel descriptor base address */
+	u32	cdlen;		/* Channel descriptor length */
+	u32	cis;		/* Channel interrupt status */
+	u32	cie;		/* Channel interrupt enable */
+	u32	cgbl;		/* Channel global buffer length */
+	u32	cdptnrd;	/* Current descriptor pointer */
+	u32	rsvd2[2];
+	u32	ps;		/* Port select */
+	u32	pctrl;		/* Port control */
+	u32	rsvd3[43];
+	u32	irnen;		/* Interrupt node enable */
+	u32	irncr;		/* Interrupt node control */
+	u32	irnicr;		/* Interrupt capture */
+};
+
+static struct list_head ltq_dma_devs;
+
+static struct ltq_dma_regs *ltq_dma_regs =
+	(struct ltq_dma_regs *) CKSEG1ADDR(LTQ_DMA_BASE);
+
+void ltq_dma_init(void)
+{
+	/* Power up DMA */
+	ltq_pm_enable(LTQ_PM_DMA);
+
+	/* Reset DMA */
+	ltq_reset_once(LTQ_RESET_DMA, 1);
+
+	/* Disable and clear all interrupts */
+	ltq_writel(&ltq_dma_regs->irnen, 0);
+	ltq_writel(&ltq_dma_regs->irncr, 0xFFFFF);
+
+	/* Enable polling for descriptor fetching for all channels */
+	ltq_writel(&ltq_dma_regs->cpoll, LTQ_DMA_CPOLL_EN |
+		    (4 << LTQ_DMA_CPOLL_CNT_SHIFT));
+
+	INIT_LIST_HEAD(&ltq_dma_devs);
+}
+
+static void ltq_dma_channel_reset(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_setbits(&ltq_dma_regs->cctrl, LTQ_DMA_CCTRL_RST);
+
+	memset(chan->mem_base, 0, chan->mem_size);
+}
+
+static void ltq_dma_channel_enable(struct ltq_dma_channel *chan)
+{
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_setbits(&ltq_dma_regs->cctrl, LTQ_DMA_CCTRL_ONOFF);
+}
+
+static void ltq_dma_port_init(struct ltq_dma_device *dev)
+{
+	u32 data;
+
+	data = LTQ_DMA_PCTRL_DEFAULT;
+	data |= dev->rx_endian_swap << LTQ_DMA_PCTR_RXENDI_SHIFT;
+	data |= dev->tx_endian_swap << LTQ_DMA_PCTR_TXENDI_SHIFT;
+
+	ltq_writel(&ltq_dma_regs->ps, dev->port);
+	ltq_writel(&ltq_dma_regs->pctrl, data);
+}
+
+struct ltq_dma_device *ltq_dma_alloc(void)
+{
+	struct ltq_dma_device *dev;
+
+	dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		return NULL;
+
+	INIT_LIST_HEAD(&dev->list);
+
+	return dev;
+}
+
+static int ltq_dma_alloc_descriptors(struct ltq_dma_channel *chan)
+{
+	void *mem_base, *desc_base;
+	size_t size;
+
+	size = LTQ_DMA_DESCRIPTOR_SIZE * chan->num_desc +
+		LTQ_DMA_DESCRIPTOR_ALIGN;
+
+	mem_base = calloc(1, size);
+	if (!mem_base)
+		return 1;
+
+	/* Align descriptor base to 8 bytes */
+	desc_base = mem_base + (LTQ_DMA_DESCRIPTOR_ALIGN - 1);
+	desc_base -= (u32) desc_base % LTQ_DMA_DESCRIPTOR_ALIGN;
+
+	chan->mem_size = size;
+	chan->mem_base = mem_base;
+	chan->desc_base = (void *) CKSEG1ADDR(desc_base);
+
+	/* Configure hardware with location of descriptor list */
+	ltq_writel(&ltq_dma_regs->cs, chan->chan_no);
+	ltq_writel(&ltq_dma_regs->cdba, (u32) chan->desc_base &
+			LTQ_DMA_CDBA_CDBA_MASK);
+	ltq_writel(&ltq_dma_regs->cdlen, chan->num_desc);
+
+	return 0;
+}
+
+int ltq_dma_register(struct ltq_dma_device *dev)
+{
+	int ret;
+
+	ltq_dma_channel_reset(&dev->rx_chan);
+	ltq_dma_channel_reset(&dev->tx_chan);
+	ltq_dma_port_init(dev);
+
+	ret = ltq_dma_alloc_descriptors(&dev->rx_chan);
+	if (ret)
+		return ret;
+
+	ret = ltq_dma_alloc_descriptors(&dev->tx_chan);
+	if (ret)
+		return ret;
+
+	list_add_tail(&dev->list, &ltq_dma_devs);
+
+	return 0;
+}
+
+void ltq_dma_reset(struct ltq_dma_device *dev)
+{
+	ltq_dma_channel_reset(&dev->rx_chan);
+	ltq_dma_channel_reset(&dev->tx_chan);
+}
+
+int ltq_dma_map_rx(struct ltq_dma_device *dev, int index, void *data, int len)
+{
+	struct ltq_dma_rx_desc *rx_desc_base = dev->rx_chan.desc_base;
+	struct ltq_dma_rx_desc *rx_desc = &rx_desc_base[index];
+
+	rx_desc->own = LTQ_DMA_DESC_OWNER_CPU;
+	rx_desc->sop = 0;
+	rx_desc->eop = 0;
+	rx_desc->byte_offset = 0;
+	rx_desc->data_pointer = (u32) data & LTQ_DMA_DESCRIPTOR_DATA_MASK;
+	rx_desc->data_length = len;
+
+	return 0;
+}
+
+int ltq_dma_read(struct ltq_dma_device *dev, int index)
+{
+	struct ltq_dma_rx_desc *rx_desc_base = dev->rx_chan.desc_base;
+	struct ltq_dma_rx_desc *rx_desc = &rx_desc_base[index];
+
+	if (rx_desc->own == LTQ_DMA_DESC_OWNER_DMA)
+		return 1;
+
+	ltq_dma_channel_enable(&dev->rx_chan);
+
+	rx_desc->c = 0;
+	rx_desc->own = LTQ_DMA_DESC_OWNER_DMA;
+
+	return 0;
+}
+
+int ltq_dma_read_poll(struct ltq_dma_device *dev, int index)
+{
+	struct ltq_dma_rx_desc *rx_desc_base = dev->rx_chan.desc_base;
+	struct ltq_dma_rx_desc *rx_desc = &rx_desc_base[index];
+
+	if (rx_desc->own == LTQ_DMA_DESC_OWNER_DMA)
+		return 0;
+
+	if (rx_desc->c)
+		return rx_desc->data_length;
+
+	return 0;
+}
+
+int ltq_dma_map_tx(struct ltq_dma_device *dev, int index, void *data, int len)
+{
+	struct ltq_dma_tx_desc *tx_desc_base = dev->tx_chan.desc_base;
+	struct ltq_dma_tx_desc *tx_desc = &tx_desc_base[index];
+
+	if (tx_desc->own == LTQ_DMA_DESC_OWNER_DMA)
+		return 1;
+
+	tx_desc->sop = 1;
+	tx_desc->eop = 1;
+	tx_desc->byte_offset = 0;
+	tx_desc->data_pointer = (u32) data & LTQ_DMA_DESCRIPTOR_DATA_MASK;
+	tx_desc->data_length = len;
+
+	return 0;
+}
+
+int ltq_dma_write(struct ltq_dma_device *dev, int index)
+{
+	struct ltq_dma_tx_desc *tx_desc_base = dev->tx_chan.desc_base;
+	struct ltq_dma_tx_desc *tx_desc = &tx_desc_base[index];
+
+	if (tx_desc->own == LTQ_DMA_DESC_OWNER_DMA)
+		return 1;
+
+	ltq_dma_channel_enable(&dev->tx_chan);
+
+	tx_desc->c = 0;
+	tx_desc->own = LTQ_DMA_DESC_OWNER_DMA;
+
+	return 0;
+}
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 5494bcffa7c4b247992f8a7e0e997a4b02cda2bf..caf1b8ede538f9c0852ab4ff96636752f98390c3 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -176,6 +176,18 @@ u64 flash_read64(void *addr)__attribute__((weak, alias("__flash_read64")));
 #define flash_read64	__flash_read64
 #endif
 
+static inline void *__flash_swap_addr(unsigned long addr)
+{
+	return (void *) addr;
+}
+
+#ifdef CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+void *flash_swap_addr(unsigned long addr)
+		__attribute__((weak, alias("__flash_swap_addr")));
+#else
+#define flash_swap_addr	__flash_swap_addr
+#endif
+
 /*-----------------------------------------------------------------------
  */
 #if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_SYS_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
@@ -211,7 +223,7 @@ flash_map (flash_info_t * info, flash_sect_t sect, uint offset)
 {
 	unsigned int byte_offset = offset * info->portwidth;
 
-	return (void *)(info->start[sect] + byte_offset);
+	return flash_swap_addr(info->start[sect] + byte_offset);
 }
 
 static inline void flash_unmap(flash_info_t *info, flash_sect_t sect,
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index 57112af66f2e13d85eeda79bd8da5e8566b0cb9e..92247ecbcb0a84e240e9da9bb63e5f5fbd82c85b 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -26,6 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	:= $(obj)libspi_flash.o
 
 COBJS-$(CONFIG_SPI_FLASH)	+= spi_flash.o
+COBJS-$(CONFIG_SPI_FLASH_MTD)	+= spi_flash_mtd.o
 COBJS-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
 COBJS-$(CONFIG_SPI_FLASH_EON)	+= eon.o
 COBJS-$(CONFIG_SPI_FLASH_MACRONIX)	+= macronix.o
diff --git a/drivers/mtd/spi/macronix.c b/drivers/mtd/spi/macronix.c
index dacbc28b3e5e2d5bb86bdb84314aeb1388df0bd9..1d7b9d60535ecd912bb29d79d89e452a53eec65b 100644
--- a/drivers/mtd/spi/macronix.c
+++ b/drivers/mtd/spi/macronix.c
@@ -48,6 +48,8 @@
 #define CMD_MX25XX_CE		0xc7	/* Chip Erase */
 #define CMD_MX25XX_DP		0xb9	/* Deep Power-down */
 #define CMD_MX25XX_RES		0xab	/* Release from DP, and Read Signature */
+#define CMD_MX25XX_EN4B		0xb7	/* Enter 4-byte mode */
+#define CMD_MX25XX_EX4B		0xe9	/* Exit 4-byte mode */
 
 struct macronix_spi_flash_params {
 	u16 idcode;
@@ -55,6 +57,7 @@ struct macronix_spi_flash_params {
 	u16 pages_per_sector;
 	u16 sectors_per_block;
 	u16 nr_blocks;
+	unsigned use_4byte_addr:1;
 	const char *name;
 };
 
@@ -65,6 +68,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 8,
+		.use_4byte_addr = 0,
 		.name = "MX25L4005",
 	},
 	{
@@ -73,6 +77,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 16,
+		.use_4byte_addr = 0,
 		.name = "MX25L8005",
 	},
 	{
@@ -81,6 +86,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 32,
+		.use_4byte_addr = 0,
 		.name = "MX25L1605D",
 	},
 	{
@@ -89,6 +95,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 64,
+		.use_4byte_addr = 0,
 		.name = "MX25L3205D",
 	},
 	{
@@ -97,6 +104,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 128,
+		.use_4byte_addr = 0,
 		.name = "MX25L6405D",
 	},
 	{
@@ -105,6 +113,7 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 256,
+		.use_4byte_addr = 0,
 		.name = "MX25L12805D",
 	},
 	{
@@ -113,8 +122,18 @@ static const struct macronix_spi_flash_params macronix_spi_flash_table[] = {
 		.pages_per_sector = 16,
 		.sectors_per_block = 16,
 		.nr_blocks = 256,
+		.use_4byte_addr = 0,
 		.name = "MX25L12855E",
 	},
+	{
+		.idcode = 0x2019,
+		.page_size = 256,
+		.pages_per_sector = 16,
+		.sectors_per_block = 16,
+		.nr_blocks = 512,
+		.use_4byte_addr = 1,
+		.name = "MX25L25635E",
+	},
 };
 
 static int macronix_write_status(struct spi_flash *flash, u8 sr)
@@ -161,6 +180,14 @@ static int macronix_erase(struct spi_flash *flash, u32 offset, size_t len)
 	return spi_flash_cmd_erase(flash, CMD_MX25XX_BE, offset, len);
 }
 
+static int macronix_set_4byte_addressing(struct spi_flash *flash, int on)
+{
+	struct spi_slave *spi = flash->spi;
+	u8 cmd = on ? CMD_MX25XX_EN4B : CMD_MX25XX_EX4B;
+
+	return spi_flash_cmd(spi, cmd, NULL, 0);
+}
+
 struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
 {
 	const struct macronix_spi_flash_params *params;
@@ -196,6 +223,11 @@ struct spi_flash *spi_flash_probe_macronix(struct spi_slave *spi, u8 *idcode)
 		* params->sectors_per_block;
 	flash->size = flash->sector_size * params->nr_blocks;
 
+	if (params->use_4byte_addr)
+		flash->set_4byte_addressing = macronix_set_4byte_addressing;
+	else
+		flash->set_4byte_addressing = NULL;
+
 	/* Clear BP# bits for read-only flash */
 	macronix_unlock(flash);
 
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index f689cc47cfccac051e4257de47bedfcecb5bd13a..893226373505272f579938f033c76416f3407814 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -15,12 +15,38 @@
 
 #include "spi_flash_internal.h"
 
-static void spi_flash_addr(u32 addr, u8 *cmd)
+static void spi_flash_addr(struct spi_flash *flash, u32 addr, u8 *cmd, u8 *cmd_len)
 {
 	/* cmd[0] is actual command */
-	cmd[1] = addr >> 16;
-	cmd[2] = addr >> 8;
-	cmd[3] = addr >> 0;
+	if (spi_flash_has_4byte_addressing(flash)) {
+		cmd[1] = addr >> 24;
+		cmd[2] = addr >> 16;
+		cmd[3] = addr >> 8;
+		cmd[4] = addr >> 0;
+		*cmd_len = 5;
+	} else {
+		cmd[1] = addr >> 16;
+		cmd[2] = addr >> 8;
+		cmd[3] = addr >> 0;
+		*cmd_len = 4;
+	}
+}
+
+static void spi_flash_page_addr(struct spi_flash *flash, u32 page_addr, u32 byte_addr, u8 *cmd, u8 *cmd_len)
+{
+	/* cmd[0] is actual command */
+	if (spi_flash_has_4byte_addressing(flash)) {
+		cmd[1] = page_addr >> 16;
+		cmd[2] = page_addr >> 8;
+		cmd[3] = page_addr >> 0;
+		cmd[4] = byte_addr;
+		*cmd_len = 5;
+	} else {
+		cmd[1] = page_addr >> 8;
+		cmd[2] = page_addr >> 0;
+		cmd[3] = byte_addr;
+		*cmd_len = 4;
+	}
 }
 
 static int spi_flash_read_write(struct spi_slave *spi,
@@ -71,7 +97,7 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 	unsigned long page_addr, byte_addr, page_size;
 	size_t chunk_len, actual;
 	int ret;
-	u8 cmd[4];
+	u8 cmd[5], cmd_len;
 
 	page_size = flash->page_size;
 	page_addr = offset / page_size;
@@ -83,16 +109,22 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 		return ret;
 	}
 
+	if (spi_flash_has_4byte_addressing(flash)) {
+		ret = spi_flash_4byte_addressing_enable(flash);
+		if (ret) {
+			debug("SF: Unable to set 4-byte addressing\n");
+			return ret;
+		}
+	}
+
 	cmd[0] = CMD_PAGE_PROGRAM;
 	for (actual = 0; actual < len; actual += chunk_len) {
 		chunk_len = min(len - actual, page_size - byte_addr);
 
-		cmd[1] = page_addr >> 8;
-		cmd[2] = page_addr;
-		cmd[3] = byte_addr;
+		spi_flash_page_addr(flash, page_addr, byte_addr, cmd, &cmd_len);
 
-		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
-		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+		debug("PP: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x%02x } chunk_len = %zu\n",
+		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], chunk_len);
 
 		ret = spi_flash_cmd_write_enable(flash);
 		if (ret < 0) {
@@ -100,7 +132,7 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 			break;
 		}
 
-		ret = spi_flash_cmd_write(flash->spi, cmd, 4,
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len,
 					  buf + actual, chunk_len);
 		if (ret < 0) {
 			debug("SF: write failed\n");
@@ -118,6 +150,9 @@ int spi_flash_cmd_write_multi(struct spi_flash *flash, u32 offset,
 	debug("SF: program %s %zu bytes @ %#x\n",
 	      ret ? "failure" : "success", len, offset);
 
+	if (spi_flash_has_4byte_addressing(flash))
+		spi_flash_4byte_addressing_disable(flash);
+
 	spi_release_bus(flash->spi);
 	return ret;
 }
@@ -129,7 +164,20 @@ int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 	int ret;
 
 	spi_claim_bus(spi);
+
+	if (spi_flash_has_4byte_addressing(flash)) {
+		ret = spi_flash_4byte_addressing_enable(flash);
+		if (ret) {
+			debug("SF: Unable to set 4-byte addressing\n");
+			return ret;
+		}
+	}
+
 	ret = spi_flash_cmd_read(spi, cmd, cmd_len, data, data_len);
+
+	if (spi_flash_has_4byte_addressing(flash))
+		spi_flash_4byte_addressing_disable(flash);
+
 	spi_release_bus(spi);
 
 	return ret;
@@ -138,13 +186,13 @@ int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 int spi_flash_cmd_read_fast(struct spi_flash *flash, u32 offset,
 		size_t len, void *data)
 {
-	u8 cmd[5];
+	u8 cmd[6], cmd_len;
 
 	cmd[0] = CMD_READ_ARRAY_FAST;
-	spi_flash_addr(offset, cmd);
-	cmd[4] = 0x00;
+	spi_flash_addr(flash, offset, cmd, &cmd_len);
+	cmd[cmd_len] = 0x00;
 
-	return spi_flash_read_common(flash, cmd, sizeof(cmd), data, len);
+	return spi_flash_read_common(flash, cmd, cmd_len + 1, data, len);
 }
 
 int spi_flash_cmd_poll_bit(struct spi_flash *flash, unsigned long timeout,
@@ -195,7 +243,7 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u8 erase_cmd,
 {
 	u32 start, end, erase_size;
 	int ret;
-	u8 cmd[4];
+	u8 cmd[5], cmd_len;
 
 	erase_size = flash->sector_size;
 	if (offset % erase_size || len % erase_size) {
@@ -213,18 +261,26 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u8 erase_cmd,
 	start = offset;
 	end = start + len;
 
+	if (spi_flash_has_4byte_addressing(flash)) {
+		ret = spi_flash_4byte_addressing_enable(flash);
+		if (ret) {
+			debug("SF: Unable to set 4-byte addressing\n");
+			return ret;
+		}
+	}
+
 	while (offset < end) {
-		spi_flash_addr(offset, cmd);
+		spi_flash_addr(flash, offset, cmd, &cmd_len);
 		offset += erase_size;
 
-		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
-		      cmd[2], cmd[3], offset);
+		debug("SF: erase %2x %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
+		      cmd[2], cmd[3], cmd[4], offset);
 
 		ret = spi_flash_cmd_write_enable(flash);
 		if (ret)
 			goto out;
 
-		ret = spi_flash_cmd_write(flash->spi, cmd, sizeof(cmd), NULL, 0);
+		ret = spi_flash_cmd_write(flash->spi, cmd, cmd_len, NULL, 0);
 		if (ret)
 			goto out;
 
@@ -236,6 +292,9 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u8 erase_cmd,
 	debug("SF: Successfully erased %zu bytes @ %#x\n", len, start);
 
  out:
+	if (spi_flash_has_4byte_addressing(flash))
+		spi_flash_4byte_addressing_disable(flash);
+
 	spi_release_bus(flash->spi);
 	return ret;
 }
@@ -356,12 +415,16 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		goto err_manufacturer_probe;
 	}
 
-	printf("SF: Detected %s with page size ", flash->name);
+	printf("SF:    %s, page size ", flash->name);
 	print_size(flash->sector_size, ", total ");
 	print_size(flash->size, "\n");
 
 	spi_release_bus(spi);
 
+#ifndef CONFIG_SPI_FLASH_4BYTE_ADDRESSING
+	flash->set_4byte_addressing = NULL;
+#endif
+
 	return flash;
 
 err_manufacturer_probe:
@@ -377,3 +440,75 @@ void spi_flash_free(struct spi_flash *flash)
 	spi_free_slave(flash->spi);
 	free(flash);
 }
+
+int spi_flash_probe_spl(struct spi_flash *sf, unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *spi;
+	u8 idcode[IDCODE_LEN], *idp;
+	int ret, i, shift, found;
+
+	spi = spi_setup_slave(bus, cs, max_hz, spi_mode);
+	if (!spi)
+		return -1;
+
+	ret = spi_claim_bus(spi);
+	if (ret)
+		goto err_claim_bus;
+
+	/* Read the ID codes */
+	ret = spi_flash_cmd(spi, CMD_READ_ID, idcode, sizeof(idcode));
+	if (ret)
+		goto err_read_id;
+
+	/* count the number of continuation bytes */
+	for (shift = 0, idp = idcode;
+	     shift < IDCODE_CONT_LEN && *idp == 0x7f;
+	     ++shift, ++idp)
+		continue;
+
+	/* search the table for matches in shift and id */
+	found = 0;
+	for (i = 0; i < ARRAY_SIZE(flashes); ++i)
+		if (flashes[i].shift == shift && flashes[i].idcode == *idp) {
+			found = 1;
+			break;
+		}
+
+	if (!found)
+		goto err_manufacturer_probe;
+
+	spi_release_bus(spi);
+
+	sf->spi = spi;
+	sf->read = spi_flash_cmd_read_fast;
+	sf->set_4byte_addressing = NULL;
+
+	return 0;
+
+err_manufacturer_probe:
+err_read_id:
+	spi_release_bus(spi);
+
+err_claim_bus:
+	spi_free_slave(spi);
+
+	return ret;
+}
+
+int spi_flash_init(void)
+{
+	struct spi_flash *sf;
+	int err;
+
+	sf = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (!sf)
+		return -1;
+
+	err = spi_flash_mtd_init(sf);
+	if (err)
+		spi_flash_free(sf);
+
+	return err;
+}
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
index 91e036a4e7cb54abb608613ad7c8475f07e8033c..5e3c0e30525944ad9860f8805025141b39cb8701 100644
--- a/drivers/mtd/spi/spi_flash_internal.h
+++ b/drivers/mtd/spi/spi_flash_internal.h
@@ -91,6 +91,16 @@ int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout);
 int spi_flash_cmd_erase(struct spi_flash *flash, u8 erase_cmd,
 			u32 offset, size_t len);
 
+static inline int spi_flash_4byte_addressing_enable(struct spi_flash *flash)
+{
+	return flash->set_4byte_addressing(flash, 1);
+}
+
+static inline int spi_flash_4byte_addressing_disable(struct spi_flash *flash)
+{
+	return flash->set_4byte_addressing(flash, 0);
+}
+
 /* Manufacturer-specific probe functions */
 struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
 struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
diff --git a/drivers/mtd/spi/spi_flash_mtd.c b/drivers/mtd/spi/spi_flash_mtd.c
new file mode 100644
index 0000000000000000000000000000000000000000..9829a6aaa6f4398aa8096293e5ebadde5c70ac9a
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_mtd.c
@@ -0,0 +1,109 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * MTD layer driver for SPI flash devices
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
+#include <spi_flash.h>
+
+static struct mtd_info sf_mtd_info;
+static char sf_mtd_name[8];
+
+static int spi_flash_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct spi_flash *sf = mtd->priv;
+	int err;
+
+	instr->state = MTD_ERASING;
+
+	err = spi_flash_erase(sf, instr->addr, instr->len);
+	if (err) {
+		instr->state = MTD_ERASE_FAILED;
+		instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+		return -EIO;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+static int spi_flash_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct spi_flash *sf = mtd->priv;
+	int err;
+
+	err = spi_flash_read(sf, from, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static int spi_flash_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct spi_flash *sf = mtd->priv;
+	int err;
+
+	err = spi_flash_write(sf, to, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static void spi_flash_mtd_sync(struct mtd_info *mtd)
+{
+	/*
+	 * This function should wait until all pending operations
+	 * finish. However this driver is fully synchronous, so
+	 * this function returns immediately
+	 */
+}
+
+static inline int spi_flash_mtd_number(void)
+{
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS
+	return CONFIG_SYS_MAX_FLASH_BANKS;
+#else
+	return 0;
+#endif
+}
+
+int spi_flash_mtd_init(struct spi_flash *sf)
+{
+	memset(&sf_mtd_info, 0, sizeof(sf_mtd_info));
+	sprintf(sf_mtd_name, "nor%d", spi_flash_mtd_number());
+
+	sf_mtd_info.name = sf_mtd_name;
+	sf_mtd_info.type = MTD_NORFLASH;
+	sf_mtd_info.flags = MTD_CAP_NORFLASH;
+	sf_mtd_info.writesize = 1;
+
+	sf_mtd_info.erase = spi_flash_mtd_erase;
+	sf_mtd_info.read = spi_flash_mtd_read;
+	sf_mtd_info.write = spi_flash_mtd_write;
+	sf_mtd_info.sync = spi_flash_mtd_sync;
+
+	sf_mtd_info.size = sf->size;
+	sf_mtd_info.priv = sf;
+
+	/*
+	 * Uniform flash with either page size or block size
+	 * assigned to sf->sector_size
+	 */
+	sf_mtd_info.numeraseregions = 0;
+	sf_mtd_info.erasesize = sf->sector_size;
+
+	return add_mtd_device(&sf_mtd_info);
+}
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index d3df82ee397e8b6dbd80d9f74fe56f8ffd7df262..f5b557a77c1143347d7c5164c1513d38e75aa6e6 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -50,6 +50,8 @@ COBJS-$(CONFIG_GRETH) += greth.o
 COBJS-$(CONFIG_INCA_IP_SWITCH) += inca-ip_sw.o
 COBJS-$(CONFIG_DRIVER_KS8695ETH) += ks8695eth.o
 COBJS-$(CONFIG_LAN91C96) += lan91c96.o
+COBJS-$(CONFIG_LANTIQ_DANUBE_ETOP) += lantiq_danube_etop.o
+COBJS-$(CONFIG_LANTIQ_VRX200_SWITCH) += lantiq_vrx200_switch.o
 COBJS-$(CONFIG_MACB) += macb.o
 COBJS-$(CONFIG_MCFFEC) += mcffec.o mcfmii.o
 COBJS-$(CONFIG_MPC5xxx_FEC) += mpc5xxx_fec.o
diff --git a/drivers/net/lantiq_danube_etop.c b/drivers/net/lantiq_danube_etop.c
new file mode 100644
index 0000000000000000000000000000000000000000..09c653fefe9ea3db2e863fccc785a63a26d17faf
--- /dev/null
+++ b/drivers/net/lantiq_danube_etop.c
@@ -0,0 +1,396 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <switch.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/dma.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PPE_ETOP_MDIO_ACC_RA	(1 << 31)
+#define LTQ_PPE_ETOP_MDIO_CFG_UMM1	(1 << 2)
+#define LTQ_PPE_ETOP_MDIO_CFG_UMM0	(1 << 1)
+
+#define LTQ_PPE_ETOP_CFG_TCKINV1	(1 << 11)
+#define LTQ_PPE_ETOP_CFG_TCKINV0	(1 << 10)
+#define LTQ_PPE_ETOP_CFG_FEN1		(1 << 9)
+#define LTQ_PPE_ETOP_CFG_FEN0		(1 << 8)
+#define LTQ_PPE_ETOP_CFG_SEN1		(1 << 7)
+#define LTQ_PPE_ETOP_CFG_SEN0		(1 << 6)
+#define LTQ_PPE_ETOP_CFG_TURBO1		(1 << 5)
+#define LTQ_PPE_ETOP_CFG_REMII1		(1 << 4)
+#define LTQ_PPE_ETOP_CFG_OFF1		(1 << 3)
+#define LTQ_PPE_ETOP_CFG_TURBO0		(1 << 2)
+#define LTQ_PPE_ETOP_CFG_REMII0		(1 << 1)
+#define LTQ_PPE_ETOP_CFG_OFF0		(1 << 0)
+
+#define LTQ_PPE_ENET0_MAC_CFG_CGEN	(1 << 11)
+#define LTQ_PPE_ENET0_MAC_CFG_DUPLEX	(1 << 2)
+#define LTQ_PPE_ENET0_MAC_CFG_SPEED	(1 << 1)
+#define LTQ_PPE_ENET0_MAC_CFG_LINK	(1 << 0)
+
+#define LTQ_PPE_ENETS0_CFG_FTUC		(1 << 28)
+
+#define LTQ_ETH_RX_BUFFER_CNT		PKTBUFSRX
+
+#define LTQ_MDIO_DRV_NAME		"ltq-mdio"
+#define LTQ_ETH_DRV_NAME		"ltq-eth"
+
+struct ltq_ppe_etop_regs {
+	u32	mdio_cfg;		/* MDIO configuration */
+	u32	mdio_acc;		/* MDIO access */
+	u32	cfg;			/* ETOP configuration */
+	u32	ig_vlan_cos;		/* IG VLAN priority CoS mapping */
+	u32	ig_dscp_cos3;		/* IG DSCP CoS mapping 3 */
+	u32	ig_dscp_cos2;		/* IG DSCP CoS mapping 2 */
+	u32	ig_dscp_cos1;		/* IG DSCP CoS mapping 1 */
+	u32	ig_dscp_cos0;		/* IG DSCP CoS mapping 0 */
+	u32	ig_plen_ctrl;		/* IG frame length control */
+	u32	rsvd0[3];
+	u32	vpid;			/* VLAN protocol ID */
+};
+
+struct ltq_ppe_enet_regs {
+	u32	mac_cfg;		/* MAC configuration */
+	u32	rsvd0[3];
+	u32	ig_cfg;			/* Ingress configuration */
+	u32	ig_pgcnt;		/* Ingress buffer used page count */
+	u32	rsvd1;
+	u32	ig_buf_ctrl;		/* Ingress buffer backpressure ctrl */
+	u32	cos_cfg;		/* Classification configuration */
+	u32	ig_drop;		/* Total ingress drop frames */
+	u32	ig_err;			/* Total ingress error frames */
+	u32	mac_da0;		/* Ingress MAC address 0 */
+	u32	mac_da1;		/* Ingress MAC address 1 */
+	u32	rsvd2[22];
+	u32	pgcnt;			/* Page counter */
+	u32	rsvd3;
+	u32	hf_ctrl;		/* Half duplex control */
+	u32	tx_ctrl;		/* Transmit control */
+	u32	rsvd4;
+	u32	vlcos0;			/* VLAN insertion config CoS 0 */
+	u32	vlcos1;			/* VLAN insertion config CoS 1 */
+	u32	vlcos2;			/* VLAN insertion config CoS 2 */
+	u32	vlcos3;			/* VLAN insertion config CoS 3 */
+	u32	eg_col;			/* Total egress collision frames */
+	u32	eg_drop;		/* Total egress drop frames */
+};
+
+struct ltq_eth_priv {
+	struct ltq_dma_device *dma_dev;
+	struct mii_dev *bus;
+	struct eth_device *dev;
+	int rx_num;
+};
+
+struct ltq_mdio_access {
+	union {
+		struct {
+			unsigned ra:1;
+			unsigned rw:1;
+			unsigned rsvd:4;
+			unsigned phya:5;
+			unsigned rega:5;
+			unsigned phyd:16;
+		} reg;
+		u32 val;
+	};
+};
+
+static struct ltq_ppe_etop_regs *ltq_ppe_etop_regs =
+	(struct ltq_ppe_etop_regs *) CKSEG1ADDR(LTQ_PPE_ETOP_BASE);
+
+static struct ltq_ppe_enet_regs *ltq_ppe_enet0_regs =
+	(struct ltq_ppe_enet_regs *) CKSEG1ADDR(LTQ_PPE_ENET0_BASE);
+
+static inline int ltq_mdio_poll(void)
+{
+	struct ltq_mdio_access acc;
+	unsigned cnt = 10000;
+
+	while (likely(cnt--)) {
+		acc.val = ltq_readl(&ltq_ppe_etop_regs->mdio_acc);
+		if (!acc.reg.ra)
+			return 0;
+	}
+
+	return 1;
+}
+
+static int ltq_mdio_read(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.reg.ra = 1;
+	acc.reg.rw = 1;
+	acc.reg.phya = addr;
+	acc.reg.rega = regnum;
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	ltq_writel(&ltq_ppe_etop_regs->mdio_acc, acc.val);
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	acc.val = ltq_readl(&ltq_ppe_etop_regs->mdio_acc);
+
+	return acc.reg.phyd;
+}
+
+static int ltq_mdio_write(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum, u16 val)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.reg.ra = 1;
+	acc.reg.rw = 0;
+	acc.reg.phya = addr;
+	acc.reg.rega = regnum;
+	acc.reg.phyd = val;
+
+	ret = ltq_mdio_poll();
+	if (ret)
+		return ret;
+
+	ltq_writel(&ltq_ppe_etop_regs->mdio_acc, acc.val);
+
+	return 0;
+}
+
+static inline void ltq_eth_write_hwaddr(const struct eth_device *dev)
+{
+	u32 da0, da1;
+
+	da0 = (dev->enetaddr[0] << 24) + (dev->enetaddr[1] << 16) +
+		(dev->enetaddr[2] << 8) + dev->enetaddr[3];
+	da1 = (dev->enetaddr[4] << 24) + (dev->enetaddr[5] << 16);
+
+	ltq_writel(&ltq_ppe_enet0_regs->mac_da0, da0);
+	ltq_writel(&ltq_ppe_enet0_regs->mac_da1, da1);
+}
+
+static int ltq_eth_init(struct eth_device *dev, bd_t *bis)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	int i, ret;
+
+	ltq_eth_write_hwaddr(dev);
+
+	for (i = 0; i < LTQ_ETH_RX_BUFFER_CNT; i++) {
+		ret = ltq_dma_map_rx(priv->dma_dev, i,
+				      (void *) NetRxPackets[i], PKTSIZE_ALIGN);
+		if (ret)
+			return ret;
+
+		ret = ltq_dma_read(priv->dma_dev, i);
+		if (ret)
+			return ret;
+	}
+
+	priv->rx_num = 0;
+
+	return 0;
+}
+
+static void ltq_eth_halt(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+
+	ltq_dma_reset(priv->dma_dev);
+}
+
+static int ltq_eth_send(struct eth_device *dev, volatile void *packet,
+			int length)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	int ret;
+
+	/* Minimum payload length w/ CRC is 60 bytes */
+	if (length < 60)
+		length = 60;
+
+	ret = ltq_dma_map_tx(priv->dma_dev, 0, (void *) packet, length);
+	if (ret)
+		return ret;
+
+	flush_dcache_range((ulong) packet, (ulong) packet + length);
+
+	ret = ltq_dma_write(priv->dma_dev, 0);
+
+	return ret;
+}
+
+static int ltq_eth_recv(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	int len;
+
+	for (;;) {
+		len = ltq_dma_read_poll(priv->dma_dev, priv->rx_num);
+		if (!len)
+			return 0;
+
+		invalidate_dcache_range((ulong) NetRxPackets[priv->rx_num],
+					(ulong) NetRxPackets[priv->rx_num] +
+					len);
+
+		NetReceive(NetRxPackets[priv->rx_num], len);
+
+		ltq_dma_map_rx(priv->dma_dev, priv->rx_num,
+				(void *) NetRxPackets[priv->rx_num],
+				PKTSIZE_ALIGN);
+		ltq_dma_read(priv->dma_dev, priv->rx_num);
+
+		priv->rx_num = (priv->rx_num + 1) % LTQ_ETH_RX_BUFFER_CNT;
+	};
+
+	return 0;
+}
+
+static void ltq_eth_hw_init(const struct ltq_eth_port_config *port)
+{
+	u32 data;
+
+	/* Power up ethernet subsystems */
+	ltq_pm_enable(LTQ_PM_ETH);
+
+	/* Reset ethernet subsystems */
+	ltq_reset_once(LTQ_RESET_ETH, 1);
+
+	/* Disable MDIO auto-detection */
+	ltq_clrbits(&ltq_ppe_etop_regs->mdio_cfg, LTQ_PPE_ETOP_MDIO_CFG_UMM1 |
+			LTQ_PPE_ETOP_MDIO_CFG_UMM0);
+
+	/* Enable CRC generation, Full Duplex, 100Mbps, Link up */
+	ltq_writel(&ltq_ppe_enet0_regs->mac_cfg, LTQ_PPE_ENET0_MAC_CFG_CGEN |
+			LTQ_PPE_ENET0_MAC_CFG_DUPLEX |
+			LTQ_PPE_ENET0_MAC_CFG_SPEED |
+			LTQ_PPE_ENET0_MAC_CFG_LINK);
+
+	/* Reset ETOP cfg and disable all */
+	data = LTQ_PPE_ETOP_CFG_OFF0 | LTQ_PPE_ETOP_CFG_OFF1;
+
+	/* Enable ENET0, enable store and fetch */
+	data &= ~LTQ_PPE_ETOP_CFG_OFF0;
+	data |= LTQ_PPE_ETOP_CFG_SEN0 | LTQ_PPE_ETOP_CFG_FEN0;
+
+	if (port->phy_if == PHY_INTERFACE_MODE_RMII)
+		data |= LTQ_PPE_ETOP_CFG_REMII0;
+	else
+		data &= ~LTQ_PPE_ETOP_CFG_REMII0;
+
+	ltq_writel(&ltq_ppe_etop_regs->cfg, data);
+
+	/* Set allowed packet length from 64 bytes to 1518 bytes */
+	ltq_writel(&ltq_ppe_etop_regs->ig_plen_ctrl, (64 << 16) | 1518);
+
+	/* Enable filter for unicast packets */
+	ltq_setbits(&ltq_ppe_enet0_regs->ig_cfg, LTQ_PPE_ENETS0_CFG_FTUC);
+}
+
+int ltq_eth_initialize(const struct ltq_eth_board_config *board_config)
+{
+	struct eth_device *dev;
+	struct mii_dev *bus;
+	struct ltq_eth_priv *priv;
+	struct ltq_dma_device *dma_dev;
+	const struct ltq_eth_port_config *port = &board_config->ports[0];
+	struct phy_device *phy;
+	struct switch_device *sw;
+	int ret;
+
+	ltq_dma_init();
+	ltq_eth_hw_init(port);
+
+	dev = calloc(1, sizeof(*dev));
+	if (!dev)
+		return -1;
+
+	priv = calloc(1, sizeof(*priv));
+	if (!priv)
+		return -1;
+
+	bus = mdio_alloc();
+	if (!bus)
+		return -1;
+
+	dma_dev = ltq_dma_alloc();
+	if (!dma_dev)
+		return -1;
+
+	sprintf(dev->name, LTQ_ETH_DRV_NAME);
+	dev->priv = priv;
+	dev->init = ltq_eth_init;
+	dev->halt = ltq_eth_halt;
+	dev->recv = ltq_eth_recv;
+	dev->send = ltq_eth_send;
+
+	sprintf(bus->name, LTQ_MDIO_DRV_NAME);
+	bus->read = ltq_mdio_read;
+	bus->write = ltq_mdio_write;
+	bus->priv = priv;
+
+	dma_dev->port = 0;
+	dma_dev->rx_chan.chan_no = 6;
+	dma_dev->rx_chan.class = 3;
+	dma_dev->rx_chan.num_desc = LTQ_ETH_RX_BUFFER_CNT;
+	dma_dev->rx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->tx_chan.chan_no = 7;
+	dma_dev->tx_chan.class = 3;
+	dma_dev->tx_chan.num_desc = 1;
+	dma_dev->tx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->priv = priv;
+
+	priv->dma_dev = dma_dev;
+	priv->bus = bus;
+	priv->dev = dev;
+
+	ret = ltq_dma_register(dma_dev);
+	if (ret)
+		return ret;
+
+	ret = mdio_register(bus);
+	if (ret)
+		return ret;
+
+	ret = eth_register(dev);
+	if (ret)
+		return ret;
+
+	if (port->flags & LTQ_ETH_PORT_SWITCH) {
+		sw = switch_connect(bus);
+		if (!sw)
+			return -1;
+
+		switch_setup(sw);
+	}
+
+	if (port->flags & LTQ_ETH_PORT_PHY) {
+		phy = phy_connect(bus, port->phy_addr, dev, port->phy_if);
+		if (!phy)
+			return -1;
+
+		phy_config(phy);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/lantiq_vrx200_switch.c b/drivers/net/lantiq_vrx200_switch.c
new file mode 100644
index 0000000000000000000000000000000000000000..dcd22660dc3f2e1c22e8efefc1ae7e2a85966d3e
--- /dev/null
+++ b/drivers/net/lantiq_vrx200_switch.c
@@ -0,0 +1,793 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010-2011 Lantiq Deutschland GmbH
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/eth.h>
+#include <asm/lantiq/pm.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/dma.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_ETHSW_MAC_CTRL0_PADEN		(1 << 8)
+#define LTQ_ETHSW_MAC_CTRL0_FCS			(1 << 7)
+#define LTQ_ETHSW_MAC_CTRL1_SHORTPRE		(1 << 8)
+#define LTQ_ETHSW_MAC_CTRL2_MLEN		(1 << 3)
+#define LTQ_ETHSW_MAC_CTRL2_LCHKL		(1 << 2)
+#define LTQ_ETHSW_MAC_CTRL2_LCHKS_DIS		0
+#define LTQ_ETHSW_MAC_CTRL2_LCHKS_UNTAG		1
+#define LTQ_ETHSW_MAC_CTRL2_LCHKS_TAG		2
+#define LTQ_ETHSW_MAC_CTRL6_RBUF_DLY_WP_SHIFT	9
+#define LTQ_ETHSW_MAC_CTRL6_RXBUF_BYPASS	(1 << 6)
+#define LTQ_ETHSW_GLOB_CTRL_SE			(1 << 15)
+#define LTQ_ETHSW_MDC_CFG1_MCEN			(1 << 8)
+#define LTQ_ETHSW_PMAC_HD_CTL_FC		(1 << 10)
+#define LTQ_ETHSW_PMAC_HD_CTL_RC		(1 << 4)
+#define LTQ_ETHSW_PMAC_HD_CTL_AC		(1 << 2)
+
+#define LTQ_ETH_RX_BUFFER_CNT		PKTBUFSRX
+
+#define LTQ_MDIO_DRV_NAME		"ltq-mdio"
+#define LTQ_ETH_DRV_NAME		"ltq-eth"
+
+#define LTQ_ETHSW_MAX_GMAC		6
+#define LTQ_ETHSW_PMAC			6
+
+struct ltq_ethsw_mac_pdi_x_regs {
+	u32	pstat;		/* Port status */
+	u32	pisr;		/* Interrupt status */
+	u32	pier;		/* Interrupt enable */
+	u32	ctrl_0;		/* Control 0 */
+	u32	ctrl_1;		/* Control 1 */
+	u32	ctrl_2;		/* Control 2 */
+	u32	ctrl_3;		/* Control 3 */
+	u32	ctrl_4;		/* Control 4 */
+	u32	ctrl_5;		/* Control 5 */
+	u32	ctrl_6;		/* Control 6 */
+	u32	bufst;		/* TX/RX buffer control */
+	u32	testen;		/* Test enable */
+};
+
+struct ltq_ethsw_mac_pdi_regs {
+	struct ltq_ethsw_mac_pdi_x_regs	mac[12];
+};
+
+struct ltq_ethsw_mdio_pdi_regs {
+	u32	glob_ctrl;	/* Global control 0 */
+	u32	rsvd0[7];
+	u32	mdio_ctrl;	/* MDIO control */
+	u32	mdio_read;	/* MDIO read data */
+	u32	mdio_write;	/* MDIO write data */
+	u32	mdc_cfg_0;	/* MDC clock configuration 0 */
+	u32	mdc_cfg_1;	/* MDC clock configuration 1 */
+	u32	rsvd[3];
+	u32	phy_addr_5;	/* PHY address port 5 */
+	u32	phy_addr_4;	/* PHY address port 4 */
+	u32	phy_addr_3;	/* PHY address port 3 */
+	u32	phy_addr_2;	/* PHY address port 2 */
+	u32	phy_addr_1;	/* PHY address port 1 */
+	u32	phy_addr_0;	/* PHY address port 0 */
+	u32	mdio_stat_0;	/* MDIO PHY polling status port 0 */
+	u32	mdio_stat_1;	/* MDIO PHY polling status port 1 */
+	u32	mdio_stat_2;	/* MDIO PHY polling status port 2 */
+	u32	mdio_stat_3;	/* MDIO PHY polling status port 3 */
+	u32	mdio_stat_4;	/* MDIO PHY polling status port 4 */
+	u32	mdio_stat_5;	/* MDIO PHY polling status port 5 */
+};
+
+struct ltq_ethsw_mii_pdi_regs {
+	u32	mii_cfg0;	/* xMII port 0 configuration */
+	u32	pcdu0;		/* Port 0 clock delay configuration */
+	u32	mii_cfg1;	/* xMII port 1 configuration */
+	u32	pcdu1;		/* Port 1 clock delay configuration */
+	u32	mii_cfg2;	/* xMII port 2 configuration */
+	u32	rsvd0;
+	u32	mii_cfg3;	/* xMII port 3 configuration */
+	u32	rsvd1;
+	u32	mii_cfg4;	/* xMII port 4 configuration */
+	u32	rsvd2;
+	u32	mii_cfg5;	/* xMII port 5 configuration */
+	u32	pcdu5;		/* Port 5 clock delay configuration */
+};
+
+struct ltq_ethsw_pmac_pdi_regs {
+	u32	hd_ctl;		/* PMAC header control */
+	u32	tl;		/* PMAC type/length */
+	u32	sa1;		/* PMAC source address 1 */
+	u32	sa2;		/* PMAC source address 2 */
+	u32	sa3;		/* PMAC source address 3 */
+	u32	da1;		/* PMAC destination address 1 */
+	u32	da2;		/* PMAC destination address 2 */
+	u32	da3;		/* PMAC destination address 3 */
+	u32	vlan;		/* PMAC VLAN */
+	u32	rx_ipg;		/* PMAC interpacket gap in RX direction */
+	u32	st_etype;	/* PMAC special tag ethertype */
+	u32	ewan;		/* PMAC ethernet WAN group */
+};
+
+struct ltq_mdio_phy_addr_reg {
+	union {
+		struct {
+			unsigned rsvd:1;
+			unsigned lnkst:2;	/* Link status control */
+			unsigned speed:2;	/* Speed control */
+			unsigned fdup:2;	/* Full duplex control */
+			unsigned fcontx:2;	/* Flow control mode TX */
+			unsigned fconrx:2;	/* Flow control mode RX */
+			unsigned addr:5;	/* PHY address */
+		} bits;
+		u16 val;
+	};
+};
+
+enum ltq_mdio_phy_addr_lnkst {
+	LTQ_MDIO_PHY_ADDR_LNKST_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_LNKST_UP = 1,
+	LTQ_MDIO_PHY_ADDR_LNKST_DOWN = 2,
+};
+
+enum ltq_mdio_phy_addr_speed {
+	LTQ_MDIO_PHY_ADDR_SPEED_M10 = 0,
+	LTQ_MDIO_PHY_ADDR_SPEED_M100 = 1,
+	LTQ_MDIO_PHY_ADDR_SPEED_G1 = 2,
+	LTQ_MDIO_PHY_ADDR_SPEED_AUTO = 3,
+};
+
+enum ltq_mdio_phy_addr_fdup {
+	LTQ_MDIO_PHY_ADDR_FDUP_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_FDUP_ENABLE = 1,
+	LTQ_MDIO_PHY_ADDR_FDUP_DISABLE = 3,
+};
+
+enum ltq_mdio_phy_addr_fcon {
+	LTQ_MDIO_PHY_ADDR_FCON_AUTO = 0,
+	LTQ_MDIO_PHY_ADDR_FCON_ENABLE = 1,
+	LTQ_MDIO_PHY_ADDR_FCON_DISABLE = 3,
+};
+
+struct ltq_mii_mii_cfg_reg {
+	union {
+		struct {
+			unsigned res:1;		/* Hardware reset */
+			unsigned en:1;		/* xMII interface enable */
+			unsigned isol:1;	/* xMII interface isolate */
+			unsigned ldclkdis:1;	/* Link down clock disable */
+			unsigned rsvd:1;
+			unsigned crs:2;		/* CRS sensitivity config */
+			unsigned rgmii_ibs:1;	/* RGMII In Band status */
+			unsigned rmii:1;	/* RMII ref clock direction */
+			unsigned miirate:3;	/* xMII interface clock rate */
+			unsigned miimode:4;	/* xMII interface mode */
+		} bits;
+		u16 val;
+	};
+};
+
+enum ltq_mii_mii_cfg_miirate {
+	LTQ_MII_MII_CFG_MIIRATE_M2P5 = 0,
+	LTQ_MII_MII_CFG_MIIRATE_M25 = 1,
+	LTQ_MII_MII_CFG_MIIRATE_M125 = 2,
+	LTQ_MII_MII_CFG_MIIRATE_M50 = 3,
+	LTQ_MII_MII_CFG_MIIRATE_AUTO = 4,
+};
+
+enum ltq_mii_mii_cfg_miimode {
+	LTQ_MII_MII_CFG_MIIMODE_MIIP = 0,
+	LTQ_MII_MII_CFG_MIIMODE_MIIM = 1,
+	LTQ_MII_MII_CFG_MIIMODE_RMIIP = 2,
+	LTQ_MII_MII_CFG_MIIMODE_RMIIM = 3,
+	LTQ_MII_MII_CFG_MIIMODE_RGMII = 4,
+};
+
+struct ltq_eth_priv {
+	struct ltq_dma_device *dma_dev;
+	struct mii_dev *bus;
+	struct eth_device *dev;
+	struct phy_device *phymap[LTQ_ETHSW_MAX_GMAC];
+	int rx_num;
+};
+
+enum ltq_mdio_mbusy {
+	LTQ_MDIO_MBUSY_IDLE = 0,
+	LTQ_MDIO_MBUSY_BUSY = 1,
+};
+
+enum ltq_mdio_op {
+	LTQ_MDIO_OP_WRITE = 1,
+	LTQ_MDIO_OP_READ = 2,
+};
+
+struct ltq_mdio_access {
+	union {
+		struct {
+			unsigned rsvd:3;
+			unsigned mbusy:1;
+			unsigned op:2;
+			unsigned phyad:5;
+			unsigned regad:5;
+		} bits;
+		u16 val;
+	};
+};
+
+static struct ltq_ethsw_mac_pdi_regs *ltq_ethsw_mac_pdi_regs =
+	(struct ltq_ethsw_mac_pdi_regs *) CKSEG1ADDR(LTQ_SWITCH_MAC_PDI_0_BASE);
+
+static struct ltq_ethsw_mdio_pdi_regs *ltq_ethsw_mdio_pdi_regs =
+	(struct ltq_ethsw_mdio_pdi_regs *) CKSEG1ADDR(LTQ_SWITCH_MDIO_PDI_BASE);
+
+static struct ltq_ethsw_mii_pdi_regs *ltq_ethsw_mii_pdi_regs =
+	(struct ltq_ethsw_mii_pdi_regs *) CKSEG1ADDR(LTQ_SWITCH_MII_PDI_BASE);
+
+static struct ltq_ethsw_pmac_pdi_regs *ltq_ethsw_pmac_pdi_regs =
+	(struct ltq_ethsw_pmac_pdi_regs *) CKSEG1ADDR(LTQ_SWITCH_PMAC_PDI_BASE);
+
+static inline int ltq_mdio_poll(struct mii_dev *bus)
+{
+	struct ltq_mdio_access acc;
+	unsigned cnt = 10000;
+
+	while (likely(cnt--)) {
+		acc.val = ltq_readl(&ltq_ethsw_mdio_pdi_regs->mdio_ctrl);
+		if (!acc.bits.mbusy)
+			return 0;
+	}
+
+	return 1;
+}
+
+static int ltq_mdio_read(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.bits.mbusy = LTQ_MDIO_MBUSY_BUSY;
+	acc.bits.op = LTQ_MDIO_OP_READ;
+	acc.bits.phyad = addr;
+	acc.bits.regad = regnum;
+
+	ret = ltq_mdio_poll(bus);
+	if (ret)
+		goto timeout;
+
+	ltq_writel(&ltq_ethsw_mdio_pdi_regs->mdio_ctrl, acc.val);
+
+	ret = ltq_mdio_poll(bus);
+	if (ret)
+		goto timeout;
+
+	ret = ltq_readl(&ltq_ethsw_mdio_pdi_regs->mdio_read);
+
+	return ret;
+
+timeout:
+	return -1;
+}
+
+static int ltq_mdio_write(struct mii_dev *bus, int addr, int dev_addr,
+				int regnum, u16 val)
+{
+	struct ltq_mdio_access acc;
+	int ret;
+
+	acc.val = 0;
+	acc.bits.mbusy = LTQ_MDIO_MBUSY_BUSY;
+	acc.bits.op = LTQ_MDIO_OP_WRITE;
+	acc.bits.phyad = addr;
+	acc.bits.regad = regnum;
+
+	ret = ltq_mdio_poll(bus);
+	if (ret)
+		return ret;
+
+	ltq_writel(&ltq_ethsw_mdio_pdi_regs->mdio_write, val);
+	ltq_writel(&ltq_ethsw_mdio_pdi_regs->mdio_ctrl, acc.val);
+
+	return 0;
+}
+
+static const void *ltq_eth_phy_addr_reg(int num)
+{
+	switch (num) {
+	case 0:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_0;
+	case 1:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_1;
+	case 2:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_2;
+	case 3:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_3;
+	case 4:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_4;
+	case 5:
+		return &ltq_ethsw_mdio_pdi_regs->phy_addr_5;
+	}
+
+	return NULL;
+}
+
+static const void *ltq_eth_mii_cfg_reg(int num)
+{
+	switch (num) {
+	case 0:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg0;
+	case 1:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg1;
+	case 2:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg2;
+	case 3:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg3;
+	case 4:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg4;
+	case 5:
+		return &ltq_ethsw_mii_pdi_regs->mii_cfg5;
+	}
+
+	return NULL;
+}
+
+static void ltq_eth_gmac_update(struct phy_device *phydev, int num)
+{
+	struct ltq_mdio_phy_addr_reg phy_addr_reg;
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+	const void *phy_addr = ltq_eth_phy_addr_reg(num);
+	const void *mii_cfg = ltq_eth_mii_cfg_reg(num);
+
+	phy_addr_reg.val = ltq_readl(phy_addr);
+	mii_cfg_reg.val = ltq_readl(mii_cfg);
+
+	phy_addr_reg.bits.addr = phydev->addr;
+
+	if (phydev->link)
+		phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_UP;
+	else
+		phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_DOWN;
+
+	switch (phydev->speed) {
+	case SPEED_1000:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_G1;
+		mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M125;
+		break;
+	case SPEED_100:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M100;
+		switch (mii_cfg_reg.bits.miimode) {
+		case LTQ_MII_MII_CFG_MIIMODE_RMIIM:
+		case LTQ_MII_MII_CFG_MIIMODE_RMIIP:
+			mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M50;
+			break;
+		default:
+			mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M25;
+			break;
+		}
+		break;
+	default:
+		phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M10;
+		mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M2P5;
+		break;
+	}
+
+	if (phydev->duplex == DUPLEX_FULL)
+		phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_ENABLE;
+	else
+		phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_DISABLE;
+
+	ltq_writel(phy_addr, phy_addr_reg.val);
+	ltq_writel(mii_cfg, mii_cfg_reg.val);
+}
+
+static int ltq_eth_init(struct eth_device *dev, bd_t * bis)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	struct phy_device *phydev;
+	int i, ret;
+
+	for (i = 0; i < LTQ_ETHSW_MAX_GMAC; i++) {
+		phydev = priv->phymap[i];
+		if (!phydev)
+			continue;
+
+		phy_startup(phydev);
+		ltq_eth_gmac_update(phydev, i);
+	}
+
+	for (i = 0; i < LTQ_ETH_RX_BUFFER_CNT; i++) {
+		ret = ltq_dma_map_rx(priv->dma_dev, i,
+					(void *) NetRxPackets[i],
+					PKTSIZE_ALIGN);
+		if (ret)
+			return ret;
+
+		ret = ltq_dma_read(priv->dma_dev, i);
+		if (ret)
+			return ret;
+	}
+
+	priv->rx_num = 0;
+
+	return 0;
+}
+
+static void ltq_eth_halt(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+
+	ltq_dma_reset(priv->dma_dev);
+}
+
+static int ltq_eth_send(struct eth_device *dev, volatile void *packet,
+			int length)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	int ret;
+
+	/* Minimum payload length w/ CRC is 60 bytes */
+	if (length < 60)
+		length = 60;
+
+	ret = ltq_dma_map_tx(priv->dma_dev, 0, (void *) packet, length);
+	if (ret)
+		return ret;
+
+	flush_dcache_range((ulong) packet, (ulong) packet + length);
+
+	ret = ltq_dma_write(priv->dma_dev, 0);
+
+	return ret;
+}
+
+static int ltq_eth_recv(struct eth_device *dev)
+{
+	struct ltq_eth_priv *priv = dev->priv;
+	int len;
+
+	for (;;) {
+		len = ltq_dma_read_poll(priv->dma_dev, priv->rx_num);
+		if (!len)
+			return 0;
+
+		invalidate_dcache_range((ulong) NetRxPackets[priv->rx_num],
+				(ulong) NetRxPackets[priv->rx_num] + len);
+
+		NetReceive(NetRxPackets[priv->rx_num], len);
+
+		ltq_dma_map_rx(priv->dma_dev, priv->rx_num,
+				(void *) NetRxPackets[priv->rx_num],
+				PKTSIZE_ALIGN);
+		ltq_dma_read(priv->dma_dev, priv->rx_num);
+
+		priv->rx_num = (priv->rx_num + 1) % LTQ_ETH_RX_BUFFER_CNT;
+	};
+
+	return 0;
+}
+
+static void ltq_eth_gmac_init(int num)
+{
+	struct ltq_mdio_phy_addr_reg phy_addr_reg;
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+	const void *phy_addr = ltq_eth_phy_addr_reg(num);
+	const void *mii_cfg = ltq_eth_mii_cfg_reg(num);
+	struct ltq_ethsw_mac_pdi_x_regs *mac_pdi_regs;
+
+	mac_pdi_regs = &ltq_ethsw_mac_pdi_regs->mac[num];
+
+	/* Reset PHY status to link down */
+	phy_addr_reg.val = ltq_readl(phy_addr);
+	phy_addr_reg.bits.addr = num;
+	phy_addr_reg.bits.lnkst = LTQ_MDIO_PHY_ADDR_LNKST_DOWN;
+	phy_addr_reg.bits.speed = LTQ_MDIO_PHY_ADDR_SPEED_M10;
+	phy_addr_reg.bits.fdup = LTQ_MDIO_PHY_ADDR_FDUP_DISABLE;
+	ltq_writel(phy_addr, phy_addr_reg.val);
+
+	/* Reset and disable MII interface */
+	mii_cfg_reg.val = ltq_readl(mii_cfg);
+	mii_cfg_reg.bits.en = 0;
+	mii_cfg_reg.bits.res = 1;
+	mii_cfg_reg.bits.miirate = LTQ_MII_MII_CFG_MIIRATE_M2P5;
+	ltq_writel(mii_cfg, mii_cfg_reg.val);
+
+	/* TODO: make configurable */
+#ifdef CONFIG_BOARD_SPH_ISDN_SIP_GATEWAY
+	if (num == 5) {
+		/* Set TX delay to 3 * 500 psec */
+		ltq_writel(&ltq_ethsw_mii_pdi_regs->pcdu5, 3);
+	}
+#endif
+
+	/*
+	 * Enable padding of short frames, enable frame checksum generation
+	 * in transmit direction
+	 */
+	ltq_writel(&mac_pdi_regs->ctrl_0, LTQ_ETHSW_MAC_CTRL0_PADEN |
+			LTQ_ETHSW_MAC_CTRL0_FCS);
+
+	/* Set inter packet gap size to 12 bytes */
+	ltq_writel(&mac_pdi_regs->ctrl_1, 12);
+
+	/*
+	 * Configure frame length checks:
+	 * - allow jumbo frames
+	 * - enable long length check
+	 * - enable short length without VLAN tags
+	 */
+	ltq_writel(&mac_pdi_regs->ctrl_2, LTQ_ETHSW_MAC_CTRL2_MLEN |
+			LTQ_ETHSW_MAC_CTRL2_LCHKL |
+			LTQ_ETHSW_MAC_CTRL2_LCHKS_UNTAG);
+}
+
+static void ltq_eth_pmac_init(void)
+{
+	struct ltq_ethsw_mac_pdi_x_regs *mac_pdi_regs;
+
+	mac_pdi_regs = &ltq_ethsw_mac_pdi_regs->mac[LTQ_ETHSW_PMAC];
+
+	/*
+	 * Enable padding of short frames, enable frame checksum generation
+	 * in transmit direction
+	 */
+	ltq_writel(&mac_pdi_regs->ctrl_0, LTQ_ETHSW_MAC_CTRL0_PADEN |
+			LTQ_ETHSW_MAC_CTRL0_FCS);
+
+	/*
+	 * Configure frame length checks:
+	 * - allow jumbo frames
+	 * - enable long length check
+	 * - enable short length without VLAN tags
+	 */
+	ltq_writel(&mac_pdi_regs->ctrl_2, LTQ_ETHSW_MAC_CTRL2_MLEN |
+			LTQ_ETHSW_MAC_CTRL2_LCHKL |
+			LTQ_ETHSW_MAC_CTRL2_LCHKS_UNTAG);
+
+	/*
+	 * Apply workaround for buffer congestion:
+	 * - shorten preambel to 1 byte
+	 * - set minimum inter packet gap size to 7 bytes
+	 * - enable receive buffer bypass mode
+	 */
+	ltq_writel(&mac_pdi_regs->ctrl_1, LTQ_ETHSW_MAC_CTRL1_SHORTPRE | 7);
+	ltq_writel(&mac_pdi_regs->ctrl_6,
+			(6 << LTQ_ETHSW_MAC_CTRL6_RBUF_DLY_WP_SHIFT) |
+			LTQ_ETHSW_MAC_CTRL6_RXBUF_BYPASS);
+
+	/* Set request assertion threshold to 8, IPG counter to 11 */
+	ltq_writel(&ltq_ethsw_pmac_pdi_regs->rx_ipg, 0x8B);
+
+	/*
+	 * Configure frame header control:
+	 * - enable reaction on pause frames (flow control)
+	 * - remove CRC for packets from PMAC to DMA
+	 * - add CRC for packets from DMA to PMAC
+	 */
+	ltq_writel(&ltq_ethsw_pmac_pdi_regs->hd_ctl, LTQ_ETHSW_PMAC_HD_CTL_FC |
+			LTQ_ETHSW_PMAC_HD_CTL_RC | LTQ_ETHSW_PMAC_HD_CTL_AC);
+}
+
+static void ltq_eth_hw_init(void)
+{
+	int i;
+
+	/* Power up ethernet and switch subsystems */
+	ltq_pm_enable(LTQ_PM_ETH);
+
+	/* Reset ethernet and switch subsystems */
+	ltq_reset_once(LTQ_RESET_ETH, 10);
+
+	/* Enable switch macro */
+	ltq_setbits(&ltq_ethsw_mdio_pdi_regs->glob_ctrl,
+		LTQ_ETHSW_GLOB_CTRL_SE);
+
+	/* Disable MDIO auto-polling for all ports */
+	ltq_writel(&ltq_ethsw_mdio_pdi_regs->mdc_cfg_0, 0);
+
+	/*
+	 * Enable and set MDIO management clock to 2.5 MHz. This is the
+	 * maximum clock for FE PHYs.
+	 * Formula for clock is:
+	 *
+	 *      50 MHz
+	 * x = ----------- - 1
+	 *      2 * f_MDC
+	 */
+	ltq_writel(&ltq_ethsw_mdio_pdi_regs->mdc_cfg_1,
+		LTQ_ETHSW_MDC_CFG1_MCEN | 9);
+
+	/* Init MAC connected to CPU  */
+	ltq_eth_pmac_init();
+
+	/* Init MACs connected to external MII interfaces */
+	for (i = 0; i < LTQ_ETHSW_MAX_GMAC; i++)
+		ltq_eth_gmac_init(i);
+}
+
+static void ltq_eth_port_config(struct ltq_eth_priv *priv,
+					const struct ltq_eth_port_config *port)
+{
+	struct ltq_mii_mii_cfg_reg mii_cfg_reg;
+	const void *mii_cfg = ltq_eth_mii_cfg_reg(port->num);
+	struct phy_device *phydev;
+	int setup_gpio = 0;
+
+	mii_cfg_reg.val = ltq_readl(mii_cfg);
+
+	switch (port->num) {
+	case 0:	/* xMII0 */
+	case 1:	/* xMII1 */
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+			if (port->flags & LTQ_ETH_PORT_PHY)
+				/* MII MAC mode, connected to external PHY */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_MIIM;
+			else
+				/* MII PHY mode, connected to external MAC */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_MIIP;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RMII:
+			if (port->flags & LTQ_ETH_PORT_PHY)
+				/* RMII MAC mode, connected to external PHY */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_RMIIM;
+			else
+				/* RMII PHY mode, connected to external MAC */
+				mii_cfg_reg.bits.miimode =
+					LTQ_MII_MII_CFG_MIIMODE_RMIIP;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			/* RGMII MAC mode, connected to external PHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_RGMII;
+			setup_gpio = 1;
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:	/* internal GPHY0 */
+	case 3:	/* internal GPHY0 */
+	case 4:	/* internal GPHY1 */
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+		case PHY_INTERFACE_MODE_GMII:
+			/* MII MAC mode, connected to internal GPHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_MIIM;
+			setup_gpio = 1;
+			break;
+		default:
+			break;
+		}
+		break;
+	case 5:	/* internal GPHY1 or xMII2 */
+		switch (port->phy_if) {
+		case PHY_INTERFACE_MODE_MII:
+			/* MII MAC mode, connected to internal GPHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_MIIM;
+			setup_gpio = 1;
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			/* RGMII MAC mode, connected to external PHY */
+			mii_cfg_reg.bits.miimode =
+				LTQ_MII_MII_CFG_MIIMODE_RGMII;
+			setup_gpio = 1;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* Enable MII interface */
+	mii_cfg_reg.bits.en = port->flags ? 1 : 0;
+	ltq_writel(mii_cfg, mii_cfg_reg.val);
+
+	/* Setup GPIOs for MII with external PHYs/MACs */
+	if (setup_gpio) {
+		/* MII/MDIO */
+		gpio_set_altfunc(42, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR,
+					GPIO_DIR_OUT);
+		/* MII/MDC */
+		gpio_set_altfunc(43, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR,
+					GPIO_DIR_OUT);
+	}
+
+	/* Connect to internal/external PHYs */
+	if (port->flags & LTQ_ETH_PORT_PHY) {
+		phydev = phy_connect(priv->bus, port->phy_addr, priv->dev,
+					port->phy_if);
+		if (phydev)
+			phy_config(phydev);
+
+		priv->phymap[port->num] = phydev;
+	}
+}
+
+int ltq_eth_initialize(const struct ltq_eth_board_config *board_config)
+{
+	struct eth_device *dev;
+	struct mii_dev *bus;
+	struct ltq_eth_priv *priv;
+	struct ltq_dma_device *dma_dev;
+	int i, ret;
+
+	ltq_dma_init();
+	ltq_eth_hw_init();
+
+	dev = calloc(1, sizeof(struct eth_device));
+	if (!dev)
+		return -1;
+
+	priv = calloc(1, sizeof(struct ltq_eth_priv));
+	if (!priv)
+		return -1;
+
+	bus = mdio_alloc();
+	if (!bus)
+		return -1;
+
+	dma_dev = ltq_dma_alloc();
+	if (!dma_dev)
+		return -1;
+
+	sprintf(dev->name, LTQ_ETH_DRV_NAME);
+	dev->priv = priv;
+	dev->init = ltq_eth_init;
+	dev->halt = ltq_eth_halt;
+	dev->recv = ltq_eth_recv;
+	dev->send = ltq_eth_send;
+
+	sprintf(bus->name, LTQ_MDIO_DRV_NAME);
+	bus->read = ltq_mdio_read;
+	bus->write = ltq_mdio_write;
+	bus->priv = priv;
+
+	dma_dev->port = 0;
+	dma_dev->rx_chan.chan_no = 0;
+	dma_dev->rx_chan.class = 0;
+	dma_dev->rx_chan.num_desc = LTQ_ETH_RX_BUFFER_CNT;
+	dma_dev->rx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->tx_chan.chan_no = 1;
+	dma_dev->tx_chan.class = 0;
+	dma_dev->tx_chan.num_desc = 1;
+	dma_dev->tx_endian_swap = LTQ_DMA_ENDIANESS_B3_B2_B1_B0;
+	dma_dev->priv = priv;
+
+	priv->dma_dev = dma_dev;
+	priv->bus = bus;
+	priv->dev = dev;
+
+	ret = ltq_dma_register(dma_dev);
+	if (ret)
+		return -1;
+
+	ret = mdio_register(bus);
+	if (ret)
+		return -1;
+
+	ret = eth_register(dev);
+	if (ret)
+		return -1;
+
+	for (i = 0; i < board_config->num_ports; i++)
+		ltq_eth_port_config(priv, &board_config->ports[i]);
+
+	return 0;
+}
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index feced39a4252b65d9e8e3a548cc30be216a04534..e41d2cb3704b3c379b29c9d365313a6eecd46578 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -33,6 +33,7 @@ COBJS-$(CONFIG_PHYLIB_10G) += generic_10g.o
 COBJS-$(CONFIG_PHY_ATHEROS) += atheros.o
 COBJS-$(CONFIG_PHY_BROADCOM) += broadcom.o
 COBJS-$(CONFIG_PHY_DAVICOM) += davicom.o
+COBJS-$(CONFIG_PHY_LANTIQ) += lantiq.o
 COBJS-$(CONFIG_PHY_LXT) += lxt.o
 COBJS-$(CONFIG_PHY_MARVELL) += marvell.o
 COBJS-$(CONFIG_PHY_MICREL) += micrel.o
diff --git a/drivers/net/phy/lantiq.c b/drivers/net/phy/lantiq.c
new file mode 100644
index 0000000000000000000000000000000000000000..380590996b40ba15c9c3941ba8e473ce1be69fdd
--- /dev/null
+++ b/drivers/net/phy/lantiq.c
@@ -0,0 +1,207 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <miiphy.h>
+
+#define ADVERTIZE_MPD		(1 << 10)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * Update link status.
+ *
+ * Based on genphy_update_link in phylib.c
+ */
+static int ltq_phy_update_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	/*
+	 * If we already saw the link up, and it hasn't gone down, then
+	 * we don't need to wait for autoneg again
+	 */
+	if (phydev->link && mii_reg & BMSR_LSTATUS)
+		return 0;
+
+	if ((mii_reg & BMSR_ANEGCAPABLE) && !(mii_reg & BMSR_ANEGCOMPLETE)) {
+		phydev->link = 0;
+		return 0;
+	} else {
+		/* Read the link a second time to clear the latched state */
+		mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+		if (mii_reg & BMSR_LSTATUS)
+			phydev->link = 1;
+		else
+			phydev->link = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Update speed and duplex.
+ *
+ * Based on genphy_parse_link in phylib.c
+ */
+static int ltq_phy_parse_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	/* We're using autonegotiation */
+	if (mii_reg & BMSR_ANEGCAPABLE) {
+		u32 lpa = 0;
+		u32 gblpa = 0;
+
+		/* Check for gigabit capability */
+		if (mii_reg & BMSR_ERCAP) {
+			/* We want a list of states supported by
+			 * both PHYs in the link
+			 */
+			gblpa = phy_read(phydev, MDIO_DEVAD_NONE, MII_STAT1000);
+			gblpa &= phy_read(phydev,
+					MDIO_DEVAD_NONE, MII_CTRL1000) << 2;
+		}
+
+		/* Set the baseline so we only have to set them
+		 * if they're different
+		 */
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_HALF;
+
+		/* Check the gigabit fields */
+		if (gblpa & (PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD)) {
+			phydev->speed = SPEED_1000;
+
+			if (gblpa & PHY_1000BTSR_1000FD)
+				phydev->duplex = DUPLEX_FULL;
+
+			/* We're done! */
+			return 0;
+		}
+
+		lpa = phy_read(phydev, MDIO_DEVAD_NONE, MII_ADVERTISE);
+		lpa &= phy_read(phydev, MDIO_DEVAD_NONE, MII_LPA);
+
+		if (lpa & (LPA_100FULL | LPA_100HALF)) {
+			phydev->speed = SPEED_100;
+
+			if (lpa & LPA_100FULL)
+				phydev->duplex = DUPLEX_FULL;
+
+		} else if (lpa & LPA_10FULL)
+			phydev->duplex = DUPLEX_FULL;
+	} else {
+		u32 bmcr = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
+
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_HALF;
+
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
+
+		if (bmcr & BMCR_SPEED1000)
+			phydev->speed = SPEED_1000;
+		else if (bmcr & BMCR_SPEED100)
+			phydev->speed = SPEED_100;
+	}
+
+	return 0;
+}
+
+static int ltq_phy_config(struct phy_device *phydev)
+{
+	u16 val;
+
+	/* Advertise as Multi-port device */
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MII_CTRL1000);
+	val |= ADVERTIZE_MPD;
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, val);
+
+	genphy_config_aneg(phydev);
+
+	return 0;
+}
+
+static int ltq_phy_startup(struct phy_device *phydev)
+{
+	/*
+	 * Update PHY status immediately without any delays as genphy_startup
+	 * does because VRX200 switch needs to be configured dependent
+	 * on this information.
+	 */
+	ltq_phy_update_link(phydev);
+	ltq_phy_parse_link(phydev);
+
+	debug("ltq_phy: addr %d, link %d, speed %d, duplex %d\n",
+		phydev->addr, phydev->link, phydev->speed, phydev->duplex);
+
+	return 0;
+}
+
+static struct phy_driver pef7071_13_driver = {
+	.name = "Lantiq XWAY PHY11G v1.3 and earlier",
+	.uid = 0x030260D1,
+	.mask = 0xFFFFFFF0,
+	.features = PHY_GBIT_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver pef7071_14_driver = {
+	.name = "Lantiq XWAY PHY11G v1.4 and later",
+	.uid = 0xd565a408,
+	.mask = 0xFFFFFFF0,
+	.features = PHY_GBIT_FEATURES,
+	.config = ltq_phy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+static struct phy_driver vrx200_genphy_driver = {
+	.name = "Generic PHY at Lantiq XWAY VRX200 switch",
+	.uid = 0,
+	.mask = 0,
+	.features = 0,
+	.config = genphy_config,
+	.startup = ltq_phy_startup,
+	.shutdown = genphy_shutdown,
+};
+
+int phy_lantiq_init(void)
+{
+#ifdef CONFIG_NEEDS_MANUAL_RELOC
+	pef7071_13_driver.config = ltq_phy_config;
+	pef7071_13_driver.startup = ltq_phy_startup;
+	pef7071_13_driver.shutdown = genphy_shutdown;
+	pef7071_13_driver.name += gd->reloc_off;
+
+	pef7071_14_driver.config = ltq_phy_config;
+	pef7071_14_driver.startup = ltq_phy_startup;
+	pef7071_14_driver.shutdown = genphy_shutdown;
+	pef7071_14_driver.name += gd->reloc_off;
+
+	vrx200_genphy_driver.config = genphy_config;
+	vrx200_genphy_driver.startup = ltq_phy_startup;
+	vrx200_genphy_driver.shutdown = genphy_shutdown;
+	vrx200_genphy_driver.name += gd->reloc_off;
+#endif
+
+	phy_register(&pef7071_13_driver);
+	phy_register(&pef7071_14_driver);
+	phy_register(&vrx200_genphy_driver);
+
+	return 0;
+}
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index eb551803e5c749dbcdafb1ed2f0f000f620741e4..4883b4c4318ee7f0e498f102bafe8865e1b96fb8 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -32,6 +32,8 @@
 #include <phy.h>
 #include <errno.h>
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /* Generic PHY support and helper functions */
 
 /**
@@ -420,6 +422,16 @@ static LIST_HEAD(phy_drivers);
 
 int phy_init(void)
 {
+#ifdef CONFIG_NEEDS_MANUAL_RELOC
+	INIT_LIST_HEAD(&phy_drivers);
+
+	genphy_driver.config = genphy_config;
+	genphy_driver.startup = genphy_startup;
+	genphy_driver.shutdown = genphy_shutdown;
+
+	genphy_driver.name += gd->reloc_off;
+#endif
+
 #ifdef CONFIG_PHY_ATHEROS
 	phy_atheros_init();
 #endif
@@ -429,6 +441,9 @@ int phy_init(void)
 #ifdef CONFIG_PHY_DAVICOM
 	phy_davicom_init();
 #endif
+#ifdef CONFIG_PHY_LANTIQ
+	phy_lantiq_init();
+#endif
 #ifdef CONFIG_PHY_LXT
 	phy_lxt_init();
 #endif
diff --git a/drivers/net/switch/Makefile b/drivers/net/switch/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..c9565443677fd87a75201ba0052c80b267863d97
--- /dev/null
+++ b/drivers/net/switch/Makefile
@@ -0,0 +1,33 @@
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Copyright (C) 2000-2011 Wolfgang Denk, DENX Software Engineering, wd@denx.de
+# Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libswitch.o
+
+COBJS-$(CONFIG_SWITCH_MULTI) += switch.o
+COBJS-$(CONFIG_SWITCH_PSB697X) += psb697x.o
+COBJS-$(CONFIG_SWITCH_ADM6996I) += adm6996i.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/net/switch/adm6996i.c b/drivers/net/switch/adm6996i.c
new file mode 100644
index 0000000000000000000000000000000000000000..53d5a4413bb76a29874cc58a34533818f36a89d6
--- /dev/null
+++ b/drivers/net/switch/adm6996i.c
@@ -0,0 +1,116 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <switch.h>
+#include <miiphy.h>
+
+#define ADM6996I_CHIPID0	0x1020
+#define ADM6996I_CHIPID1	0x0007
+#define ADM6996I_PORT_COUNT	6
+
+#define ADM6996I_REG_P0BC	0x001	/* P0 Basic Control */
+#define ADM6996I_REG_P1BC	0x003	/* P1 Basic Control */
+#define ADM6996I_REG_P2BC	0x005	/* P2 Basic Control */
+#define ADM6996I_REG_P3BC	0x007	/* P3 Basic Control */
+#define ADM6996I_REG_P4BC	0x008	/* P4 Basic Control */
+#define ADM6996I_REG_P5BC	0x009	/* P5 Basic Control */
+
+#define ADM6996I_REG_P0EC	0x002	/* P0 Extended Control */
+#define ADM6996I_REG_P1EC	0x002	/* P1 Extended Control */
+#define ADM6996I_REG_P2EC	0x004	/* P2 Extended Control */
+#define ADM6996I_REG_P3EC	0x004	/* P3 Extended Control */
+#define ADM6996I_REG_P4EC	0x006	/* P4 Extended Control */
+#define ADM6996I_REG_P5EC	0x006	/* P5 Extended Control */
+
+#define ADM6996I_REG_SC4	0x012	/* System Control 4 */
+
+#define ADM6996I_REG_CI0	0xA0	/* Chip Identifier 0 */
+#define ADM6996I_REG_CI1	0xA1	/* Chip Identifier 1 */
+
+#define ADM6996I_REG_PXBC_DEFAULT	0x040F
+#define ADM6996I_REG_PXBC_CROSS_EE	(1 << 15)
+#define ADM6996I_REG_PXBC_PD		(1 << 5)
+
+#define ADM6996I_REG_SC4_DEFAULT	0x3600
+#define ADM6996I_REG_SC4_LED_ENABLE	(1 << 1)
+
+#define ADM6996I_REG_CI0_PC_MASK	0xFFF0
+#define ADM6996I_REG_CI0_VN_MASK	0xF
+#define ADM6996I_REG_CI1_PC_MASK	0xF
+
+
+static inline int adm6996i_mii_read(struct mii_dev *bus, u16 reg)
+{
+	int ret;
+
+	ret = bus->read(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE, reg & 0x1f);
+
+	return ret;
+}
+
+static inline int adm6996i_mii_write(struct mii_dev *bus, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = bus->write(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE,
+		reg & 0x1f, val);
+
+	return ret;
+}
+
+static int adm6996i_probe(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	u16 ci0, ci1;
+
+	ci0 = adm6996i_mii_read(bus, ADM6996I_REG_CI0);
+	ci1 = adm6996i_mii_read(bus, ADM6996I_REG_CI1);
+
+	ci0 &= ADM6996I_REG_CI0_PC_MASK;
+	ci1 &= ADM6996I_REG_CI1_PC_MASK;
+
+	if (ci0 == ADM6996I_CHIPID0 && ci1 == ADM6996I_CHIPID1)
+		return 0;
+
+	return 1;
+}
+
+static void adm6996i_setup(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	u16 val;
+
+	/*
+	 * Write default values (Port enable, 100 Mbps, Full Duplex,
+	 * Auto negotiation, Flow control) and enable crossover auto-detect
+	 */
+	val = ADM6996I_REG_PXBC_DEFAULT | ADM6996I_REG_PXBC_CROSS_EE;
+	adm6996i_mii_write(bus, ADM6996I_REG_P0BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P1BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P2BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P3BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P4BC, val);
+	adm6996i_mii_write(bus, ADM6996I_REG_P5BC, val);
+
+	val = ADM6996I_REG_SC4_DEFAULT | ADM6996I_REG_SC4_LED_ENABLE;
+	adm6996i_mii_write(bus, ADM6996I_REG_SC4, val);
+}
+
+static struct switch_driver adm6996i_drv = {
+	.name = "adm6996i",
+};
+
+void switch_adm6996i_init(void)
+{
+	/* For archs with manual relocation */
+	adm6996i_drv.probe = adm6996i_probe;
+	adm6996i_drv.setup = adm6996i_setup;
+
+	switch_driver_register(&adm6996i_drv);
+}
diff --git a/drivers/net/switch/psb697x.c b/drivers/net/switch/psb697x.c
new file mode 100644
index 0000000000000000000000000000000000000000..0d47b08db5cd241f70b201a422655227e0ef1d52
--- /dev/null
+++ b/drivers/net/switch/psb697x.c
@@ -0,0 +1,119 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <switch.h>
+#include <miiphy.h>
+
+#define PSB697X_CHIPID1		0x2599
+#define PSB697X_PORT_COUNT	7
+
+#define PSB697X_PORT_BASE(p)	(p * 0x20)
+#define PSB697X_REG_PS(p)	(PSB697X_PORT_BASE(p) + 0x00)
+#define PSB697X_REG_PBC(p)	(PSB697X_PORT_BASE(p) + 0x01)
+#define PSB697X_REG_PEC(p)	(PSB697X_PORT_BASE(p) + 0x02)
+
+#define PSB697X_REG_SGC1	0x0E0	/* Switch Global Control Register 1 */
+#define PSB697X_REG_SGC2	0x0E1	/* Switch Global Control Register 2 */
+#define PSB697X_REG_CMH		0x0E2	/* CPU Port & Mirror Control */
+#define PSB697X_REG_MIICR	0x0F5	/* MII Port Control */
+#define PSB697X_REG_CI0		0x100	/* Chip Identifier 0 */
+#define PSB697X_REG_CI1		0x101	/* Chip Identifier 1 */
+#define PSB697X_REG_MIIAC	0x120	/* MII Indirect Access Control */
+#define PSB697X_REG_MIIWD	0x121	/* MII Indirect Write Data */
+#define PSB697X_REG_MIIRD	0x122	/* MII Indirect Read Data */
+
+#define PSB697X_REG_PORT_FLP	(1 << 2)	/* Force link up */
+#define PSB697X_REG_PORT_FLD	(1 << 1)	/* Force link down */
+
+#define PSB697X_REG_SGC2_SE	(1 << 15)	/* Switch enable */
+
+#define PSB697X_REG_CMH_CPN_MASK	0x7
+#define PSB697X_REG_CMH_CPN_SHIFT	5
+
+
+static inline int psb697x_mii_read(struct mii_dev *bus, u16 reg)
+{
+	int ret;
+
+	ret = bus->read(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE, reg & 0x1f);
+
+	return ret;
+}
+
+static inline int psb697x_mii_write(struct mii_dev *bus, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = bus->write(bus, (reg >> 5) & 0x1f, MDIO_DEVAD_NONE,
+		reg & 0x1f, val);
+
+	return ret;
+}
+
+static int psb697x_probe(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	int ci1;
+
+	ci1 = psb697x_mii_read(bus, PSB697X_REG_CI1);
+
+	if (ci1 == PSB697X_CHIPID1)
+		return 0;
+
+	return 1;
+}
+
+static void psb697x_setup(struct switch_device *dev)
+{
+	struct mii_dev *bus = dev->bus;
+	int i, state;
+
+	/* Enable switch */
+	psb697x_mii_write(bus, PSB697X_REG_SGC2, PSB697X_REG_SGC2_SE);
+
+	/*
+	 * Force 100 Mbps as default value for CPU ports 5 and 6 to get
+	 * full speed.
+	 */
+	psb697x_mii_write(bus, PSB697X_REG_MIICR, 0x0773);
+
+	for (i = 0; i < PSB697X_PORT_COUNT; i++) {
+		state = dev->port_mask & (1 << i);
+
+		/*
+		 * Software workaround from Errata Sheet:
+		 * Force link down and reset internal PHY, keep that state
+		 * for all unconnected ports and disable force link down
+		 * for all connected ports
+		 */
+		psb697x_mii_write(bus, PSB697X_REG_PBC(i),
+			PSB697X_REG_PORT_FLD);
+
+		if (i == dev->cpu_port)
+			/* Force link up for CPU port */
+			psb697x_mii_write(bus, PSB697X_REG_PBC(i),
+				PSB697X_REG_PORT_FLP);
+		else if (state)
+			/* Disable force link down for active LAN ports */
+			psb697x_mii_write(bus, PSB697X_REG_PBC(i), 0);
+	}
+}
+
+static struct switch_driver psb697x_drv = {
+	.name = "psb697x",
+};
+
+void switch_psb697x_init(void)
+{
+	/* For archs with manual relocation */
+	psb697x_drv.probe = psb697x_probe;
+	psb697x_drv.setup = psb697x_setup;
+
+	switch_driver_register(&psb697x_drv);
+}
diff --git a/drivers/net/switch/switch.c b/drivers/net/switch/switch.c
new file mode 100644
index 0000000000000000000000000000000000000000..9e2ddbb2be3c934b75922116086c7201cfa9d315
--- /dev/null
+++ b/drivers/net/switch/switch.c
@@ -0,0 +1,70 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <miiphy.h>
+#include <switch.h>
+
+static struct list_head switch_drivers;
+static struct list_head switch_devices;
+
+void switch_init(void)
+{
+	INIT_LIST_HEAD(&switch_drivers);
+	INIT_LIST_HEAD(&switch_devices);
+
+#if defined(CONFIG_SWITCH_PSB697X)
+	switch_psb697x_init();
+#endif
+#if defined(CONFIG_SWITCH_ADM6996I)
+	switch_adm6996i_init();
+#endif
+
+	board_switch_init();
+}
+
+void switch_driver_register(struct switch_driver *drv)
+{
+	INIT_LIST_HEAD(&drv->list);
+	list_add_tail(&drv->list, &switch_drivers);
+}
+
+int switch_device_register(struct switch_device *dev)
+{
+	struct switch_driver *drv;
+
+	/* Add switch device only, if an adequate driver is registered */
+	list_for_each_entry(drv, &switch_drivers, list) {
+		if (!strcmp(drv->name, dev->name)) {
+			dev->drv = drv;
+
+			INIT_LIST_HEAD(&dev->list);
+			list_add_tail(&dev->list, &switch_devices);
+
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+struct switch_device *switch_connect(struct mii_dev *bus)
+{
+	struct switch_device *sw;
+	int err;
+
+	list_for_each_entry(sw, &switch_devices, list) {
+		sw->bus = bus;
+
+		err = sw->drv->probe(sw);
+		if (!err)
+			return sw;
+	}
+
+	return NULL;
+}
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 616b85703b29b3dd82ce50be9b65d10f20664f88..3c7a45920a9fd26f7b9eb01af3e4f8f8b9d87210 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -41,6 +41,7 @@ COBJS-$(CONFIG_CLPS7111_SERIAL) += serial_clps7111.o
 COBJS-$(CONFIG_IMX_SERIAL) += serial_imx.o
 COBJS-$(CONFIG_IXP_SERIAL) += serial_ixp.o
 COBJS-$(CONFIG_KS8695_SERIAL) += serial_ks8695.o
+COBJS-$(CONFIG_LANTIQ_SERIAL) += serial_lantiq.o
 COBJS-$(CONFIG_LPC2292_SERIAL) += serial_lpc2292.o
 COBJS-$(CONFIG_LH7A40X_SERIAL) += serial_lh7a40x.o
 COBJS-$(CONFIG_MAX3100_SERIAL) += serial_max3100.o
diff --git a/drivers/serial/serial_lantiq.c b/drivers/serial/serial_lantiq.c
new file mode 100644
index 0000000000000000000000000000000000000000..5f3a78f264514f949de6fea3ac13b8ab3a3f81a7
--- /dev/null
+++ b/drivers/serial/serial_lantiq.c
@@ -0,0 +1,247 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#if CONFIG_CONSOLE_ASC == 0
+#define LTQ_ASC_BASE			LTQ_ASC0_BASE
+#else
+#define LTQ_ASC_BASE			LTQ_ASC1_BASE
+#endif
+
+#define LTQ_ASC_ID_TXFS_SHIFT		24
+#define LTQ_ASC_ID_TXFS_MASK		(0x3F << LTQ_ASC_ID_TXFS_SHIFT)
+#define LTQ_ASC_ID_RXFS_SHIFT		16
+#define LTQ_ASC_ID_RXFS_MASK		(0x3F << LTQ_ASC_ID_RXFS_SHIFT)
+
+#define LTQ_ASC_MCON_R			(1 << 15)
+#define LTQ_ASC_MCON_FDE		(1 << 9)
+
+#define LTQ_ASC_WHBSTATE_SETREN		(1 << 1)
+#define LTQ_ASC_WHBSTATE_CLRREN		(1 << 0)
+
+#define LTQ_ASC_RXFCON_RXFITL_SHIFT	8
+#define LTQ_ASC_RXFCON_RXFITL_MASK	(0x3F << LTQ_ASC_RXFCON_RXFITL_SHIFT)
+#define LTQ_ASC_RXFCON_RXFITL_RXFFLU	(1 << 1)
+#define LTQ_ASC_RXFCON_RXFITL_RXFEN	(1 << 0)
+
+#define LTQ_ASC_TXFCON_TXFITL_SHIFT	8
+#define LTQ_ASC_TXFCON_TXFITL_MASK	(0x3F << LTQ_ASC_TXFCON_TXFITL_SHIFT)
+#define LTQ_ASC_TXFCON_TXFITL_TXFFLU	(1 << 1)
+#define LTQ_ASC_TXFCON_TXFITL_TXFEN	(1 << 0)
+
+#define LTQ_ASC_FSTAT_TXFREE_SHIFT	24
+#define LTQ_ASC_FSTAT_TXFREE_MASK	(0x3F << LTQ_ASC_FSTAT_TXFREE_SHIFT)
+#define LTQ_ASC_FSTAT_RXFREE_SHIFT	16
+#define LTQ_ASC_FSTAT_RXFREE_MASK	(0x3F << LTQ_ASC_FSTAT_RXFREE_SHIFT)
+#define LTQ_ASC_FSTAT_TXFFL_SHIFT	8
+#define LTQ_ASC_FSTAT_TXFFL_MASK	(0x3F << LTQ_ASC_FSTAT_TXFFL_SHIFT)
+#define LTQ_ASC_FSTAT_RXFFL_MASK	0x3F
+
+#ifdef __BIG_ENDIAN
+#define LTQ_ASC_RBUF_OFFSET		3
+#define LTQ_ASC_TBUF_OFFSET		3
+#else
+#define LTQ_ASC_RBUF_OFFSET		0
+#define LTQ_ASC_TBUF_OFFSET		0
+#endif
+
+struct ltq_asc_regs {
+	u32	clc;
+	u32	pisel;
+	u32	id;
+	u32	rsvd0;
+	u32	mcon;
+	u32	state;
+	u32	whbstate;
+	u32	rsvd1;
+	u8	tbuf[4];
+	u8	rbuf[4];
+	u32	rsvd2[2];
+	u32	abcon;
+	u32	abstat;
+	u32	whbabcon;
+	u32	whbabstat;
+	u32	rxfcon;
+	u32	txfcon;
+	u32	fstat;
+	u32	rsvd3;
+	u32	bg;
+	u32	bg_timer;
+	u32	fdv;
+	u32	pmw;
+	u32	modcon;
+	u32	modstat;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct ltq_asc_regs *ltq_asc_regs =
+	(struct ltq_asc_regs *) CKSEG1ADDR(LTQ_ASC_BASE);
+
+int serial_init(void)
+{
+	/* Set clock divider for normal run mode to 1 and enable module */
+	ltq_writel(&ltq_asc_regs->clc, 0x100);
+
+	/* Reset MCON register */
+	ltq_writel(&ltq_asc_regs->mcon, 0);
+
+	/* Use Port A as receiver input */
+	ltq_writel(&ltq_asc_regs->pisel, 0);
+
+	/* Enable and flush RX/TX FIFOs */
+	ltq_setbits(&ltq_asc_regs->rxfcon,
+		LTQ_ASC_RXFCON_RXFITL_RXFFLU | LTQ_ASC_RXFCON_RXFITL_RXFEN);
+	ltq_setbits(&ltq_asc_regs->txfcon,
+		LTQ_ASC_TXFCON_TXFITL_TXFFLU | LTQ_ASC_TXFCON_TXFITL_TXFEN);
+
+	serial_setbrg();
+
+	/* Disable error flags, enable receiver */
+	ltq_writel(&ltq_asc_regs->whbstate, LTQ_ASC_WHBSTATE_SETREN);
+
+	return 0;
+}
+
+/*
+ *             fdv       asc_clk
+ * Baudrate = ----- * -------------
+ *             512    16 * (bg + 1)
+ */
+static void serial_calc_br_fdv(unsigned long asc_clk, unsigned long baudrate,
+				u16 *fdv, u16 *bg)
+{
+	const u32 c = asc_clk / (16 * 512);
+	u32 diff1, diff2;
+	u32 bg_calc, br_calc, i;
+
+	diff1 = baudrate;
+	for (i = 512; i > 0; i--) {
+		/* Calc bg for current fdv value */
+		bg_calc = i * c / baudrate;
+
+		/* Impossible baudrate */
+		if (!bg_calc)
+			return;
+
+		/*
+		 * Calc diff to target baudrate dependent on current
+		 * bg and fdv values
+		 */
+		br_calc = i * c / bg_calc;
+		if (br_calc > baudrate)
+			diff2 = br_calc - baudrate;
+		else
+			diff2 = baudrate - br_calc;
+
+		/* Perfect values found */
+		if (diff2 == 0) {
+			*fdv = i;
+			*bg = bg_calc - 1;
+			return;
+		}
+
+		if (diff2 < diff1) {
+			*fdv = i;
+			*bg = bg_calc - 1;
+			diff1 = diff2;
+		}
+	}
+}
+
+void serial_setbrg(void)
+{
+	unsigned long asc_clk, baudrate;
+	u16 bg = 0;
+	u16 fdv = 511;
+
+	/* ASC clock is same as FPI clock with CLC.RMS = 1 */
+	asc_clk = ltq_get_bus_clock();
+	baudrate = gd->baudrate;
+
+	/* Calculate FDV and BG values */
+	serial_calc_br_fdv(asc_clk, baudrate, &fdv, &bg);
+
+	/* Disable baudrate generator */
+	ltq_clrbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_R);
+
+	/* Enable fractional divider */
+	ltq_setbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_FDE);
+
+	/* Set fdv and bg values */
+	ltq_writel(&ltq_asc_regs->fdv, fdv);
+	ltq_writel(&ltq_asc_regs->bg, bg);
+
+	/* Enable baudrate generator */
+	ltq_setbits(&ltq_asc_regs->mcon, LTQ_ASC_MCON_R);
+}
+
+static inline unsigned int serial_tx_free(void)
+{
+	unsigned int txfree;
+
+	txfree = (ltq_readl(&ltq_asc_regs->fstat) &
+			LTQ_ASC_FSTAT_TXFREE_MASK) >>
+			LTQ_ASC_FSTAT_TXFREE_SHIFT;
+
+	return txfree;
+}
+
+static inline unsigned int serial_rx_fill(void)
+{
+	unsigned int rxffl;
+
+	rxffl = ltq_readl(&ltq_asc_regs->fstat) & LTQ_ASC_FSTAT_RXFFL_MASK;
+
+	return rxffl;
+}
+
+static inline void serial_tx(const char c)
+{
+	ltq_writeb(&ltq_asc_regs->tbuf[LTQ_ASC_TBUF_OFFSET], c);
+}
+
+static inline u8 serial_rx(void)
+{
+	return ltq_readb(&ltq_asc_regs->rbuf[LTQ_ASC_RBUF_OFFSET]);
+}
+
+void serial_putc(const char c)
+{
+	if (c == '\n')
+		serial_putc('\r');
+
+	while (!serial_tx_free())
+		;
+
+	serial_tx(c);
+}
+
+void serial_puts(const char *s)
+{
+	while (*s)
+		serial_putc(*s++);
+}
+
+int serial_getc(void)
+{
+	while (!serial_rx_fill())
+		;
+
+	return serial_rx();
+}
+
+int serial_tstc(void)
+{
+	return (0 != serial_rx_fill());
+}
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6f389f093498ae00c9758f7aac99a3c36e3b6228..0dab7fb135faa3749adf8b18503c45c5992d0901 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -34,6 +34,7 @@ COBJS-$(CONFIG_BFIN_SPI) += bfin_spi.o
 COBJS-$(CONFIG_CF_SPI) += cf_spi.o
 COBJS-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 COBJS-$(CONFIG_KIRKWOOD_SPI) += kirkwood_spi.o
+COBJS-$(CONFIG_LANTIQ_SPI) += lantiq_spi.o
 COBJS-$(CONFIG_MPC52XX_SPI) += mpc52xx_spi.o
 COBJS-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
 COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
diff --git a/drivers/spi/lantiq_spi.c b/drivers/spi/lantiq_spi.c
new file mode 100644
index 0000000000000000000000000000000000000000..557e4a5df7113b3d45149a1122882b7ab2b82b81
--- /dev/null
+++ b/drivers/spi/lantiq_spi.c
@@ -0,0 +1,476 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <asm/gpio.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_SPI_CLC_RMC_SHIFT		8
+#define LTQ_SPI_CLC_RMC_MASK		(0xFF << LTQ_SPI_CLC_RMC_SHIFT)
+#define LTQ_SPI_CLC_DISS		(1 << 1)
+#define LTQ_SPI_CLC_DISR		1
+
+#define LTQ_SPI_ID_TXFS_SHIFT		24
+#define LTQ_SPI_ID_TXFS_MASK		(0x3F << LTQ_SPI_ID_TXFS_SHIFT)
+#define LTQ_SPI_ID_RXFS_SHIFT		16
+#define LTQ_SPI_ID_RXFS_MASK		(0x3F << LTQ_SPI_ID_RXFS_SHIFT)
+
+#define LTQ_SPI_CON_ENBV		(1 << 22)
+#define LTQ_SPI_CON_BM_SHIFT		16
+#define LTQ_SPI_CON_BM_MASK		(0x1F << LTQ_SPI_CON_BM_SHIFT)
+#define LTQ_SPI_CON_LB			(1 << 7)
+#define LTQ_SPI_CON_PO			(1 << 6)
+#define LTQ_SPI_CON_PH			(1 << 5)
+#define LTQ_SPI_CON_HB			(1 << 4)
+#define LTQ_SPI_CON_RXOFF		(1 << 1)
+#define LTQ_SPI_CON_TXOFF		1
+
+#define LTQ_SPI_STAT_RXBV_SHIFT		28
+#define LTQ_SPI_STAT_RXBV_MASK		(0x7 << LTQ_SPI_STAT_RXBV_SHIFT)
+#define LTQ_SPI_STAT_BSY		(1 << 13)
+
+#define LTQ_SPI_WHBSTATE_SETMS		(1 << 3)
+#define LTQ_SPI_WHBSTATE_CLRMS		(1 << 2)
+#define LTQ_SPI_WHBSTATE_SETEN		(1 << 1)
+#define LTQ_SPI_WHBSTATE_CLREN		1
+
+#define LTQ_SPI_TXFCON_TXFLU		(1 << 1)
+#define LTQ_SPI_TXFCON_TXFEN		1
+
+#define LTQ_SPI_RXFCON_RXFLU		(1 << 1)
+#define LTQ_SPI_RXFCON_RXFEN		1
+
+#define LTQ_SPI_FSTAT_RXFFL_MASK	0x3f
+#define LTQ_SPI_FSTAT_TXFFL_SHIFT	8
+#define LTQ_SPI_FSTAT_TXFFL_MASK	(0x3f << LTQ_SPI_FSTAT_TXFFL_SHIFT)
+
+#define LTQ_SPI_RXREQ_RXCNT_MASK	0xFFFF
+#define LTQ_SPI_RXCNT_TODO_MASK		0xFFFF
+
+#define LTQ_SPI_GPIO_DIN		16
+#define LTQ_SPI_GPIO_DOUT		17
+#define LTQ_SPI_GPIO_CLK		18
+
+struct ltq_spi_regs {
+	u32	clc;		/* Clock control */
+	u32	pisel;		/* Port input select */
+	u32	id;		/* Identification */
+	u32	rsvd0;
+	u32	con;		/* Control */
+	u32	stat;		/* Status */
+	u32	whbstate;	/* Write HW modified state */
+	u32	rsvd1;
+	u32	tb;		/* Transmit buffer */
+	u32	rb;		/* Receive buffer */
+	u32	rsvd2[2];
+	u32	rxfcon;		/* Recevie FIFO control */
+	u32	txfcon;		/* Transmit FIFO control */
+	u32	fstat;		/* FIFO status */
+	u32	rsvd3;
+	u32	brt;		/* Baudrate timer */
+	u32	brstat;		/* Baudrate timer status */
+	u32	rsvd4[6];
+	u32	sfcon;		/* Serial frame control */
+	u32	sfstat;		/* Serial frame status */
+	u32	rsvd5[2];
+	u32	gpocon;		/* General purpose output control */
+	u32	gpostat;	/* General purpose output status */
+	u32	fgpo;		/* Force general purpose output */
+	u32	rsvd6;
+	u32	rxreq;		/* Receive request */
+	u32	rxcnt;		/* Receive count */
+	u32	rsvd7[25];
+	u32	dmacon;		/* DMA control */
+};
+
+struct ltq_spi_slave {
+	struct spi_slave slave;
+	unsigned int max_hz;
+	unsigned int mode;
+	unsigned int len;
+	unsigned int brt;
+	unsigned int tx_cnt;
+	unsigned int rx_cnt;
+	unsigned int rx_req;
+	const u8 *tx;
+	u8 *rx;
+	u8 txfs;
+	u8 rxfs;
+};
+
+static inline struct ltq_spi_slave *to_ltq_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct ltq_spi_slave, slave);
+}
+
+#ifdef CONFIG_SPL_BUILD
+/*
+ * We do not have or want malloc in a SPI flash SPL.
+ * Neither we have to support multiple SPI slaves. Thus we put the
+ * SPI slave context in BSS for SPL builds.
+ */
+static struct ltq_spi_slave ltq_spi_slave;
+
+static inline struct ltq_spi_slave *ltq_spi_slave_alloc(void)
+{
+	return &ltq_spi_slave;
+}
+
+static inline void ltq_spi_slave_free(struct spi_slave *slave)
+{
+}
+#else
+static inline struct ltq_spi_slave *ltq_spi_slave_alloc(void)
+{
+	return malloc(sizeof(struct ltq_spi_slave));
+}
+
+static inline void ltq_spi_slave_free(struct spi_slave *slave)
+{
+	struct ltq_spi_slave *sl;
+
+	if (slave) {
+		sl = to_ltq_spi_slave(slave);
+		free(sl);
+	}
+}
+#endif
+
+static struct ltq_spi_regs *ltq_spi_regs =
+	(struct ltq_spi_regs *) CKSEG1ADDR(LTQ_SPI_BASE);
+
+void spi_init(void)
+{
+	/* Power up SPI subsystem */
+	ltq_pm_enable(LTQ_PM_SPI);
+
+	/* Enable module and set clock divider to 1 */
+	ltq_writel(&ltq_spi_regs->clc, 1 << LTQ_SPI_CLC_RMC_SHIFT);
+
+	/* SPI/DIN input */
+	gpio_set_altfunc(16, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_IN);
+	/* SPI/DOUT output */
+	gpio_set_altfunc(17, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+	/* SPI/CLK output */
+	gpio_set_altfunc(18, GPIO_ALTSEL_SET, GPIO_ALTSEL_CLR, GPIO_DIR_OUT);
+}
+
+static inline u32 ltq_spi_calc_br(unsigned int max_hz)
+{
+	u32 speed_hz, spi_hz;
+	u16 brt;
+
+	/* SPI module clock is same as FPI bus clock */
+	spi_hz = ltq_get_bus_clock();
+
+	/*
+	 *                 f_SPI
+	 * baudrate = --------------
+	 *             2 * (BR + 1)
+	 */
+	spi_hz /= 2;
+
+	for (brt = 0; brt < 0xFFFF; brt++) {
+		speed_hz = spi_hz / (brt + 1);
+		if (speed_hz <= max_hz)
+			break;
+	}
+
+	return brt;
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	u32 id;
+	struct ltq_spi_slave *sl;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	sl = ltq_spi_slave_alloc();
+	if (!sl)
+		return NULL;
+
+	/* Read HW capabilities */
+	id = ltq_readl(&ltq_spi_regs->id);
+	sl->txfs = (id & LTQ_SPI_ID_TXFS_MASK) >> LTQ_SPI_ID_TXFS_SHIFT;
+	sl->rxfs = (id & LTQ_SPI_ID_RXFS_MASK) >> LTQ_SPI_ID_RXFS_SHIFT;
+
+	sl->slave.bus = bus;
+	sl->slave.cs = cs;
+	sl->max_hz = max_hz;
+	sl->mode = mode;
+
+	sl->brt = ltq_spi_calc_br(max_hz);
+
+	return &sl->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	ltq_spi_slave_free(slave);
+}
+
+static int ltq_spi_wait_ready(struct ltq_spi_slave *sl)
+{
+	u32 stat;
+	const unsigned long timeout = 20000;
+	unsigned long timebase;
+
+	timebase = get_timer(0);
+
+	do {
+		WATCHDOG_RESET();
+
+		stat = ltq_readl(&ltq_spi_regs->stat);
+
+		if (!(stat & LTQ_SPI_STAT_BSY))
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct ltq_spi_slave *sl = to_ltq_spi_slave(slave);
+	u32 con;
+	int ret;
+
+	/* Put module in configuration mode */
+	ltq_setbits(&ltq_spi_regs->whbstate, LTQ_SPI_WHBSTATE_CLREN);
+
+	/* Enable and flush RX and TX FIFOs */
+	ltq_setbits(&ltq_spi_regs->txfcon,
+			LTQ_SPI_TXFCON_TXFLU | LTQ_SPI_TXFCON_TXFEN);
+	ltq_setbits(&ltq_spi_regs->rxfcon,
+			LTQ_SPI_RXFCON_RXFLU | LTQ_SPI_RXFCON_RXFEN);
+
+	ret = ltq_spi_wait_ready(sl);
+	if (ret)
+		return ret;
+
+	/* Set baudrate */
+	ltq_writel(&ltq_spi_regs->brt, sl->brt);
+
+	/*
+	 * Disable byte valid control (ENBV = 0) and
+	 * set data width to 8 bit (BM = 7)
+	 */
+	con = (7 << LTQ_SPI_CON_BM_SHIFT);
+
+	/* Disable transmitter and receiver */
+	con |= (LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_TXOFF);
+
+	/* Set SPI mode
+	 * Mapping: Mode CPOL CPHA CON.PO CON.PH
+	 *            0    0    0      0      1
+	 *            1    0    1      0      0
+	 *            2    1    0      1      1
+	 *            3    1    1      1      0
+	 */
+	if (sl->mode & SPI_CPHA)
+		con &= ~LTQ_SPI_CON_PH;
+	else
+		con |= LTQ_SPI_CON_PH;
+
+	if (sl->mode & SPI_CPOL)
+		con |= LTQ_SPI_CON_PO;
+	else
+		con &= ~LTQ_SPI_CON_PO;
+
+	/* Set heading control */
+	if (sl->mode & SPI_LSB_FIRST)
+		con &= ~LTQ_SPI_CON_HB;
+	else
+		con |= LTQ_SPI_CON_HB;
+
+	/* Set loopback control */
+	if (sl->mode & SPI_LOOP)
+		con |= LTQ_SPI_CON_LB;
+	else
+		con &= ~LTQ_SPI_CON_LB;
+
+	ltq_writel(&ltq_spi_regs->con, con);
+
+	/* Set SPI master mode and enable SPI */
+	ltq_setbits(&ltq_spi_regs->whbstate,
+			LTQ_SPI_WHBSTATE_SETEN | LTQ_SPI_WHBSTATE_SETMS);
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+	/* Put module in configuration mode */
+	ltq_setbits(&ltq_spi_regs->whbstate, LTQ_SPI_WHBSTATE_CLREN);
+
+	/* Flush RX and TX FIFOs */
+	ltq_setbits(&ltq_spi_regs->txfcon, LTQ_SPI_TXFCON_TXFLU);
+	ltq_setbits(&ltq_spi_regs->rxfcon, LTQ_SPI_RXFCON_RXFLU);
+}
+
+static inline void ltq_spi_txfifo_write(struct ltq_spi_slave *sl)
+{
+	u32 fstat, tb;
+	u16 fifo_space;
+
+	fstat = ltq_readl(&ltq_spi_regs->fstat);
+	fifo_space = sl->txfs - ((fstat & LTQ_SPI_FSTAT_TXFFL_MASK) >>
+			LTQ_SPI_FSTAT_TXFFL_SHIFT);
+
+	while (sl->tx_cnt < sl->len && fifo_space) {
+		tb = *sl->tx++;
+		ltq_writel(&ltq_spi_regs->tb, tb);
+		fifo_space--;
+		sl->tx_cnt++;
+	}
+}
+
+static inline void ltq_spi_rx_request(struct ltq_spi_slave *sl)
+{
+	u32 rxreq, rxreq_max;
+
+	/*
+	 * In RX-only mode the serial clock is activated only after writing
+	 * the expected amount of RX bytes into RXREQ register.
+	 * To avoid receive overflows at high clocks it is better to request
+	 * only the amount of bytes that fits into all FIFOs. This value
+	 * depends on the FIFO size implemented in hardware.
+	 */
+	rxreq = sl->len - sl->rx_cnt;
+	rxreq_max = sl->rxfs << 2;
+	rxreq = min(rxreq_max, rxreq);
+
+	if (!sl->rx_req && rxreq && sl->rx_cnt < sl->len) {
+		ltq_writel(&ltq_spi_regs->rxreq, rxreq);
+		sl->rx_req = rxreq;
+	}
+}
+
+static void ltq_spi_rxfifo_read(struct ltq_spi_slave *sl)
+{
+	u32 fstat, data, *rx32;
+	u16 fifo_fill;
+	u8 rxbv, shift, *rx8;
+
+	/* Determine how much FIFOs are filled with RX data */
+	fstat = ltq_readl(&ltq_spi_regs->fstat);
+	fifo_fill = fstat & LTQ_SPI_FSTAT_RXFFL_MASK;
+
+	/*
+	 * The 32 bit FIFO is always used completely independent from the
+	 * bits_per_word value. Thus four bytes have to be read at once
+	 * per FIFO.
+	 */
+	rx32 = (u32 *) sl->rx;
+	while (sl->len - sl->rx_cnt >= 4 && fifo_fill) {
+		data = ltq_readl(&ltq_spi_regs->rb);
+		*rx32++ = data;
+		sl->rx_cnt += 4;
+		sl->rx_req -= 4;
+		sl->rx += 4;
+		fifo_fill--;
+	}
+
+	/*
+	 * If there are remaining bytes, read byte count from STAT.RXBV
+	 * register and read the data byte-wise.
+	 */
+	while (fifo_fill && sl->rx_cnt < sl->len) {
+		fstat = ltq_readl(&ltq_spi_regs->stat);
+		rxbv = (fstat & LTQ_SPI_STAT_RXBV_MASK) >>
+			LTQ_SPI_STAT_RXBV_SHIFT;
+
+		if (!rxbv)
+			break;
+
+		data = ltq_readl(&ltq_spi_regs->rb);
+
+		shift = (rxbv - 1) * 8;
+		rx8 = sl->rx;
+
+		while (rxbv) {
+			*rx8++ = (data >> shift) & 0xFF;
+			rxbv--;
+			shift -= 8;
+			sl->rx_cnt++;
+			sl->rx_req--;
+			sl->rx++;
+		}
+
+		fifo_fill--;
+	}
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+	     const void *dout, void *din, unsigned long flags)
+{
+	struct ltq_spi_slave *sl = to_ltq_spi_slave(slave);
+	int ret;
+
+	if (bitlen % 8)
+		return 1;
+
+	if (!bitlen) {
+		ret = 0;
+		goto done;
+	}
+
+	sl->len = bitlen / 8;
+	sl->tx = dout;
+	sl->rx = din;
+	sl->tx_cnt = 0;
+	sl->rx_cnt = 0;
+	sl->rx_req = 0;
+
+	if (flags & SPI_XFER_BEGIN)
+		spi_cs_activate(slave);
+
+	/* Enable transmitter */
+	if (sl->tx)
+		ltq_clrbits(&ltq_spi_regs->con, LTQ_SPI_CON_TXOFF);
+
+	/* Enable receiver */
+	if (sl->rx)
+		ltq_clrbits(&ltq_spi_regs->con, LTQ_SPI_CON_RXOFF);
+
+	if (sl->tx)
+		ltq_spi_txfifo_write(sl);
+	else if (sl->rx)
+		ltq_spi_rx_request(sl);
+
+	while (sl->tx_cnt != sl->len && sl->rx_cnt != sl->len) {
+		if (sl->rx) {
+			ltq_spi_rxfifo_read(sl);
+
+			if (sl->tx)
+				ltq_spi_txfifo_write(sl);
+			else
+				ltq_spi_rx_request(sl);
+		} else if (sl->tx)
+			ltq_spi_txfifo_write(sl);
+	}
+
+	ret = ltq_spi_wait_ready(sl);
+
+done:
+	/* Disable transmitter and receiver */
+	ltq_setbits(&ltq_spi_regs->con, LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
+
+	if (flags & SPI_XFER_END)
+		spi_cs_deactivate(slave);
+
+	return ret;
+}
diff --git a/examples/standalone/Makefile b/examples/standalone/Makefile
index e23865b4b020ba0781335cf81c82ae2168630702..8c9e4cf3eef703f2f548452c6e493e2a322f56c1 100644
--- a/examples/standalone/Makefile
+++ b/examples/standalone/Makefile
@@ -88,6 +88,10 @@ endif
 CFLAGS_NTR := $(call cc-option,-fno-toplevel-reorder)
 CFLAGS += $(CFLAGS_NTR)
 
+# Pass through endianness settings in LDFLAGS to LD
+LDFLAGS_ENDIAN += $(filter -EB,$(LDFLAGS))
+LDFLAGS_ENDIAN += $(filter -EL,$(LDFLAGS))
+
 all:	$(obj).depend $(OBJS) $(LIB) $(SREC) $(BIN) $(ELF)
 
 #########################################################################
@@ -96,7 +100,7 @@ $(LIB):	$(obj).depend $(LIBOBJS)
 
 $(ELF):
 $(obj)%:	$(obj)%.o $(LIB)
-		$(LD) -g -Ttext $(CONFIG_STANDALONE_LOAD_ADDR) \
+		$(LD) $(LDFLAGS_ENDIAN) -g -Ttext $(CONFIG_STANDALONE_LOAD_ADDR) \
 			-o $@ -e $(SYM_PREFIX)$(notdir $(<:.o=)) $< $(LIB) \
 			-L$(gcclibdir) -lgcc
 
diff --git a/include/common.h b/include/common.h
index 5cfdd762dc6ee1ee9844a1526eb82953e264ff22..4caf2c25435d0e61c41f1ec0e615a83727903875 100644
--- a/include/common.h
+++ b/include/common.h
@@ -338,6 +338,9 @@ int setenv_addr(const char *varname, const void *addr);
 # include <asm/mach-types.h>
 # include <asm/u-boot-nds32.h>
 #endif /* CONFIG_NDS32 */
+#ifdef CONFIG_MIPS
+# include <asm/u-boot-mips.h>
+#endif /* CONFIG_MIPS */
 
 #ifdef CONFIG_AUTO_COMPLETE
 int env_complete(char *var, int maxv, char *cmdv[], int maxsz, char *buf);
diff --git a/include/configs/easy50712.h b/include/configs/easy50712.h
new file mode 100644
index 0000000000000000000000000000000000000000..95938fb175196132fa40bed469ed03ecf88e9e68
--- /dev/null
+++ b/include/configs/easy50712.h
@@ -0,0 +1,79 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"EASY50712"
+#define CONFIG_BOARD_NAME	"Lantiq EASY50712 Danube Reference Board"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_LANTIQ_EASY50712
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL		/* Have an AT45DB321D serial flash */
+
+/* Switch devices */
+#define CONFIG_SWITCH_MULTI
+#define CONFIG_SWITCH_ADM6996I
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		2
+#define CONFIG_ENV_SPI_MAX_HZ		20000000
+#define CONFIG_ENV_SPI_MODE		0
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY Danube */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/easy80920.h b/include/configs/easy80920.h
new file mode 100644
index 0000000000000000000000000000000000000000..d2c76aeb7fd29c7d3e39cd41be08f5dd4e26d932
--- /dev/null
+++ b/include/configs/easy80920.h
@@ -0,0 +1,94 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"EASY80920"
+#define CONFIG_BOARD_NAME	"Lantiq EASY80920 VRX200 Family Board"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_LANTIQ_EASY80920
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Have a MX29LV620 serial flash */
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(320 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#elif defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=tftpboot u-boot.ltq.lzo.sfspl && "		\
+	"run sf-probe; sf erase 0 +$filesize; "				\
+	"sf write $fileaddr 0 $filesize\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/fb3370.h b/include/configs/fb3370.h
new file mode 100644
index 0000000000000000000000000000000000000000..225c144d07d9f5c564b7dd24fac5dd5619859d11
--- /dev/null
+++ b/include/configs/fb3370.h
@@ -0,0 +1,72 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"FB3370"
+#define CONFIG_BOARD_NAME	"AVM FritzBox 3370"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_AVM_FB3370
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Have a MX29LV620 serial flash */
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=tftpboot u-boot.ltq.lzo.sfspl && "		\
+	"run sf-probe; sf erase 0 +$filesize; "				\
+	"sf write $fileaddr 0 $filesize\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/isdn_sip_gw.h b/include/configs/isdn_sip_gw.h
new file mode 100644
index 0000000000000000000000000000000000000000..d8870d8dbd51099651610cc6471e558681657a7f
--- /dev/null
+++ b/include/configs/isdn_sip_gw.h
@@ -0,0 +1,86 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"SPHISDNSIPGW"
+#define CONFIG_BOARD_NAME	"Sphairon ISDN SIP Gateway"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_SPH_ISDN_SIP_GATEWAY
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Have a MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_ADDRESSING
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=tftpboot u-boot.ltq.lzo.sfspl && "		\
+	"run sf-probe; sf erase 0 +$filesize; "				\
+	"sf write $fileaddr 0 $filesize\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/pb1x00.h b/include/configs/pb1x00.h
index eea8ed3adb09199cdb94b3cac081653cf87ab32d..d056884e7ebac620bc316f62cc4f70609119c83a 100644
--- a/include/configs/pb1x00.h
+++ b/include/configs/pb1x00.h
@@ -46,6 +46,8 @@
 #endif
 #endif
 
+#define CONFIG_SYS_LITTLE_ENDIAN
+
 #define CONFIG_ETHADDR		DE:AD:BE:EF:01:01    /* Ethernet address */
 
 #define CONFIG_BOOTDELAY	2	/* autoboot after 2 seconds	*/
diff --git a/include/configs/sphairon_env.h b/include/configs/sphairon_env.h
new file mode 100644
index 0000000000000000000000000000000000000000..18c5df9dadbd1882de0b2306165c0a2561594bfb
--- /dev/null
+++ b/include/configs/sphairon_env.h
@@ -0,0 +1,40 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef _SPHAIRON_ENV_H_
+#define _SPHAIRON_ENV_H_
+
+/* Enable library for Sphairon extensions */
+#define CONFIG_LIB_SPHAIRON
+#define CONFIG_LZMA
+
+#define CONFIG_CMD_GPIO
+#define CONFIG_CMD_PING
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_CMD_SPI
+#endif
+
+/* Image booting */
+#define CONFIG_SPHAIRON_SCAN_STEP_SIZE		0x8000
+#define CONFIG_BOOTDELAY			3
+
+/* Environment */
+#define CONFIG_IPADDR				192.168.100.1
+#define CONFIG_SERVERIP				192.168.100.100
+#define CONFIG_ETHADDR				00:1c:28:ff:00:10
+#define CONFIG_LOADADDR				CONFIG_SYS_LOAD_ADDR
+
+#define CONFIG_ENV_ADDBOOTARGS						\
+	"addbootargs=setenv bootargs $bootargs $kernelcmdline"	\
+	" $mtdparts $rootfs $servicefs $defconfig"		\
+	" $flash_layout $ptest\0"
+
+#define CONFIG_ENV_SPHAIRON_GENERIC	\
+	CONFIG_ENV_ADDBOOTARGS
+
+#endif /* _SPHAIRON_ENV_H_ */
diff --git a/include/configs/sx76x.h b/include/configs/sx76x.h
new file mode 100644
index 0000000000000000000000000000000000000000..753c9120cffd60c99d058e98e5acab3ec9655daa
--- /dev/null
+++ b/include/configs/sx76x.h
@@ -0,0 +1,58 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Luka Perkov <uboot@lukaperkov.net>
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"sx76x"
+#define CONFIG_BOARD_NAME	"Gigaset sx76x"
+#define CONFIG_MACH_TYPE	"GIGASX76X"
+#define CONFIG_BOARD_GIGASET_SX76X
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+/* Switch devices */
+#define CONFIG_SWITCH_MULTI
+#define CONFIG_SWITCH_ADM6996I
+
+/* Environment */
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Commands */
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_PING
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Pull in default board configs for Lantiq XWAY Danube */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/tl7201.h b/include/configs/tl7201.h
new file mode 100644
index 0000000000000000000000000000000000000000..1f2935b1a96c64183c38823132d7b478e674586b
--- /dev/null
+++ b/include/configs/tl7201.h
@@ -0,0 +1,70 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"SPHTL7201"
+#define CONFIG_BOARD_NAME	"Sphairon Turbolink 7201"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_SPHAIRON_TL7201
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_NOR_FLASH	/* Have a parallel NOR flash */
+
+/* Switch devices */
+#define CONFIG_SWITCH_MULTI
+#define CONFIG_SWITCH_PSB697X
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_CMD_MTD
+
+/* Environment */
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(256 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(128 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Pull in default board configs for Lantiq XWAY Danube */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/vrx_g1.h b/include/configs/vrx_g1.h
new file mode 100644
index 0000000000000000000000000000000000000000..702b6d1c6a0fc3360609c0501c4260c9f2b361c0
--- /dev/null
+++ b/include/configs/vrx_g1.h
@@ -0,0 +1,89 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_IDENT_STRING	"SPHVRXG1"
+#define CONFIG_BOARD_NAME	"Sphairon VRX288 G1 Board"
+#define CONFIG_MACH_TYPE	CONFIG_IDENT_STRING
+#define CONFIG_BOARD_SPH_VRX_G1
+
+/* Configure SoC */
+#define CONFIG_LTQ_SUPPORT_UART		/* Enable ASC and UART */
+
+#define CONFIG_LTQ_SUPPORT_ETHERNET	/* Enable ethernet */
+
+#define CONFIG_LTQ_SUPPORT_SPI_FLASH
+#define CONFIG_SPI_FLASH_MACRONIX	/* Have a MX29LV620 serial flash */
+#define CONFIG_SPI_FLASH_4BYTE_ADDRESSING
+
+#define CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH	/* Build SPI flash SPL */
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		4
+#define CONFIG_SPL_SPI_MAX_HZ		25000000
+#define CONFIG_SPL_SPI_MODE		0
+#define CONFIG_LTQ_SPL_COMP_LZO
+
+/* MTD devices */
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_CMD_MTD
+
+/* Environment */
+#define CONFIG_ENV_SPI_BUS		CONFIG_SPL_SPI_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SPL_SPI_CS
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SPL_SPI_MAX_HZ
+#define CONFIG_ENV_SPI_MODE		CONFIG_SPL_SPI_MODE
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		(192 * 1024)
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#else
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE			(2 * 1024)
+#endif
+
+#define CONFIG_LOADADDR			CONFIG_SYS_LOAD_ADDR
+
+/* Console */
+#define CONFIG_LTQ_ADVANCED_CONSOLE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_CONSOLE_ASC		1
+#define CONFIG_CONSOLE_DEV		"ttyLTQ1"
+
+/* Commands */
+#define CONFIG_CMD_PING
+
+/* Swap FW for each GPHY due to wrong MII lines on G1 board */
+#define CONFIG_SPH_ETH_HARDWARE_WORKAROUND
+
+/* Pull in default board configs for Lantiq XWAY VRX200 */
+#include <asm/lantiq/config.h>
+#include <asm/arch/config.h>
+
+/* Pull in additional Sphairon board config options */
+#include <configs/sphairon_env.h>
+
+#define CONFIG_ENV_UPDATE_UBOOT_SF					\
+	"update-uboot-sf=tftpboot u-boot.ltq.lzo.sfspl && "		\
+	"run sf-probe; sf erase 0 +$filesize; "				\
+	"sf write $fileaddr 0 $filesize\0"
+
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_ENV_LANTIQ_DEFAULTS	\
+	CONFIG_ENV_UPDATE_UBOOT_SF	\
+	CONFIG_ENV_SPHAIRON_GENERIC
+
+/* Default flash layout */
+#define CONFIG_SPHAIRON_FLASHLAYOUT	"pss"
+
+#endif /* __CONFIG_H */
diff --git a/include/linux/mtd/compat.h b/include/linux/mtd/compat.h
index 39c693f7a8c0a50ab1addfe1b90696908dd373e1..97182d0bbcfec7ad13412ed8b494e66f5daa690d 100644
--- a/include/linux/mtd/compat.h
+++ b/include/linux/mtd/compat.h
@@ -6,7 +6,7 @@
 
 #define ndelay(x)	udelay(1)
 
-#define printk	printf
+#define printk	debug
 
 #define KERN_EMERG
 #define KERN_ALERT
diff --git a/include/phy.h b/include/phy.h
index 095f41c43b27cd4f376094530481023a6123be93..c76bc1224bf9793651be7a1cd57b6c7a9064f965 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -219,6 +219,7 @@ int gen10g_discover_mmds(struct phy_device *phydev);
 int phy_atheros_init(void);
 int phy_broadcom_init(void);
 int phy_davicom_init(void);
+int phy_lantiq_init(void);
 int phy_lxt_init(void);
 int phy_marvell_init(void);
 int phy_micrel_init(void);
diff --git a/include/sas/boot.h b/include/sas/boot.h
new file mode 100644
index 0000000000000000000000000000000000000000..6935206238e7a49442aca1388e7fa0d482939919
--- /dev/null
+++ b/include/sas/boot.h
@@ -0,0 +1,60 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_BOOT_H__
+#define __SAS_BOOT_H__
+
+#include <linux/list.h>
+#include <sas/image.h>
+
+typedef enum
+{
+	SAS_BOOT_NONAVAILABLE = 0,
+	SAS_BOOT_AVAILABLE,
+	SAS_BOOT_ACTIVEWORKING,
+	SAS_BOOT_INACTIVEWORKING,
+	SAS_BOOT_NOTWORKING,
+	SAS_BOOT_IGNORED,
+	SAS_BOOT_INVALID
+} sas_boot_state_t;
+
+struct mtd_info;
+struct sas_flash_partition;
+
+extern int sas_boot_init(struct mtd_info *mtd, int *save_env);
+
+extern int sas_boot_image_scan(void);
+
+extern void sas_boot_image_flush(void);
+
+extern int sas_boot_has_platform_images(
+				const struct sas_flash_partition *part);
+
+extern int sas_boot_has_service_images(
+				const struct sas_flash_partition *part);
+
+extern int sas_boot_platform_layout(const struct sas_flash_partition *part,
+					size_t uimage_size, size_t rootfs_size,
+					ulong *uimage_addr, ulong *rootfs_addr,
+					size_t *erase_len);
+
+extern void sas_boot_mtdparts_init(int active_image, int protect_uboot,
+					char *buf);
+
+extern int sas_boot_prepare(int active_image);
+
+extern int sas_boot_image_load(const struct sas_flash_partition *part,
+				sas_image_type_t type, ulong addr);
+
+extern int sas_boot_image_mtd_num(const struct sas_flash_partition *part,
+					sas_image_type_t type);
+
+extern void sas_boot_print(void);
+
+extern const char* sas_boot_state_str(sas_boot_state_t state);
+
+#endif /* __SAS_BOOT_H__ */
diff --git a/include/sas/cd_user.h b/include/sas/cd_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..fe658676d684b3d807346767372b640580176a4e
--- /dev/null
+++ b/include/sas/cd_user.h
@@ -0,0 +1,13 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_CD_USER_H__
+#define __SAS_CD_USER_H__
+
+#define SAS_CDIH_BASE_UBOOT_VARIABLE_STRING	"cald_addr"
+
+#endif /* __SAS_CD_USER_H__ */
diff --git a/include/sas/cmd_queue.h b/include/sas/cmd_queue.h
new file mode 100644
index 0000000000000000000000000000000000000000..5e80c91099fea5d94909222127057aafbae9e6f1
--- /dev/null
+++ b/include/sas/cmd_queue.h
@@ -0,0 +1,97 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_CMD_QUEUE_H__
+#define __SAS_CMD_QUEUE_H__
+
+struct sas_cmd_queue {
+	size_t size;
+	char *queue;
+	char *pos;
+};
+
+static inline struct sas_cmd_queue * sas_cmd_queue_alloc(size_t size)
+{
+	struct sas_cmd_queue *cmdq;
+	char *s;
+
+	cmdq = malloc(size + sizeof(*cmdq));
+	if (!cmdq)
+		return NULL;
+
+	cmdq->size = size;
+	s = (char *) &cmdq[1];
+	*s = '\0';
+	cmdq->queue = s;
+	cmdq->pos = s;
+
+	return cmdq;
+}
+
+static inline void sas_cmd_queue_release(struct sas_cmd_queue *cmdq)
+{
+	if (cmdq)
+		free(cmdq);
+}
+
+static inline void sas_cmd_queue_push_cmd(struct sas_cmd_queue *cmdq,
+				const char * cmd)
+{
+	size_t len = strlen(cmd);
+	char *s;
+
+	s = cmdq->pos;
+
+	if (s != cmdq->queue) {
+		*s = ';';
+		s++;
+	}
+
+	strcat(s, cmd);
+	s += len;
+	*s = '\0';
+
+	cmdq->pos = s;
+}
+
+static inline void sas_cmd_queue_push_macro(struct sas_cmd_queue *cmdq,
+				const char * cmd)
+{
+	size_t len = strlen(cmd);
+	char *s;
+
+	s = cmdq->pos;
+
+	if (s != cmdq->queue) {
+		*s = ';';
+		s++;
+	}
+
+	strcpy(s, "run ");
+	s += 4;
+	strcat(s, cmd);
+	s += len;
+	*s = '\0';
+
+	cmdq->pos = s;
+}
+
+static inline void sas_cmd_queue_reset(struct sas_cmd_queue *cmdq)
+{
+	char *s;
+
+	s = cmdq->queue;
+	*s = '\0';
+	cmdq->pos = s;
+}
+
+static inline int sas_cmd_queue_exec(struct sas_cmd_queue *cmdq)
+{
+	return sas_run_command(cmdq->queue);
+}
+
+#endif /* __SAS_CMD_QUEUE_H__ */
diff --git a/include/sas/etl.h b/include/sas/etl.h
new file mode 100644
index 0000000000000000000000000000000000000000..6a5603230983dc46afece2abf18fcb435477cd6b
--- /dev/null
+++ b/include/sas/etl.h
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_ETL_H__
+#define __SAS_ETL_H__
+
+#include <sas/etl_user.h>
+
+extern int sas_etl_init(int *save_env);
+
+extern void sas_etl_print(void);
+
+extern int sas_etl_get_string(unsigned id, char *retval, size_t len,
+			const char *defval, char fill);
+
+extern int sas_etl_get_ulong(unsigned int id, unsigned long *retval,
+			unsigned int base, unsigned long defval);
+
+extern int sas_etl_version(void);
+
+#endif /* __SAS_ETL_H__ */
diff --git a/include/sas/etl_user.h b/include/sas/etl_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..236957e23671f1e4dd388b223c5a01fccb3d8e1e
--- /dev/null
+++ b/include/sas/etl_user.h
@@ -0,0 +1,79 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_ETL_USER_H__
+#define __SAS_ETL_USER_H__
+
+typedef enum
+{
+	SAS_ETL_HW_VERSION		= 0x01,
+	SAS_ETL_SERIAL			= 0x02,
+	SAS_ETL_PROD_DATE		= 0x03,
+	SAS_ETL_WLAN_MODULE		= 0x04,
+	SAS_ETL_WLAN_KEY		= 0x05,
+	SAS_ETL_TRIV_NAME		= 0x06,
+	SAS_ETL_MAC_ADDR		= 0x07,
+	SAS_ETL_HW_CFG			= 0x08,
+	SAS_ETL_HW_CFG2			= 0x09,
+	SAS_ETL_IDENT_NO		= 0x0A,
+	SAS_ETL_CUSTOMER		= 0x0B,
+	SAS_ETL_BASE_PLATFORM		= 0x0C,
+	SAS_ETL_WPS_PIN			= 0x0D,
+	SAS_ETL_LEDCFG			= 0x0E,
+	SAS_ETL_WLANCFG			= 0x0F,
+	SAS_ETL_WLAN_SSID		= 0x10,
+	SAS_ETL_FLASH_LAYOUT		= 0x11,
+	SAS_ETL_EXTRA_SPACE_SIZE	= 0x12,
+	SAS_ETL_JFFS_IMAGES		= 0x13,
+	SAS_ETL_SERIAL_EXTRA		= 0x14,
+	SAS_ETL_SHDSL_LINES		= 0x15
+} sas_etl_id_t;
+
+struct sas_hw_cfg
+{
+	unsigned FXO : 1;
+	unsigned S0_ext : 1;
+	unsigned S0_int : 1;
+	unsigned ab_count : 2;
+	unsigned switch_ic : 1;
+	unsigned USB : 1;
+	unsigned metering_hw : 1;
+};
+
+struct sas_hw_cfg2
+{
+	unsigned reserved0 : 4;
+	unsigned fxs_ringvoltage : 4;
+	unsigned S0_int_count : 7;
+	unsigned reserved1 : 1;
+};
+
+struct sas_led_cfg
+{
+	unsigned l01 : 1;
+	unsigned l02 : 1;
+	unsigned l03 : 1;
+	unsigned l04 : 1;
+	unsigned l05 : 1;
+	unsigned l06 : 1;
+	unsigned l07 : 1;
+	unsigned l08 : 1;
+	unsigned l09 : 1;
+	unsigned l10 : 1;
+	unsigned l11 : 1;
+	unsigned l12 : 1;
+	unsigned l13 : 1;
+	unsigned l14 : 1;
+	unsigned rsvd : 2;
+};
+
+
+
+#define SAS_ETL_AREA_SIZE		SAS_FLASH_ETL_SIZE
+#define SAS_ETL_VARIABLE_EMPTY_CHAR	0x78
+
+#endif /* __SAS_ETL_USER_H__ */
diff --git a/include/sas/flash.h b/include/sas/flash.h
new file mode 100644
index 0000000000000000000000000000000000000000..17f00950e7ace1098e12a3100f7d8c9de5925e6a
--- /dev/null
+++ b/include/sas/flash.h
@@ -0,0 +1,107 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASH_H__
+#define __SAS_FLASH_H__
+
+#include <sas/flash_user.h>
+
+struct sas_flash_partition {
+	struct list_head link;
+	struct mtd_info *master;
+	struct mtd_info *mtd;
+	sas_flash_partition_t type;
+	size_t offset;
+	size_t size;
+	int locked;
+};
+
+extern int sas_flash_init(void);
+
+extern void sas_flash_verbose_set(int v);
+
+extern const char * sas_flash_boot_device(void);
+
+extern const char * sas_flash_linux_mtdid(const struct mtd_info *mtd);
+
+extern struct sas_flash_partition * sas_flash_partition_add(
+					struct mtd_info *master,
+					sas_flash_partition_t type,
+					size_t size, size_t offset,
+					int locked);
+
+extern struct sas_flash_partition * sas_flash_partition_get(
+					sas_flash_partition_t type);
+
+typedef void (*sas_flash_device_cb)(struct mtd_info *mtd, void *data);
+
+extern void sas_flash_device_foreach(sas_flash_device_cb cb,
+					void *data);
+
+typedef void (*sas_flash_partition_cb)(struct sas_flash_partition *part,
+					void *data);
+
+extern void sas_flash_partition_foreach(struct mtd_info *master,
+					sas_flash_partition_cb cb,
+					void *data);
+
+extern int sas_flash_partition_mtd_update(struct mtd_info *master);
+
+extern void sas_flash_partition_print(void);
+
+static inline size_t sas_flash_roundb(const struct sas_flash_partition *part,
+					size_t len)
+{
+	return ROUND(len, part->mtd->erasesize);
+}
+
+extern int sas_flash_read(const struct sas_flash_partition *part,
+				ulong from, size_t len, void *buf);
+
+extern int sas_flash_write(const struct sas_flash_partition *part,
+				ulong to, size_t len, const void *buf);
+
+extern int sas_flash_lock(const struct sas_flash_partition *part,
+				ulong off, size_t len);
+
+extern int sas_flash_unlock(const struct sas_flash_partition *part,
+				ulong off, size_t len);
+
+extern int sas_flash_erase(const struct sas_flash_partition *part,
+				ulong off, size_t len);
+
+extern int sas_flash_partial_erase(const struct sas_flash_partition *part,
+					ulong off, size_t len);
+
+extern int sas_flash_complete_write(const struct sas_flash_partition *part,
+					ulong to, size_t write_len,
+					size_t erase_len, const void *buf,
+					int partial_erase);
+
+static inline size_t sas_flash_cd_size(void)
+{
+	return 1 * 1024;
+}
+
+static inline size_t sas_flash_etl_size(void)
+{
+	return 1 * 1024;
+}
+
+static inline ulong sas_flash_cd_offset(struct sas_flash_partition *part)
+{
+	return part->size - 8 * 1024;
+}
+
+static inline ulong sas_flash_etl_offset(struct sas_flash_partition *part)
+{
+	return part->size - 7 * 1024;
+}
+
+extern const char* sas_flash_partition_str(sas_flash_partition_t type);
+
+#endif /* __SAS_FLASH_H__ */
diff --git a/include/sas/flash_user.h b/include/sas/flash_user.h
new file mode 100644
index 0000000000000000000000000000000000000000..6af8e5c5683cf1f69715ae336ef2b96f6038be1e
--- /dev/null
+++ b/include/sas/flash_user.h
@@ -0,0 +1,29 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASH_USER_H__
+#define __SAS_FLASH_USER_H__
+
+typedef enum {
+	SAS_PART_UBOOT_FIX,
+	SAS_PART_UBOOT_CFG,
+	SAS_PART_UBOOT_UPDATE,
+	SAS_PART_SYSCFG1,
+	SAS_PART_SYSCFG2,
+	SAS_PART_IMAGES1,
+	SAS_PART_IMAGES2,
+	SAS_PART_IMAGES3,
+	SAS_PART_DEVICE,
+	SAS_PART_INVALID
+} sas_flash_partition_t;
+
+#define SAS_FLASH_DATA_SIZE		(8 * 1024)
+#define SAS_FLASH_CD_SIZE		(1 * 1024)
+#define SAS_FLASH_ETL_SIZE		(1 * 1024)
+#define SAS_FLASH_ENV_SIZE		(8 * 1024)
+
+#endif /* __SAS_FLASH_USER_H__ */
diff --git a/include/sas/flashlayout.h b/include/sas/flashlayout.h
new file mode 100644
index 0000000000000000000000000000000000000000..c3ccfe6d8511ce8b79a2350db17798c72cb506b6
--- /dev/null
+++ b/include/sas/flashlayout.h
@@ -0,0 +1,55 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_FLASHLAYOUT_H__
+#define __SAS_FLASHLAYOUT_H__
+
+typedef enum {
+	SAS_LAYOUT_BASIC = 0,
+	SAS_LAYOUT_PLATFORM_ONLY_SINGLE,
+	SAS_LAYOUT_PLATFORM_ONLY_MIRRORED,
+	SAS_LAYOUT_PLATFORM_SERVICE_SINGLE,
+	SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED,
+	SAS_LAYOUT_PLATFORM_SERVICE_HANOI,
+	SAS_LAYOUT_INVALID
+} sas_flash_layout_t;
+
+struct mtd_info;
+
+extern int sas_flash_layout_basic_init(struct mtd_info *mtd);
+
+extern int sas_flash_layout_full_init(struct mtd_info *mtd,
+					int *save_env);
+
+extern int sas_flash_layout_device_init(struct mtd_info *mtd);
+
+extern void sas_flash_layout_print(void);
+
+extern int sas_flash_layout_is_mirrored(sas_flash_layout_t layout);
+
+extern int sas_flash_layout_image_partitions(
+					sas_flash_layout_t layout);
+
+static inline int sas_flash_layout_image_max_partitions(void)
+{
+	return 3;
+}
+
+extern struct sas_flash_partition *
+		sas_flash_layout_image_partition(int index);
+
+extern sas_flash_layout_t sas_flash_layout_current(void);
+
+extern const char* sas_flash_layout_name(
+				sas_flash_layout_t layout);
+
+extern const char* sas_flash_layout_str(
+				sas_flash_layout_t layout);
+
+extern sas_flash_layout_t sas_flash_layout_parse(const char *str);
+
+#endif /* __SAS_FLASHLAYOUT_H__ */
diff --git a/include/sas/image.h b/include/sas/image.h
new file mode 100644
index 0000000000000000000000000000000000000000..7a7b0717e68e1d06632207accf6ba77452c74d36
--- /dev/null
+++ b/include/sas/image.h
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_IMAGE_H__
+#define __SAS_IMAGE_H__
+
+#include <image.h>
+
+typedef enum
+{
+	SAS_IMG_FDT = 0,
+	SAS_IMG_KERNEL,
+	SAS_IMG_ROOTFS,
+	SAS_IMG_SERVICEFS,
+	SAS_IMG_DEFCONFIG,
+	SAS_IMG_UNSPECIFIED,
+	SAS_IMG_INVALID,
+} sas_image_type_t;
+
+#define SAS_UBOOT_BIN		"u-boot.bin"
+#define SAS_UBOOT_IMAGE		"u-boot.img"
+#define SAS_UBOOT_LZO_IMAGE	"u-boot.lzo.img"
+#define SAS_UBOOT_LZMA_IMAGE	"u-boot.lzma.img"
+#define SAS_UBOOT_SFSPL		"u-boot.ltq.sfspl"
+#define SAS_UBOOT_LZO_SFSPL	"u-boot.ltq.lzo.sfspl"
+#define SAS_UBOOT_LZMA_SFSPL	"u-boot.ltq.lzma.sfspl"
+#define SAS_TYPELABEL_BIN	"typelabel.bin"
+#define SAS_KERNEL_IMAGE	"uImage"
+#define SAS_ROOTFS_IMAGE	"rootfs.img"
+#define SAS_SERVICEFS_IMAGE	"servicefs.img"
+#define SAS_CONFIGFS_IMAGE	"configfs.img"
+
+extern int sas_image_header_check(const image_header_t *hdr);
+
+extern int sas_image_data_check(const image_header_t *hdr);
+
+extern const char* sas_image_type_str(sas_image_type_t type);
+
+extern sas_image_type_t sas_image_type(const image_header_t *hdr);
+
+extern size_t sas_image_size(const image_header_t *hdr);
+
+extern void sas_image_name(const image_header_t *hdr, char *buf);
+
+#endif /* __SAS_IMAGE_H__ */
diff --git a/include/sas/init.h b/include/sas/init.h
new file mode 100644
index 0000000000000000000000000000000000000000..d3a12adf5d13bbf5c8ee6aa210e1eb5595ae74b0
--- /dev/null
+++ b/include/sas/init.h
@@ -0,0 +1,27 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_INIT_H__
+#define __SAS_INIT_H__
+
+#ifdef CONFIG_LIB_SPHAIRON
+extern int sas_init_f(void);
+
+extern int sas_init_r(void);
+#else
+static inline int sas_init_f(void)
+{
+	return 0;
+}
+
+static inline int sas_init_r(void)
+{
+	return 0;
+}
+#endif
+
+#endif /* __SAS_INIT_H__ */
diff --git a/include/sas/util.h b/include/sas/util.h
new file mode 100644
index 0000000000000000000000000000000000000000..88036a3805b86d0c71feb246537dea4623b0636d
--- /dev/null
+++ b/include/sas/util.h
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#ifndef __SAS_UTIL_H__
+#define __SAS_UTIL_H__
+
+extern int sas_setenv(const char *name, const char *value, int *saveenv);
+
+extern int sas_setenv_num(const char *name, int value, int *saveenv);
+
+extern int sas_setenv_hex(const char *name, int value, int *saveenv);
+
+extern int sas_run_command(const char* fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+extern size_t sas_run_tftpboot(ulong loadaddr, const char *file);
+
+extern int sas_confirm(const char *message);
+
+extern void sas_banner_header_print(const char *fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+extern void sas_banner_content_print(const char *fmt, ...)
+		__attribute__((format(printf, 1, 2)));
+
+extern void sas_banner_footer_print(void);
+
+extern void sas_banner_line_print(void);
+
+#endif /* __SAS_UTIL_H__ */
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 2671ab55398aed94c97a2893a44b1b6dac06a1a9..4ef30b4f08a98d10a31f1778676e08b706816660 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -44,12 +44,17 @@ struct spi_flash {
 				size_t len, const void *buf);
 	int		(*erase)(struct spi_flash *flash, u32 offset,
 				size_t len);
+	int		(*set_4byte_addressing)(struct spi_flash *flash,
+				int on);
 };
 
 struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode);
 void spi_flash_free(struct spi_flash *flash);
 
+int spi_flash_probe_spl(struct spi_flash *sf, unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int spi_mode);
+
 static inline int spi_flash_read(struct spi_flash *flash, u32 offset,
 		size_t len, void *buf)
 {
@@ -68,4 +73,34 @@ static inline int spi_flash_erase(struct spi_flash *flash, u32 offset,
 	return flash->erase(flash, offset, len);
 }
 
+#ifdef CONFIG_SPI_FLASH_4BYTE_ADDRESSING
+static inline int spi_flash_has_4byte_addressing(struct spi_flash *flash)
+{
+	return (NULL != flash->set_4byte_addressing);
+}
+#else
+static inline int spi_flash_has_4byte_addressing(struct spi_flash *flash)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPI_FLASH_MTD
+extern int spi_flash_mtd_init(struct spi_flash *sf);
+#else
+static inline int spi_flash_mtd_init(struct spi_flash *sf)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPI_FLASH
+extern int spi_flash_init(void);
+#else
+static inline int spi_flash_init(void)
+{
+	return 0;
+}
+#endif
+
 #endif /* _SPI_FLASH_H_ */
diff --git a/include/switch.h b/include/switch.h
new file mode 100644
index 0000000000000000000000000000000000000000..d0ea0121ddccd87f4c7e8655869f986508728649
--- /dev/null
+++ b/include/switch.h
@@ -0,0 +1,97 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#ifndef __SWITCH_H
+#define __SWITCH_H
+
+#include <linux/list.h>
+
+#define SWITCH_NAME_SIZE	32
+
+struct switch_device;
+struct mii_dev;
+
+struct switch_driver {
+	struct list_head list;
+
+	/* Switch device name */
+	const char name[SWITCH_NAME_SIZE];
+
+	/*
+	 * Called to probe the switch chip. Must return 0 if the switch
+	 * chip matches the given switch device/driver combination. Otherwise
+	 * 1 must be returned.
+	 */
+	int (*probe) (struct switch_device *dev);
+
+	/*
+	 * Called to initialize the switch chip.
+	 */
+	void (*setup) (struct switch_device *dev);
+};
+
+struct switch_device {
+	struct list_head list;
+	struct switch_driver *drv;
+
+	/* MII bus the switch chip is connected to */
+	struct mii_dev *bus;
+
+	/* Switch device name */
+	const char name[SWITCH_NAME_SIZE];
+
+	/* Bitmask for board specific setup of used switch ports */
+	u16 port_mask;
+
+	/* Number of switch port that is connected to host CPU */
+	u16 cpu_port;
+};
+
+/*
+ * Board specific switch initialization.
+ *
+ * Called from switch_init to register the board specific switch_device
+ * structure.
+ */
+extern int board_switch_init(void);
+
+/* Initialize switch subsystem */
+#ifdef CONFIG_SWITCH_MULTI
+extern void switch_init(void);
+#else
+static inline void switch_init(void)
+{
+}
+#endif
+
+/* Register a switch driver */
+extern void switch_driver_register(struct switch_driver *drv);
+
+/* Register a switch device */
+extern int switch_device_register(struct switch_device *dev);
+
+/*
+ * Probe the available switch chips and connect the found one
+ * with the given MII bus
+ */
+extern struct switch_device *switch_connect(struct mii_dev *bus);
+
+/*
+ * Setup the given switch device
+ */
+static inline void switch_setup(struct switch_device *dev)
+{
+	if (dev->drv->setup)
+		dev->drv->setup(dev);
+}
+
+/* Init functions for supported Switch drivers */
+extern void switch_psb697x_init(void);
+extern void switch_adm6996i_init(void);
+
+#endif /* __SWITCH_H */
+
diff --git a/lib/sphairon/Makefile b/lib/sphairon/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..3f47beed94cbb01eca5266a9d65742bfe50df2f0
--- /dev/null
+++ b/lib/sphairon/Makefile
@@ -0,0 +1,41 @@
+#
+# (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+
+include $(TOPDIR)/config.mk
+
+CFLAGS	+= -Werror
+
+LIB	= $(obj)libsphairon.o
+
+COBJS-y	+= util.o
+COBJS-y	+= flash.o flashlayout.o
+COBJS-y	+= etl.o
+COBJS-y	+= boot.o image.o
+COBJS-y	+= init.o
+COBJS-y	+= cmd_sas_boot.o
+COBJS-y	+= cmd_sas_upgrade.o
+COBJS-$(CONFIG_SPI_FLASH) += cmd_sas_test_sf.o
+SOBJS-y	+=
+
+COBJS	:= $(COBJS-y)
+SOBJS	:= $(SOBJS-y)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/lib/sphairon/boot.c b/lib/sphairon/boot.c
new file mode 100644
index 0000000000000000000000000000000000000000..64561a2c5bc1c2091a929c129d0376079b9c772e
--- /dev/null
+++ b/lib/sphairon/boot.c
@@ -0,0 +1,625 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/boot.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+
+struct sas_boot_image {
+	struct list_head link;
+	sas_image_type_t type;
+	size_t size;
+	ulong offset;
+	int mtd_num;
+	const struct sas_flash_partition *part;
+	char name[IH_NMLEN];
+};
+
+static struct list_head sas_boot_images;
+
+int sas_boot_init(struct mtd_info *mtd, int *save_env)
+{
+	int ret;
+
+	debug("sas_boot: initializing\n");
+
+	INIT_LIST_HEAD(&sas_boot_images);
+
+	ret = sas_boot_image_scan();
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int sas_boot_image_add(const struct sas_flash_partition *part,
+				const image_header_t *hdr,
+				sas_image_type_t type, size_t size,
+				ulong offset)
+{
+	struct sas_boot_image *image;
+
+	image = malloc(sizeof(*image));
+	if (!image)
+		return 1;
+
+	INIT_LIST_HEAD(&image->link);
+	image->type = type;
+	image->size = size;
+	image->offset = offset;
+	image->mtd_num = -1;
+	image->part = part;
+	sas_image_name(hdr, image->name);
+
+	debug("%s: name %s\n", __func__, image->name);
+
+	list_add_tail(&image->link, &sas_boot_images);
+
+	return 0;
+}
+
+/*
+ * Scan for boot images.
+ *
+ * - with PSH layout we expect a kernel image or servicefs image
+ *   at partition begin
+ * - with all other layouts we expect only a kernel image at
+ *   partition begin
+ * - if kernel image or servicefs image could not found we can abort
+ *   the scan for this partition
+ */
+static int sas_boot_image_part_scan(const struct sas_flash_partition *part,
+					sas_flash_layout_t flash_layout)
+{
+	size_t size;
+	int ret;
+	image_header_t hdr;
+	sas_image_type_t type;
+	ulong offset;
+
+	debug("%s: mtd->name %s, mtd->size %llx, mtd->erasesize %x\n",
+		__func__, part->mtd->name, part->mtd->size, part->mtd->erasesize);
+
+	offset = 0;
+	do {
+		ret = sas_flash_read(part, offset, sizeof(hdr), &hdr);
+		if (ret)
+			return ret;
+
+		ret = sas_image_header_check(&hdr);
+		if (ret)
+			type = sas_image_type(&hdr);
+		else
+			type = SAS_IMG_INVALID;
+
+		if (type != SAS_IMG_INVALID) {
+			size = sas_image_size(&hdr);
+			ret = sas_boot_image_add(part, &hdr, type, size,
+						 offset);
+			if (ret)
+				return ret;
+
+			offset += size;
+			offset = ROUND(offset, CONFIG_SPHAIRON_SCAN_STEP_SIZE);
+		} else
+			offset += CONFIG_SPHAIRON_SCAN_STEP_SIZE;
+	} while (offset < part->mtd->size);
+
+	return 0;
+}
+
+static void sas_boot_image_content_set(int index, int has_platform,
+					int has_service)
+{
+	unsigned int content = (has_platform | (has_service << 1));
+	char buf[32];
+
+	sprintf(buf, "image_content%d", index);
+	printf("Setting content of image from %d to %u\n",
+		index, content);
+
+	sas_setenv_num(buf, content, NULL);
+}
+
+static void sas_boot_image_state_set(int index, sas_boot_state_t state)
+{
+	char buf[32];
+
+	sprintf(buf, "image_state%d", index);
+	printf("Setting state of image %d to '%s'\n",
+		index, sas_boot_state_str(state));
+
+	sas_setenv_num(buf, state, NULL);
+}
+
+#if 0
+static int sas_boot_bootcount_get(void)
+{
+	return getenv_ulong( "boot_count", 10, 0);
+}
+
+static void sas_boot_bootcount_set(int value, int *save_env)
+{
+    printf("Setting boot_count to %d\n", value);
+    sas_setenv_num("boot_count", value, save_env);
+}
+
+static int sas_boot_boottry_get(void)
+{
+	return getenv_ulong( "boot_try", 10, 0);
+}
+
+static void sas_boot_boottry_set(int value, int *save_env)
+{
+    printf("Setting boot_try to %d\n", value);
+    sas_setenv_num("boot_try", value, save_env);
+}
+#endif
+
+int sas_boot_image_scan(void)
+{
+	const struct sas_flash_partition *part;
+	sas_flash_layout_t flash_layout;
+	int ret, image_cnt, i;
+	int has_platformfs, has_servicefs;
+
+	debug("sas_boot: scanning\n");
+
+	flash_layout = sas_flash_layout_current();
+	if (flash_layout == SAS_LAYOUT_BASIC ||
+		flash_layout == SAS_LAYOUT_INVALID)
+		return 0;
+
+	sas_boot_image_flush();
+
+	image_cnt = sas_flash_layout_image_partitions(flash_layout);
+
+	for (i = 0; i < sas_flash_layout_image_max_partitions(); i++) {
+		if (i >= image_cnt) {
+			sas_boot_image_state_set(i, SAS_BOOT_NONAVAILABLE);
+			continue;
+		}
+
+		part = sas_flash_layout_image_partition(i);
+		if (!part)
+			return 1;
+
+		ret = sas_boot_image_part_scan(part, flash_layout);
+		if (ret)
+			return ret;
+
+		has_platformfs = sas_boot_has_platform_images(part);
+		has_servicefs = sas_boot_has_service_images(part);
+
+		debug( "%s: i %d, has_platformfs %d, has_servicefs %d\n",
+			__func__, i, has_platformfs, has_servicefs);
+
+		sas_boot_image_content_set(i, has_platformfs, has_servicefs);
+
+		if (!has_platformfs && !has_servicefs)
+			sas_boot_image_state_set(i, SAS_BOOT_NONAVAILABLE);
+	}
+
+	return 0;
+}
+
+void sas_boot_image_flush(void)
+{
+	struct sas_boot_image *image;
+
+	while (!list_empty(&sas_boot_images)) {
+		image = list_first_entry(&sas_boot_images,
+					 struct sas_boot_image, link);
+		list_del(&image->link);
+		free(image);
+	}
+}
+
+struct sas_boot_priv {
+	int active_image;
+	int protect_uboot;
+	int dev_cnt;
+	int part_cnt;
+	int mtd_cnt;
+	char *pos;
+};
+
+static int sas_boot_memsize_format(char *buf, size_t size)
+{
+	int n;
+
+#define SIZE_GB ((size_t)1024*1024*1024)
+#define SIZE_MB ((size_t)1024*1024)
+#define SIZE_KB ((size_t)1024)
+
+	if ((size % SIZE_GB) == 0)
+		n = sprintf(buf, "%ug", size/SIZE_GB);
+	else if ((size % SIZE_MB) == 0)
+		n = sprintf(buf, "%um", size/SIZE_MB);
+	else if (size % SIZE_KB == 0)
+		n = sprintf(buf, "%uk", size/SIZE_KB);
+	else
+		n = sprintf(buf, "%u", size);
+
+	return n;
+}
+
+static void sas_boot_mtd_part_add(struct sas_boot_priv *priv,
+				size_t size, size_t offset,
+				const char *name,
+				int readonly)
+{
+	int n;
+
+	if (priv->part_cnt)
+		*(priv->pos++) = ',';
+
+	n = sas_boot_memsize_format(priv->pos, size);
+	priv->pos += n;
+
+	if (offset) {
+		*(priv->pos++) = '@';
+		n = sas_boot_memsize_format(priv->pos, offset);
+		priv->pos += n;
+	}
+
+	n = sprintf(priv->pos, "(%s)", name);
+	priv->pos += n;
+
+	if (readonly) {
+		*(priv->pos++) = 'r';
+		*(priv->pos++) = 'o';
+	}
+
+	priv->part_cnt++;
+	priv->mtd_cnt++;
+}
+
+static void sas_boot_part_handle_cfg(struct sas_boot_priv *priv,
+				const struct sas_flash_partition *part)
+{
+	const sas_flash_layout_t flash_layout = sas_flash_layout_current();
+	int add_active = 0, add_backup = 0;
+
+	switch (flash_layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+		add_active = (part->type == SAS_PART_SYSCFG1);
+		break;
+	case SAS_LAYOUT_PLATFORM_SERVICE_HANOI:
+		add_active = (part->type == SAS_PART_SYSCFG1);
+		add_backup = (part->type == SAS_PART_SYSCFG2);
+		break;
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+		if (priv->active_image > 1) {
+			add_active = (part->type == SAS_PART_SYSCFG2);
+			add_backup = (part->type == SAS_PART_SYSCFG1);
+		} else {
+			add_active = (part->type == SAS_PART_SYSCFG1);
+			add_backup = (part->type == SAS_PART_SYSCFG2);
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (add_active)
+		sas_boot_mtd_part_add(priv, part->size, part->offset,
+					"cfg_active", 0);
+
+	if (add_backup)
+		sas_boot_mtd_part_add(priv, part->size, part->offset,
+					"cfg_backup", 0);
+}
+
+static void sas_boot_part_cb(struct sas_flash_partition *part, void *data)
+{
+	struct sas_boot_priv *priv = data;
+
+	debug("%s: %s\n", __func__, part->mtd->name);
+
+	switch (part->type) {
+	case SAS_PART_UBOOT_FIX:
+		sas_boot_mtd_part_add(priv, part->size, part->offset,
+					part->mtd->name, priv->protect_uboot);
+		break;
+	case SAS_PART_UBOOT_CFG:
+	case SAS_PART_UBOOT_UPDATE:
+	case SAS_PART_IMAGES1:
+	case SAS_PART_IMAGES2:
+	case SAS_PART_IMAGES3:
+	case SAS_PART_DEVICE:
+		sas_boot_mtd_part_add(priv, part->size, part->offset,
+					part->mtd->name, 0);
+		break;
+	case SAS_PART_SYSCFG1:
+	case SAS_PART_SYSCFG2:
+		sas_boot_part_handle_cfg(priv, part);
+		break;
+	default:
+		break;
+	}
+}
+
+static void sas_boot_mtd_part_fs_add(struct sas_boot_priv *priv,
+					struct sas_boot_image *image)
+{
+	ulong offset;
+	size_t size;
+	const char *type;
+
+	offset = image->offset + image->part->offset + sizeof(image_header_t);
+	size = image->size - sizeof(image_header_t);
+	type = sas_image_type_str(image->type);
+	image->mtd_num = priv->mtd_cnt;
+
+	debug("%s: %s: offset %08lx, mtd_num %d\n",
+		__func__, image->name, offset, image->mtd_num);
+
+	sas_boot_mtd_part_add(priv, size, offset, type, 1);
+}
+
+static void sas_boot_part_handle_fs(struct sas_boot_priv *priv,
+					struct sas_flash_partition *boot_part)
+{
+	const sas_flash_layout_t flash_layout = sas_flash_layout_current();
+	struct sas_boot_image *image, *rootfs = NULL;
+	struct sas_boot_image *servicefs = NULL, *defconfig = NULL;
+
+	debug("%s: %s\n", __func__, boot_part->mtd->name);
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (flash_layout == SAS_LAYOUT_PLATFORM_SERVICE_HANOI) {
+			printf("%s: hanoi layout not yet supported!\n",
+				__func__);
+		} else {
+			if (boot_part == image->part) {
+				switch (image->type) {
+				case SAS_IMG_ROOTFS:
+					rootfs = image;
+					break;
+				case SAS_IMG_SERVICEFS:
+					servicefs = image;
+					break;
+				case SAS_IMG_DEFCONFIG:
+					defconfig = image;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	if (rootfs)
+		sas_boot_mtd_part_fs_add(priv, rootfs);
+
+	if (servicefs)
+		sas_boot_mtd_part_fs_add(priv, servicefs);
+
+	if (defconfig)
+		sas_boot_mtd_part_fs_add(priv, defconfig);
+}
+
+static void sas_boot_mtd_cb(struct mtd_info *mtd, void *data)
+{
+	struct sas_boot_priv *priv = data;
+	struct sas_flash_partition *boot_part;
+	int n;
+
+	debug("%s: %s\n", __func__, mtd->name);
+
+	if (priv->dev_cnt)
+		*(priv->pos++) = ';';
+
+	n = sprintf(priv->pos, "%s:", sas_flash_linux_mtdid(mtd));
+	priv->pos += n;
+	priv->part_cnt = 0;
+
+	sas_flash_partition_foreach(mtd, sas_boot_part_cb, priv);
+
+	if (priv->active_image) {
+		boot_part = sas_flash_layout_image_partition(
+						priv->active_image - 1);
+		if (mtd == boot_part->master)
+			sas_boot_part_handle_fs(priv, boot_part);
+	}
+
+	priv->dev_cnt++;
+}
+
+void sas_boot_mtdparts_init(int active_image, int protect_uboot, char *buf)
+{
+	struct sas_boot_priv priv;
+	int n;
+
+	debug("%s: active_image %d, protect_uboot %d\n",
+		__func__, active_image, protect_uboot);
+
+	priv.active_image = active_image;
+	priv.protect_uboot = protect_uboot;
+	priv.dev_cnt = 0;
+	priv.part_cnt = 0;
+	priv.mtd_cnt = 0;
+	priv.pos = buf;
+
+	n = sprintf(priv.pos, "mtdparts=");
+	priv.pos += n;
+
+	sas_flash_device_foreach(sas_boot_mtd_cb, &priv);
+
+	*(priv.pos) = 0;
+
+	debug("%s: %s\n", __func__, buf);
+}
+
+int sas_boot_prepare(int active_image)
+{
+	return 1;
+}
+
+static struct sas_boot_image * sas_boot_find(sas_image_type_t type,
+						const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+
+	list_for_each_entry(image, &sas_boot_images, link) {
+		if (part == image->part &&
+			type == image->type)
+			return image;
+	}
+
+	return NULL;
+}
+
+int sas_boot_has_platform_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+
+	if (!part)
+		return 0;
+
+	image = sas_boot_find(SAS_IMG_KERNEL, part);
+	if (!image)
+		return 0;
+
+	image = sas_boot_find(SAS_IMG_ROOTFS, part);
+	if (!image)
+		return 0;
+
+	return 1;
+}
+
+int sas_boot_has_service_images(const struct sas_flash_partition *part)
+{
+	struct sas_boot_image *image;
+
+	if (!part)
+		return 0;
+
+	image = sas_boot_find(SAS_IMG_SERVICEFS, part);
+	if (!image)
+		return 0;
+
+	image = sas_boot_find(SAS_IMG_DEFCONFIG, part);
+	if (!image)
+		return 0;
+
+	return 1;
+}
+
+int sas_boot_platform_layout(const struct sas_flash_partition *part,
+				size_t uimage_size, size_t rootfs_size,
+				ulong *uimage_addr, ulong *rootfs_addr,
+				size_t *erase_len)
+{
+	const sas_flash_layout_t flash_layout = sas_flash_layout_current();
+
+	debug("%s: part %s, uimage_size %zu, rootfs_size %zu\n",
+		__func__, part->mtd->name, uimage_size, rootfs_size);
+
+	/*
+	 * - uImage at the beginning of the partition
+	 * - rootfs.img after uImage and aligned to flashStepSize
+	 * - if Hanoi layout is not configured the whole partition can
+	 *   be used for platform
+	 */
+	*uimage_addr = 0;
+	*rootfs_addr = ROUND(uimage_size, CONFIG_SPHAIRON_SCAN_STEP_SIZE);
+
+	if (flash_layout == SAS_LAYOUT_PLATFORM_SERVICE_HANOI) {
+		puts("Hanoi layout not yet supported\n");
+		return 1;
+	} else {
+		*erase_len = *rootfs_addr + rootfs_size;
+		*erase_len = sas_flash_roundb(part, *erase_len);
+
+		if (*erase_len > part->size) {
+			puts("Size of images exceeds partition size\n");
+			return 1;
+		}
+	}
+
+	debug("%s: uimage_addr %08lx, rootfs_addr %08lx, erase_len %zu\n",
+		__func__, *uimage_addr, *rootfs_addr, *erase_len);
+
+	return 0;
+}
+
+int sas_boot_image_load(const struct sas_flash_partition *part,
+			sas_image_type_t type, ulong addr)
+{
+	struct sas_boot_image *image;
+
+	printf("%s: loading %s from partition %s to %08lx\n",
+		__func__, sas_image_type_str(type), part->mtd->name, addr);
+
+	image = sas_boot_find(type, part);
+	if (!image)
+		return 1;
+
+	return sas_flash_read(part, image->offset, image->size, (void *) addr);
+}
+
+int sas_boot_image_mtd_num(const struct sas_flash_partition *part,
+					sas_image_type_t type)
+{
+	struct sas_boot_image *image;
+
+	debug("%s: getting MTD num of %s from partition %s\n",
+		__func__, sas_image_type_str(type), part->mtd->name);
+
+	image = sas_boot_find(type, part);
+	if (!image)
+		return -1;
+
+	return image->mtd_num;
+}
+
+void sas_boot_print(void)
+{
+	struct sas_boot_image *image;
+
+	sas_banner_header_print("Boot info");
+
+	list_for_each_entry(image, &sas_boot_images, link)
+		sas_banner_content_print("%-8s @ %08lx      %-32s",
+					sas_flash_partition_str(image->part->type),
+					image->offset, image->name);
+
+	sas_banner_line_print();
+
+	sas_banner_content_print("%-25s%-u ", "Boot count", 0);
+	sas_banner_content_print("%-25s%-u ", "Boot try", 0);
+
+	sas_banner_footer_print();
+}
+
+static const char sas_boot_state_strings[][20] = {
+	"non-available",
+	"available",
+	"active-working",
+	"inactive-working",
+	"not-working",
+	"ignored",
+	"invalid"
+};
+
+const char* sas_boot_state_str(sas_boot_state_t state)
+{
+	assert(state <= SAS_BOOT_INVALID);
+
+	return sas_boot_state_strings[state];
+}
diff --git a/lib/sphairon/cmd_sas_boot.c b/lib/sphairon/cmd_sas_boot.c
new file mode 100644
index 0000000000000000000000000000000000000000..120aabe10d728e9dbc3b6361c8853b9e6fa7e613
--- /dev/null
+++ b/lib/sphairon/cmd_sas_boot.c
@@ -0,0 +1,351 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/util.h>
+#include <sas/cmd_queue.h>
+#include <sas/boot.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+
+#ifdef CMD_SAVEENV
+#define sas_has_saveenv		1
+#else
+#define sas_has_saveenv		0
+#endif
+
+typedef enum {
+	SAS_FLASH,
+	SAS_TFTP,
+	SAS_NFS,
+	SAS_NONE,
+	SAS_PTEST,
+	SAS_INVALID,
+} sas_image_src_t;
+
+static const char sas_image_src_strings[][10] = {
+	"flash",
+	"tftp",
+	"nfs",
+	"none",
+	"ptest",
+	"invalid"
+};
+
+static inline const char * sas_image_src_str(sas_image_src_t image)
+{
+	assert(image <= SAS_INVALID);
+
+	return sas_image_src_strings[image];
+}
+
+static sas_image_src_t sas_parse_image_src(const char *image,
+					sas_image_src_t def_image)
+{
+	int i, ret;
+
+	if (!image)
+		return def_image;
+
+	for (i = 0; i < ARRAY_SIZE(sas_image_src_strings); i++) {
+		ret = strcmp(image, sas_image_src_str(i));
+		if (!ret)
+			return i;
+	}
+
+	printf("sas_boot: invalid image src: %s\n",
+		image ? image : "");
+
+	return SAS_INVALID;
+}
+
+static inline const char * sas_image_str(sas_image_type_t type)
+{
+	switch (type) {
+	case SAS_IMG_ROOTFS:
+		return "rootfs";
+	case SAS_IMG_SERVICEFS:
+		return "servicefs";
+	case SAS_IMG_DEFCONFIG:
+		return "defconfig";
+	default:
+		return NULL;
+	}
+}
+
+static int sas_load_kernel(const struct sas_flash_partition *part,
+				sas_image_src_t src, ulong loadaddr)
+{
+	int ret;
+	size_t size;
+
+	debug("%s\n", __func__);
+
+	switch (src) {
+	case SAS_TFTP:
+		size = sas_run_tftpboot(loadaddr, SAS_KERNEL_IMAGE);
+		ret = size ? 0 : 1;
+		break;
+	case SAS_FLASH:
+		assert(part);
+		ret = sas_boot_image_load(part, SAS_IMG_KERNEL,
+						loadaddr);
+		break;
+	default:
+		ret = 1;
+	}
+
+	if (ret) {
+		puts("Failed to load kernel image\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int sas_load_fs(const struct sas_flash_partition *part,
+			sas_image_src_t src, sas_image_type_t type)
+{
+	char buf[48];
+	int mtd_num, ret;
+	const char *name = sas_image_str(type);
+
+	debug("%s: name %s\n", __func__, name);
+
+	switch (src) {
+	case SAS_FLASH:
+		mtd_num = sas_boot_image_mtd_num(part, type);
+		if (mtd_num < 0)
+			ret = 1;
+		else {
+			sprintf(buf, "%s=/dev/mtdblock%d", name, mtd_num);
+			setenv(name, buf);
+			ret = 0;
+		}
+		break;
+	case SAS_TFTP:
+	case SAS_NFS:
+		sprintf(buf, "%s=%s", name, sas_image_src_str(src));
+		setenv(name, buf);
+		ret = 0;
+		break;
+	case SAS_NONE:
+		ret = 0;
+		break;
+	case SAS_PTEST:
+		setenv("ptest", "ptest=1");
+		ret = 0;
+		break;
+	default:
+		ret = 1;
+	}
+
+	if (ret) {
+		printf("Failed to load %s image\n", name);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void sas_linux_fixup(ulong loadaddr)
+{
+	const image_header_t *hdr = (const image_header_t *)loadaddr;
+	char name[IH_NMLEN + 1];
+
+	sas_image_name(hdr, name);
+
+	if (!strstr(name, "kernel#Linux-3"))
+#ifdef CONFIG_SOC_XWAY_VRX200
+		setenv("consoledev", "ttyS0");
+#else
+		setenv("consoledev", "ttyS1");
+#endif
+}
+
+static void sas_env_bootargs_clear(void)
+{
+	setenv("bootargs", NULL);
+	setenv("mtdparts", NULL);
+	setenv("ptest", NULL);
+	setenv(sas_image_str(SAS_IMG_ROOTFS), NULL);
+	setenv(sas_image_str(SAS_IMG_SERVICEFS), NULL);
+	setenv(sas_image_str(SAS_IMG_DEFCONFIG), NULL);
+}
+
+static void sas_env_flashlayout_set(sas_flash_layout_t layout, int *save_env)
+{
+	const char flash_layout[] = "flash_layout";
+	char buf[24];
+
+	sprintf(buf, "%s=%s", flash_layout, sas_flash_layout_name(layout));
+	sas_setenv(flash_layout, buf, save_env);
+}
+
+static void sas_env_compat_set(int *save_env)
+{
+	sas_setenv("cfg_version", "20", save_env);
+}
+
+static void sas_env_mtdparts_set(const char *mtdparts)
+{
+	setenv("mtdparts", mtdparts);
+}
+
+static void sas_env_bootargs_init(void)
+{
+	sas_run_command("run addconsole addeth addip addmachtype addbootargs");
+}
+
+static void sas_env_save(int status)
+{
+	if (status && sas_has_saveenv)
+		saveenv();
+}
+
+static void sas_bootm(ulong addr, int sim)
+{
+	if (sim)
+		printf("\nbootm %08lx\n\n", addr);
+	else
+		sas_run_command("bootm %08lx", addr);
+}
+
+static int sas_bootlogic_active(sas_flash_layout_t flash_layout,
+				sas_image_src_t kernel, sas_image_src_t rootfs,
+				sas_image_src_t servicefs)
+{
+	if (kernel != SAS_FLASH)
+		return 0;
+
+	if (rootfs != SAS_FLASH)
+		return 0;
+
+	switch (flash_layout) {
+	case SAS_LAYOUT_BASIC:
+		return 0;
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+		return 1;
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+		if (servicefs == SAS_FLASH)
+			return 1;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int do_sas_boot(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	const char *kernel_src, *rootfs_src, *servicefs_src;
+	const sas_flash_layout_t flash_layout = sas_flash_layout_current();
+	struct sas_flash_partition *part;
+	sas_image_src_t kernel, rootfs, servicefs;
+	ulong loadaddr;
+	int ret = 0, save_env = 0, active_image = 0, sas_saveenv;
+	int i, protect_uboot, boot_logic;
+	char mtdparts[512];
+
+	if (argc == 4) {
+		kernel_src = argv[1];
+		rootfs_src = argv[2];
+		servicefs_src = argv[3];
+	} else if (argc == 1) {
+		kernel_src = getenv("kernel_src");
+		rootfs_src = getenv("rootfs_src");
+		servicefs_src = getenv("servicefs_src");
+	} else
+		goto usage;
+
+	kernel = sas_parse_image_src(kernel_src, SAS_FLASH);
+	rootfs = sas_parse_image_src(rootfs_src, SAS_FLASH);
+	servicefs = sas_parse_image_src(servicefs_src, SAS_FLASH);
+
+	if (kernel == SAS_INVALID || rootfs == SAS_INVALID ||
+		servicefs == SAS_INVALID)
+		goto usage;
+
+	loadaddr = getenv_ulong("loadaddr", 16, 0);
+	sas_saveenv = getenv_ulong("sas_saveenv", 10, 0);
+	boot_logic = sas_bootlogic_active(flash_layout, kernel, rootfs,
+						servicefs);
+
+	printf("Booting with: kernel %s, rootfs %s, servicefs %s, "
+	       "loadaddr %08lx, boot_logic %d\n",
+		sas_image_src_str(kernel), sas_image_src_str(rootfs),
+		sas_image_src_str(servicefs), loadaddr, boot_logic);
+
+	active_image = 0;
+	protect_uboot = (servicefs != SAS_PTEST);
+
+	sas_env_bootargs_clear();
+
+	for (i = 0; i < sas_flash_layout_image_partitions(flash_layout); i++) {
+		part = sas_flash_layout_image_partition(i);
+		assert(part);
+
+		active_image = i + 1;
+
+		debug("i %d, active_image %d, part %s\n",
+			i, active_image, part->mtd->name);
+
+		sas_boot_mtdparts_init(active_image, protect_uboot, mtdparts);
+
+		ret = sas_load_kernel(part, kernel, loadaddr);
+		if (ret)
+			goto done;
+
+		ret = sas_load_fs(part, rootfs, SAS_IMG_ROOTFS);
+		if (ret)
+			goto done;
+
+		ret = sas_load_fs(part, servicefs, SAS_IMG_SERVICEFS);
+		if (ret)
+			goto done;
+
+		ret = sas_load_fs(part, servicefs, SAS_IMG_DEFCONFIG);
+		if (ret)
+			goto done;
+
+		ret = sas_boot_prepare(active_image);
+		if (ret)
+			break;
+	}
+
+	sas_linux_fixup(loadaddr);
+	sas_env_flashlayout_set(flash_layout, &save_env);
+	sas_env_compat_set(&save_env);
+
+	sas_env_save(save_env || sas_saveenv);
+
+	sas_env_mtdparts_set(mtdparts);
+	sas_env_bootargs_init();
+
+	sas_bootm(loadaddr, 0);
+
+done:
+	if (ret != -1)
+		return ret;
+
+usage:
+	return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(sas_boot, 4, 1, do_sas_boot,
+	   "Sphairon kernel and rootfs loader",
+	   "[kernel_src rootfs_src servicefs_src] \n"
+	   "    - kernel_src = [flash|tftp]\n"
+	   "    - rootfs_src = [flash|tftp|nfs|none]\n"
+	   "    - servicefs_src = [flash|tftp|nfs|none|ptest]\n");
diff --git a/lib/sphairon/cmd_sas_test_sf.c b/lib/sphairon/cmd_sas_test_sf.c
new file mode 100644
index 0000000000000000000000000000000000000000..7db61e16dd2f717d4787513fde2a19f1113a872d
--- /dev/null
+++ b/lib/sphairon/cmd_sas_test_sf.c
@@ -0,0 +1,119 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <command.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <asm/io.h>
+
+static int do_sas_test_sf(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
+{
+	struct spi_flash *sf;
+	const ulong ram_addr = CONFIG_SYS_SDRAM_BASE;
+	ulong sf_addr_lo, sf_addr_hi;
+	const uint32_t pattern_len = 0x20;
+	volatile uint8_t *p8;
+	void *p;
+	int i, j, ret = 0;
+	char c;
+
+	puts(">>> Caustion: this test program erases some flash sectors!");
+	for (;;) {
+		puts("\n>>> Do you want to continue (y|n)? :");
+		c = getc();
+		if (c == 'y')
+			break;
+		if (c == 'n') {
+			puts("\n");
+			return 0;
+		}
+	}
+
+	sf = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+			CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (!sf)
+		return -1;
+
+	sf_addr_lo = 6 * sf->sector_size;
+	sf_addr_hi = sf_addr_lo + 0x1000000;
+
+	p8 = (volatile uint8_t *)ram_addr;
+	printf("\n>>> Init pattern in RAM @ %p\n", p8);
+	for (i = 0; i < pattern_len; i++) {
+		j = 4;
+		while (j--)
+			*p8++ = i;
+	}
+
+	p = (void *)ram_addr;
+	print_buffer(ram_addr, p, 4, pattern_len, 0);
+
+	printf(">>> Erasing flash at offset %04lx and len %04x\n", sf_addr_lo, sf->sector_size);
+	ret = spi_flash_erase(sf, sf_addr_lo, sf->sector_size);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	printf(">>> Write pattern to flash at offset %04lx\n", sf_addr_lo);
+	ret = spi_flash_write(sf, sf_addr_lo, 4 * pattern_len, (const void *)ram_addr);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	p += 4 * pattern_len;
+	printf(">>> Read back pattern from flash @ %04lx to RAM @ %p\n", sf_addr_lo, p);
+	ret = spi_flash_read(sf, sf_addr_lo, 4 * pattern_len, p);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	print_buffer((ulong)p, p, 4, pattern_len, 0);
+
+	if (!sf->set_4byte_addressing || sf->size <= 0x1000000) {
+		puts(">>> Skipping 4-byte addressing test\n");
+		ret = 0;
+		goto out;
+	}
+
+	printf(">>> Erasing flash at offset %04lx and len %04x\n", sf_addr_hi, sf->sector_size);
+	ret = spi_flash_erase(sf, sf_addr_hi, sf->sector_size);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	printf(">>> Write pattern to flash at offset %04lx\n", sf_addr_hi);
+	ret = spi_flash_write(sf, sf_addr_hi, 4 * pattern_len, (const void *)ram_addr);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	p += 4 * pattern_len;
+	printf(">>> Read back pattern from flash @ %04lx to RAM @ %p\n", sf_addr_hi, p);
+	ret = spi_flash_read(sf, sf_addr_hi, 4 * pattern_len, p);
+	if (ret) {
+		puts(" -> failed\n");
+		goto out;
+	}
+
+	print_buffer((ulong)p, p, 4, pattern_len, 0);
+
+out:
+	spi_flash_free(sf);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_test_sf, 1, 0, do_sas_test_sf,
+	   "Sphairon test program for SPI flash", NULL);
diff --git a/lib/sphairon/cmd_sas_upgrade.c b/lib/sphairon/cmd_sas_upgrade.c
new file mode 100644
index 0000000000000000000000000000000000000000..92077f3fb85e2a140c4f34f5aaf5e74530f3369d
--- /dev/null
+++ b/lib/sphairon/cmd_sas_upgrade.c
@@ -0,0 +1,440 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+#include <sas/boot.h>
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#if defined(CONFIG_LTQ_SPL_COMP_LZO)
+#define SAS_UBOOT_USED		SAS_UBOOT_LZO_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_LZO_IMAGE
+#elif defined(CONFIG_LTQ_SPL_COMP_LZMA)
+#define SAS_UBOOT_USED		SAS_UBOOT_LZMA_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_LZMA_IMAGE
+#else
+#define SAS_UBOOT_USED		SAS_UBOOT_SFSPL
+#define SAS_UBOOT_ALT		SAS_UBOOT_IMAGE
+#endif
+#else
+#define SAS_UBOOT_USED		SAS_UBOOT_BIN
+#define SAS_UBOOT_ALT		SAS_UBOOT_IMAGE
+#endif
+
+static int sas_upgrade_images_load(const char *name1, ulong *addr1,
+				   size_t *size1, const char *name2,
+				   ulong *addr2, size_t *size2)
+{
+	ulong loadaddr;
+	size_t size;
+
+	loadaddr = getenv_ulong("loadaddr", 16, 0);
+
+	size = sas_run_tftpboot(loadaddr, name1);
+	if (!size)
+		goto err;
+
+	*addr1 = loadaddr;
+	*size1 = size;
+
+	debug("addr1 %08lx, size1 %zu\n", *addr1, *size1);
+
+	if (!name2)
+		return 0;
+
+	loadaddr += size + 1;
+	loadaddr = ROUND(loadaddr, 32);
+
+	size = sas_run_tftpboot(loadaddr, name2);
+	if (!size)
+		goto err;
+
+	*addr2 = loadaddr;
+	*size2 = size;
+
+	debug("addr2 %08lx, size2 %zu\n", *addr2, *size2);
+
+	return 0;
+
+err:
+	puts("Could not load images\n");
+
+	return 1;
+}
+
+static int sas_upgrade_image_load(cmd_tbl_t * cmdtp, int argc,
+				  char *const argv[], const char *image,
+				  ulong *addr, size_t *size)
+{
+	int ret;
+	ulong val;
+
+	if (argc == 1) {
+		return sas_upgrade_images_load(image, addr, size,
+						NULL, NULL, NULL);
+	} else if (argc == 3) {
+		ret = strict_strtoul(argv[1], 16, &val);
+		if (ret)
+			return 1;
+
+		*addr = val;
+
+		ret = strict_strtoul(argv[2], 16, &val);
+		if (ret)
+			return 1;
+
+		if (!val) {
+			printf("Invalid size %08zx\n", *size);
+			return 1;
+		}
+
+		*size = val;
+
+		return 0;
+	}
+
+	return cmd_usage(cmdtp);
+}
+
+static int sas_upgrade_image_check(ulong addr, sas_image_type_t image_type)
+{
+	int ret;
+	sas_image_type_t type;
+	const image_header_t *hdr = (const image_header_t *) addr;
+
+	type = sas_image_type(hdr);
+	if (type != image_type) {
+		puts("invalid image type\n");
+		return 0;
+	}
+
+	ret = sas_run_command("iminfo %p", hdr);
+	if (ret)
+		return 0;
+
+	return 1;
+}
+
+static int do_sas_upgrade_uboot(cmd_tbl_t * cmdtp, int flag,
+				int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	ulong loadaddr, cd_offset;
+	size_t size;
+	int ret;
+
+	ret = sas_confirm("Caution: this can damage your board");
+	if (!ret)
+		return 0;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_UBOOT_USED,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	if (size >= part->size) {
+		puts("Image size too big\n");
+		return 1;
+	}
+
+	cd_offset = sas_flash_cd_offset(part);
+	if (size >= cd_offset) {
+		puts("Image size leads to overwriting of CD/ETL area\n");
+		return 1;
+	}
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_complete_write(part, 0, size, size,
+					(const void *) loadaddr, 1);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_uboot, 3, 0, do_sas_upgrade_uboot,
+	"Update U-Boot in flash", "[addr] [size]\n");
+
+static int do_sas_upgrade_uboot_alt(cmd_tbl_t * cmdtp, int flag,
+				    int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	ulong loadaddr;
+	size_t size;
+	int ret;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_UPDATE);
+	if (!part)
+		return 1;
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_UBOOT_ALT,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	if (size >= part->size) {
+		puts("Image size too big\n");
+		return 1;
+	}
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_complete_write(part, 0, size, size,
+					(const void *) loadaddr, 0);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_uboot_alt, 3, 0, do_sas_upgrade_uboot_alt,
+	"Update alternate U-Boot in flash", "[addr] [size]\n");
+
+static int do_sas_erase_uboot_alt(cmd_tbl_t * cmdtp, int flag,
+				  int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_UPDATE);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_erase(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_uboot_alt, 1, 0, do_sas_erase_uboot_alt,
+	"Erase second U-Boot in flash", "");
+
+static int do_sas_upgrade_etl(cmd_tbl_t * cmdtp, int flag,
+			      int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	ulong loadaddr, etl_offset;
+	size_t size;
+	int ret;
+
+	ret = sas_confirm("Caution: this can damage your board");
+	if (!ret)
+		return 0;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	ret = sas_upgrade_image_load(cmdtp, argc, argv, SAS_TYPELABEL_BIN,
+					&loadaddr, &size);
+	if (ret)
+		return ret;
+
+	if (size >= sas_flash_etl_size()) {
+		puts("Image size too big\n");
+		return 1;
+	}
+
+	etl_offset = sas_flash_etl_offset(part);
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_complete_write(part, etl_offset, size,
+					sas_flash_etl_size(),
+					(const void *) loadaddr, 1);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_etl, 3, 0, do_sas_upgrade_etl,
+	"Update ETL in flash", "[addr] [size]\n");
+
+static int do_sas_erase_etl(cmd_tbl_t * cmdtp, int flag,
+			    int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+	ulong etl_offset;
+
+	ret = sas_confirm("Caution: this can damage your board");
+	if (!ret)
+		return 0;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_FIX);
+	if (!part)
+		return 1;
+
+	etl_offset = sas_flash_etl_offset(part);
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_unlock(part, 0, part->size);
+	if (ret)
+		goto done;
+
+	ret = sas_flash_partial_erase(part, etl_offset,
+					sas_flash_etl_size());
+
+done:
+	sas_flash_lock(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_etl, 1, 0, do_sas_erase_etl,
+	"Erase ETL in flash", "");
+
+static int do_sas_erase_uboot_cfg(cmd_tbl_t * cmdtp, int flag,
+			    int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_CFG);
+	if (!part)
+		return 1;
+
+	sas_flash_verbose_set(1);
+	ret = sas_flash_unlock(part, 0, part->size);
+	if (ret)
+		goto done;
+
+	ret = sas_flash_erase(part, 0, part->size);
+
+done:
+	sas_flash_lock(part, 0, part->size);
+	sas_flash_verbose_set(0);
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_erase_uboot_cfg, 1, 0, do_sas_erase_uboot_cfg,
+	"Erase U-Boot config in flash", "");
+
+static inline void sas_upgrade_index(int argc, char *const argv[], int *index)
+{
+	int ret;
+	ulong val;
+
+	if (argc == 1) {
+		*index = 0;
+		return;
+	}
+
+	ret = strict_strtoul(argv[1], 10, &val);
+	if (ret) {
+		*index = -1;
+		return;
+	}
+
+	*index = val - 1;
+}
+
+static int do_sas_upgrade_platform(cmd_tbl_t * cmdtp, int flag,
+				   int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int index = 0, ret;
+	ulong uimage_srcaddr, uimage_dstaddr;
+	ulong rootfs_srcaddr, rootfs_dstaddr;
+	size_t uimage_size, rootfs_size, erase_len;
+
+	sas_upgrade_index(argc, argv, &index);
+	part = sas_flash_layout_image_partition(index);
+	if (!part) {
+		puts("Invalid index or partition\n");
+		return 1;
+	}
+
+	debug("using partition %s\n", part->mtd->name);
+
+	ret = sas_upgrade_images_load(SAS_KERNEL_IMAGE, &uimage_srcaddr,
+					&uimage_size, SAS_ROOTFS_IMAGE,
+					&rootfs_srcaddr, &rootfs_size);
+	if (ret)
+		return ret;
+
+	ret = sas_upgrade_image_check(uimage_srcaddr, SAS_IMG_KERNEL);
+	if (!ret)
+		return 1;
+
+	ret = sas_upgrade_image_check(rootfs_srcaddr, SAS_IMG_ROOTFS);
+	if (!ret)
+		return 1;
+
+	ret = sas_boot_platform_layout(part, uimage_size, rootfs_size,
+					&uimage_dstaddr, &rootfs_dstaddr,
+					&erase_len);
+	if (ret)
+		return ret;
+
+	sas_flash_verbose_set(1);
+
+	ret = sas_flash_complete_write(part, uimage_dstaddr, uimage_size,
+					erase_len,
+					(const void *) uimage_srcaddr, 1);
+	if (ret)
+		goto done;
+
+	ret = sas_flash_write(part, rootfs_dstaddr, rootfs_size,
+				(const void *) rootfs_srcaddr);
+
+done:
+	sas_flash_verbose_set(0);
+	ret = sas_boot_image_scan();
+
+	return ret;
+}
+
+U_BOOT_CMD(sas_upgrade_platform, 2, 0, do_sas_upgrade_platform,
+	"Update kernel and rootfs in flash", "[index]");
+
+static int do_sas_upgrade_service(cmd_tbl_t * cmdtp, int flag,
+				  int argc, char *const argv[])
+{
+	struct sas_flash_partition *part;
+	int index = 0, ret;
+	ulong servicefs_addr, configfs_addr;
+	size_t servicefs_size, configfs_size;
+
+	sas_upgrade_index(argc, argv, &index);
+	part = sas_flash_layout_image_partition(index);
+	if (!part) {
+		puts("Invalid index or partition\n");
+		return 1;
+	}
+
+	debug("using partition %s\n", part->mtd->name);
+
+	ret = sas_upgrade_images_load(SAS_SERVICEFS_IMAGE, &servicefs_addr,
+					&servicefs_size, SAS_CONFIGFS_IMAGE,
+					&configfs_addr, &configfs_size);
+	if (ret)
+		return ret;
+
+	ret = sas_upgrade_image_check(servicefs_addr, SAS_IMG_SERVICEFS);
+	if (!ret)
+		return 1;
+
+	ret = sas_upgrade_image_check(configfs_addr, SAS_IMG_DEFCONFIG);
+	if (!ret)
+		return 1;
+
+	return 0;
+}
+
+U_BOOT_CMD(sas_upgrade_service, 2, 0, do_sas_upgrade_service,
+	"Update servicefs and defconfig in flash", "[index]");
diff --git a/lib/sphairon/etl.c b/lib/sphairon/etl.c
new file mode 100644
index 0000000000000000000000000000000000000000..df220b15a9104cfca0635e9ce6116faee41940dc
--- /dev/null
+++ b/lib/sphairon/etl.c
@@ -0,0 +1,254 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/etl.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+
+static u_char *sas_etl_buf;
+static int sas_etl_ver;
+
+static int sas_etl_import(void)
+{
+	struct sas_flash_partition *part;
+	int ret;
+
+	debug("sas_etl: initializing\n");
+
+	part = sas_flash_partition_get(SAS_PART_UBOOT_FIX);
+	if (!part) {
+		debug("sas_etl: sas_flash_partition_get failed\n");
+		return 1;
+	}
+
+	sas_etl_buf = malloc(sas_flash_etl_size());
+	if (!sas_etl_buf) {
+		debug("sas_etl: malloc failed\n");
+		return 1;
+	}
+
+	ret = sas_flash_read(part, sas_flash_etl_offset(part),
+			sas_flash_etl_size(), sas_etl_buf);
+	if (ret) {
+		debug("sas_etl: sas_flash_read failed\n");
+		goto err;
+	}
+
+	sas_etl_ver = 0;
+	if (sas_etl_buf[0] != 0xFF)
+		sas_etl_ver = 2;
+
+	return 0;
+
+err:
+	free(sas_etl_buf);
+
+	return ret;
+}
+
+static inline void sas_etl_banner_print(const char *name, const char *buf)
+{
+	sas_banner_content_print("%-25s%-s ", name, buf);
+}
+
+static inline int sas_etl_check_eth_addr(const char *buf)
+{
+	return 0;
+}
+
+static int sas_etl_parse(int *save_env)
+{
+	char buf[40];
+	int ret;
+
+	sas_banner_header_print("Sphairon type label v%u", sas_etl_ver);
+
+	/* Compat values for userspace */
+	sas_setenv("etl_exists", "1", save_env);
+
+	/* Trivial name of board */
+	sas_etl_get_string(SAS_ETL_TRIV_NAME, buf, 32,
+				CONFIG_IDENT_STRING, 0);
+	sas_setenv("etl_triv_name", buf, save_env);
+	sas_etl_banner_print("Product name", buf);
+
+	/* Ident number */
+	sas_etl_get_string(SAS_ETL_IDENT_NO, buf, 6, "0", 0);
+	sas_setenv("etl_ident_no", buf, save_env);
+	sas_etl_banner_print("Ident number", buf);
+
+	/* Base platform */
+	sas_etl_get_string(SAS_ETL_BASE_PLATFORM, buf, 4, "0", 0);
+	sas_setenv("etl_base_platform", buf, save_env);
+	sas_etl_banner_print("Base platform", buf);
+
+	/* Flash layout */
+	sas_etl_get_string(SAS_ETL_FLASH_LAYOUT, buf, 8,
+				CONFIG_SPHAIRON_FLASHLAYOUT, 0);
+	sas_setenv("etl_flash_layout", buf, save_env);
+	sas_etl_banner_print("Flash layout", buf);
+
+	sas_banner_line_print();
+
+	/* Hardware version */
+	sas_etl_get_string(SAS_ETL_HW_VERSION, buf, 4, NULL, 'x');
+	sas_setenv("etl_hw_version", buf, save_env);
+	sas_etl_banner_print("HW version", buf);
+
+	/* Serial number */
+	sas_etl_get_string(SAS_ETL_SERIAL, buf, 13, NULL, 'x');
+	sas_setenv("etl_serial_no", buf, save_env);
+	sas_etl_banner_print("Serial number", buf);
+
+	/* Extra serial number */
+	sas_etl_get_string(SAS_ETL_SERIAL_EXTRA, buf, 15, NULL, 'x');
+	sas_setenv("etl_serial_extra", buf, save_env);
+	sas_etl_banner_print("Serial number extra", buf);
+
+	/* Production date */
+	sas_etl_get_string(SAS_ETL_PROD_DATE, buf, 10, NULL, 'x');
+	sas_setenv("etl_prod_date", buf, save_env);
+	sas_etl_banner_print("Date of production", buf);
+
+	/* MAC address */
+	ret = sas_etl_get_string(SAS_ETL_MAC_ADDR, buf, 17, NULL, 0);
+	if (!ret) {
+		ret = sas_etl_check_eth_addr(buf);
+		if (!ret)
+			sas_setenv("ethaddr", buf, save_env);
+	}
+	sas_etl_banner_print("MAC address", getenv("ethaddr"));
+
+	/* WLAN module */
+	sas_etl_get_string(SAS_ETL_WLAN_MODULE, buf, 32, NULL, 'x');
+	sas_setenv("etl_wlan_module", buf, save_env);
+	sas_etl_banner_print("WLAN module", buf);
+
+	/* WLAN SSID */
+	sas_etl_get_string(SAS_ETL_WLAN_SSID, buf, 32, "default", 0);
+	sas_setenv("etl_wlan_ssid", buf, save_env);
+	sas_etl_banner_print("WLAN SSID", buf);
+
+	/* WLAN Key */
+	sas_etl_get_string(SAS_ETL_WLAN_KEY, buf, 26, NULL, 'x');
+	sas_setenv("etl_wlan_wep_key", buf, save_env);
+	sas_etl_banner_print("WLAN key", buf);
+
+	/* WLAN WPS PIN */
+	sas_etl_get_string(SAS_ETL_WPS_PIN, buf, 16, NULL, 'x');
+	sas_setenv("etl_wlan_wps_pin", buf, save_env);
+	sas_etl_banner_print("WLAN WPS PIN", buf);
+
+	sas_banner_footer_print();
+
+	return 0;
+}
+
+int sas_etl_init(int *save_env)
+{
+	int ret;
+
+	ret = sas_etl_import();
+	if (ret)
+		return ret;
+
+	ret = sas_etl_parse(save_env);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void sas_etl_print(void)
+{
+	int save_env;
+
+	sas_etl_parse(&save_env);
+}
+
+static const u_char * sas_etl_match(unsigned id, size_t *retlen)
+{
+	const u_char *p;
+	u8 idx;
+	size_t len;
+
+	p = sas_etl_buf;
+	do {
+		idx = *p++;
+		len = *p++;
+
+		if (idx == id && len) {
+			*retlen = len;
+			return p;
+		}
+
+		p += len;
+	} while (idx && len &&
+		((p - sas_etl_buf) < sas_flash_etl_size()));
+
+	return NULL;
+}
+
+int sas_etl_get_string(unsigned int id, char *retval, size_t len,
+				const char *defval, char fill)
+{
+	size_t retlen = 0;
+	const void *p;
+
+	p = sas_etl_match(id, &retlen);
+	if (!p) {
+		if (!defval) {
+			if (fill) {
+				memset(retval, fill, len);
+				retval[len] = 0;
+				return 0;
+			}
+			return -1;
+		}
+		p = defval;
+		retlen = len;
+	}
+
+	if (retlen > len)
+		retlen = len;
+
+	memcpy(retval, p, retlen);
+	retval[retlen] = 0;
+
+	return 0;
+}
+
+int sas_etl_get_ulong(unsigned int id, unsigned long *retval,
+			unsigned int base, unsigned long defval)
+{
+	size_t retlen = 0;
+	const void *p;
+	char buf[32];
+
+	p = sas_etl_match(id, &retlen);
+	if (!p) {
+		*retval = defval;
+		return 0;
+	}
+
+	memcpy(buf, p, sizeof(buf));
+	buf[retlen] = 0;
+
+	return strict_strtoul(buf, base, retval);
+}
+
+int sas_etl_version(void)
+{
+	return sas_etl_ver;
+}
diff --git a/lib/sphairon/flash.c b/lib/sphairon/flash.c
new file mode 100644
index 0000000000000000000000000000000000000000..5698c6caf9e034d19743ebb98fea123d16c33248
--- /dev/null
+++ b/lib/sphairon/flash.c
@@ -0,0 +1,465 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <malloc.h>
+#include <spi_flash.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <sas/flash.h>
+#include <sas/util.h>
+
+#define SAS_FLASH_MAX_DEVICES	4
+
+/* should be ltq-nor for upstream linux */
+#define SAS_MTDID_LTQ_NOR	"bank1";
+#define SAS_MTDID_M25P80	"m25p80";
+
+extern struct mtd_info *mtd_table[MAX_MTD_DEVICES];
+
+#define mtd_for_each_device(mtd)		\
+	for ((mtd) = mtd_table[0];		\
+		(mtd) != NULL;			\
+		(mtd) = mtd_table[(mtd)->index + 1])
+
+static struct mtd_info *sas_flash_devs[SAS_FLASH_MAX_DEVICES];
+static int sas_flash_dev_num;
+
+static struct list_head sas_flash_partitions;
+static int sas_flash_part_num;
+
+static int sas_flash_verbose;
+
+int sas_flash_init(void)
+{
+	struct mtd_info *mtd;
+
+	debug("sas_flash: initializing\n");
+
+	INIT_LIST_HEAD(&sas_flash_partitions);
+
+	mtd_for_each_device(mtd) {
+		debug("sas_flash: found MTD device %s\n", mtd->name);
+		sas_flash_devs[sas_flash_dev_num++] = mtd;
+	}
+
+	if (!sas_flash_dev_num)
+		return 1;
+
+	return 0;
+}
+
+void sas_flash_verbose_set(int v)
+{
+	sas_flash_verbose = v;
+}
+
+const char * sas_flash_boot_device(void)
+{
+#if defined(CONFIG_FLASH_CFI_MTD)
+#if defined(CONFIG_SPI_FLASH_MTD) && defined(CONFIG_SYS_BOOT_SFSPL)
+	return "nor1";
+#else
+	return "nor0";
+#endif
+#elif defined(CONFIG_SPI_FLASH_MTD)
+	return "nor0";
+#else
+	return "nor0";
+#endif
+}
+
+const char * sas_flash_linux_mtdid(const struct mtd_info *mtd)
+{
+#if defined(CONFIG_FLASH_CFI_MTD)
+	if (0 == strcmp(mtd->name, "nor0"))
+		return SAS_MTDID_LTQ_NOR;
+#if defined(CONFIG_SPI_FLASH_MTD)
+	if (0 == strcmp(mtd->name, "nor1"))
+		return SAS_MTDID_M25P80;
+#endif
+#elif defined(CONFIG_SPI_FLASH_MTD)
+	if (0 == strcmp(mtd->name, "nor0"))
+		return SAS_MTDID_M25P80;
+#endif
+
+	return NULL;
+}
+
+struct sas_flash_partition * sas_flash_partition_add(struct mtd_info *master,
+						sas_flash_partition_t type,
+						size_t size, size_t offset,
+						int locked)
+{
+	struct sas_flash_partition *part;
+
+	part = malloc(sizeof(*part));
+	assert(part);
+
+	INIT_LIST_HEAD(&part->link);
+	part->master = master;
+	part->mtd = NULL;
+	part->type = type;
+	part->offset = offset;
+	part->size = size;
+	part->locked = locked;
+
+	list_add_tail(&part->link, &sas_flash_partitions);
+
+	sas_flash_part_num++;
+
+	return part;
+}
+
+struct sas_flash_partition * sas_flash_partition_get(
+						sas_flash_partition_t type)
+{
+	struct sas_flash_partition *part;
+
+	list_for_each_entry(part, &sas_flash_partitions, link)
+		if (part->type == type)
+			return part;
+
+	return NULL;
+}
+
+void sas_flash_device_foreach(sas_flash_device_cb cb, void *data)
+{
+	int i;
+	struct mtd_info *mtd;
+
+	for (i = 0; i < sas_flash_dev_num; i++) {
+		mtd = sas_flash_devs[i];
+		cb(mtd, data);
+	}
+}
+
+void sas_flash_partition_foreach(struct mtd_info *master,
+				sas_flash_partition_cb cb, void *data)
+{
+	struct sas_flash_partition *part;
+
+	list_for_each_entry(part, &sas_flash_partitions, link) {
+		if (part->master == master)
+			cb(part, data);
+	}
+}
+
+int sas_flash_partition_mtd_update(struct mtd_info *master)
+{
+	int i = 0, do_add = 0, ret;
+	struct mtd_partition *mtd_part, mtd_parts[12];
+	struct sas_flash_partition *part;
+
+	memset(mtd_parts, 0, sizeof(mtd_parts));
+
+	list_for_each_entry(part, &sas_flash_partitions, link) {
+		if (part->mtd)
+			continue;
+
+		if (master != part->master)
+			continue;
+
+		mtd_part = &mtd_parts[i++];
+		mtd_part->name =
+			(char *) sas_flash_partition_str(part->type);
+		mtd_part->offset = part->offset;
+		mtd_part->size = part->size;
+		do_add = 1;
+	}
+
+	if (!do_add)
+		return 0;
+
+	ret = add_mtd_partitions(master, mtd_parts, i);
+	if (ret)
+		return ret;
+
+	list_for_each_entry(part, &sas_flash_partitions, link)
+		part->mtd = get_mtd_device_nm(
+			sas_flash_partition_str(part->type));
+
+	return 0;
+}
+
+void sas_flash_partition_print(void)
+{
+	struct mtd_info *mtd;
+	struct sas_flash_partition *part;
+	int i = 0, dev;
+
+	for (dev = 0; dev < sas_flash_dev_num; dev++) {
+		mtd = sas_flash_devs[dev];
+
+		sas_banner_line_print();
+		sas_banner_content_print("Device %s:", mtd->name);
+
+		list_for_each_entry(part, &sas_flash_partitions, link) {
+			if (mtd != part->master)
+				continue;
+
+			sas_banner_content_print("%-24s %8x @ %08x",
+						part->mtd->name,
+						part->size, part->offset);
+			i++;
+		}
+	}
+}
+
+static inline void sas_flash_info_print(const char *func,
+					const struct sas_flash_partition *part,
+					ulong from, size_t len,
+					const void *buf)
+{
+	if (sas_flash_verbose) {
+		printf("%s: %x bytes @ %lx on %s ",
+			func, len, from, part->mtd->name);
+		if (buf)
+			printf("from %p ", buf);
+		puts("... ");
+	}
+}
+
+static inline void sas_flash_result_print(int result)
+{
+	if (result)
+		printf("failed (%d)\n", result);
+	else if (sas_flash_verbose)
+		puts("done\n");
+}
+
+int sas_flash_read(const struct sas_flash_partition *part,
+			ulong from, size_t len, void *buf)
+{
+	int ret;
+	size_t retlen;
+
+	sas_flash_info_print(__func__, part, from, len, buf);
+
+	ret = part->mtd->read(part->mtd, from, len, &retlen, buf);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_write(const struct sas_flash_partition *part,
+			ulong to, size_t len, const void *buf)
+{
+	int ret;
+	size_t retlen;
+
+	sas_flash_info_print(__func__, part, to, len, buf);
+
+	ret = part->mtd->write(part->mtd, to, len, &retlen, buf);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_lock(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	int ret = 0;
+	size_t erase_len = sas_flash_roundb(part, len);
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	if (part->mtd->lock)
+		ret = part->mtd->lock(part->mtd, off, erase_len);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_unlock(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	int ret = 0;
+	size_t erase_len = sas_flash_roundb(part, len);
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	if (part->mtd->unlock)
+		ret = part->mtd->unlock(part->mtd, off, erase_len);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_erase(const struct sas_flash_partition *part,
+			ulong off, size_t len)
+{
+	struct erase_info instr;
+	int ret;
+	size_t erase_len = sas_flash_roundb(part, len);
+
+	instr.mtd = part->mtd;
+	instr.addr = off;
+	instr.len = erase_len;
+	instr.callback = NULL;
+
+	sas_flash_info_print(__func__, part, off, erase_len, NULL);
+
+	ret = part->mtd->erase(part->mtd, &instr);
+
+	sas_flash_result_print(ret);
+
+	return ret;
+}
+
+int sas_flash_partial_erase(const struct sas_flash_partition *part,
+				ulong off, size_t len)
+{
+	struct erase_info instr;
+	int ret;
+	ulong pre_start = 0, pre_end = 0, post_start = 0, post_end = 0;
+	ulong erase_start, erase_end;
+	size_t pre_size, post_size, erase_len, retlen;
+	void *pre_data = NULL, *post_data = NULL;
+
+	sas_flash_info_print(__func__, part, off, len, NULL);
+
+	if (part->mtd->numeraseregions)
+		printf("\n%s: note: not yet optimized for non-uniform "
+			"flash devices\n", __func__);
+
+	pre_size = off % part->mtd->erasesize;
+	if (pre_size) {
+		pre_start = off - pre_size;
+		pre_size--;
+		pre_end = off - 1;
+		erase_start = pre_start;
+
+		pre_data = malloc(pre_size);
+		if (!pre_data) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		ret = part->mtd->read(part->mtd, pre_start, pre_size,
+					&retlen, pre_data);
+		if (ret)
+			goto done;
+	} else
+		erase_start = off;
+
+	post_size = (off + len) % part->mtd->erasesize;
+	if (post_size) {
+		post_end = sas_flash_roundb(part, off + len) - 1;
+		post_start = off + len;
+		post_size = post_end - post_start;
+		erase_end = post_end;
+
+		post_data = malloc(post_size);
+		if (!post_data) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		ret = part->mtd->read(part->mtd, post_start, post_size,
+					&retlen, post_data);
+		if (ret)
+			goto done;
+	} else
+		erase_end = off + len - 1;
+
+	erase_len = erase_end - erase_start + 1;
+
+	instr.mtd = part->mtd;
+	instr.addr = erase_start;
+	instr.len = erase_len;
+	instr.callback = NULL;
+
+	ret = part->mtd->erase(part->mtd, &instr);
+	if (ret)
+		goto done;
+
+	if (pre_data) {
+		ret = part->mtd->write(part->mtd, pre_start, pre_size,
+					&retlen, pre_data);
+		if (ret)
+			goto done;
+	}
+
+	if (post_data) {
+		ret = part->mtd->write(part->mtd, post_start, post_size,
+					&retlen, post_data);
+		if (ret)
+			goto done;
+	}
+
+done:
+	sas_flash_result_print(ret);
+
+	if (pre_data)
+		free(pre_data);
+
+	if (post_data)
+		free(post_data);
+
+	return ret;
+}
+
+int sas_flash_complete_write(const struct sas_flash_partition *part,
+				ulong to, size_t write_len,
+				size_t erase_len, const void *buf,
+				int partial_erase)
+{
+	int ret;
+
+	if (part->locked) {
+		ret = sas_flash_unlock(part, 0, part->size);
+		if (ret)
+			return ret;
+	}
+
+	if (partial_erase)
+		ret = sas_flash_partial_erase(part, to, erase_len);
+	else
+		ret = sas_flash_erase(part, to, erase_len);
+
+	if (ret)
+		return ret;
+
+	ret = sas_flash_write(part, to, write_len, buf);
+	if (ret)
+		return ret;
+
+	if (part->locked)
+		sas_flash_lock(part, 0, part->size);
+
+	return 0;
+}
+
+static const char sas_flash_partition_strings[][16] = {
+	"uboot_fix",
+	"uboot_cfg",
+	"uboot_update",
+	"syscfg1",
+	"syscfg2",
+	"images1",
+	"images2",
+	"images3",
+	"device",
+	"invalid"
+};
+
+const char* sas_flash_partition_str(sas_flash_partition_t type)
+{
+	assert(type <= SAS_PART_INVALID);
+
+	return sas_flash_partition_strings[type];
+}
diff --git a/lib/sphairon/flashlayout.c b/lib/sphairon/flashlayout.c
new file mode 100644
index 0000000000000000000000000000000000000000..2d738a3d410f1fa0497f53f9877400b4b52e0f37
--- /dev/null
+++ b/lib/sphairon/flashlayout.c
@@ -0,0 +1,272 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/flashlayout.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+
+#if defined(CONFIG_ENV_OFFSET) && defined(CONFIG_ENV_SECT_SIZE)
+#define sas_have_mtd_uboot_cfg		1
+#define sas_have_mtd_uboot_update	1
+#else
+#define sas_have_mtd_uboot_cfg		0
+#define sas_have_mtd_uboot_update	0
+#define CONFIG_ENV_OFFSET		0
+#define CONFIG_ENV_SECT_SIZE		0
+#endif
+
+struct sas_layout_map {
+	const char name[4];
+	const char desc[28];
+};
+
+static sas_flash_layout_t sas_flash_layout;
+static size_t sas_flash_layout_offset;
+
+static inline size_t sas_round_size(struct mtd_info *mtd, size_t min_size)
+{
+	size_t size, d;
+
+	if (!(min_size % mtd->erasesize))
+		return min_size;
+
+	d = min_size / mtd->erasesize;
+	size = (d + 1) * mtd->erasesize;
+
+	return size;
+}
+
+static void sas_flash_layout_default(struct mtd_info *mtd)
+{
+	size_t size, offset;
+
+	/* uboot_fix: size = env offset @ 0 */
+	offset = 0;
+	size = CONFIG_ENV_OFFSET;
+	sas_flash_partition_add(mtd, SAS_PART_UBOOT_FIX,
+				size, offset, 1);
+
+	/* uboot_cfg: env sector size @ env offset */
+	if (sas_have_mtd_uboot_cfg) {
+		offset = CONFIG_ENV_OFFSET;
+		size = CONFIG_ENV_SECT_SIZE;
+		sas_flash_partition_add(mtd, SAS_PART_UBOOT_CFG,
+					size, offset, 1);
+	}
+
+	/* uboot_update: size = env offset */
+	if (sas_have_mtd_uboot_update) {
+		offset += size;
+		size = sas_round_size(mtd, 128 * 1024);
+		sas_flash_partition_add(mtd, SAS_PART_UBOOT_UPDATE,
+					size, offset, 0);
+	}
+
+	sas_flash_layout_offset = offset + size;
+	sas_flash_layout = SAS_LAYOUT_BASIC;
+}
+
+static void sas_flash_layout_extended(struct mtd_info *mtd,
+				sas_flash_layout_t layout)
+{
+	size_t size, offset, image_size;
+	const int image_cnt =
+		sas_flash_layout_image_partitions(layout);
+
+	/* syscfg1: 128k */
+	offset = sas_flash_layout_offset;
+	size = sas_round_size(mtd, 128 * 1024);
+	sas_flash_partition_add(mtd, SAS_PART_SYSCFG1,
+				size, offset, 0);
+
+	/* syscfg2: 128k */
+	if (sas_flash_layout_is_mirrored(layout)) {
+		offset += size;
+		size = sas_round_size(mtd, 128 * 1024);
+		sas_flash_partition_add(mtd, SAS_PART_SYSCFG2,
+					size, offset, 0);
+	}
+
+	/* calculate remaining flash space */
+	offset += size;
+	image_size = mtd->size - offset;
+
+	switch (image_cnt) {
+	case 1:
+		size = image_size;
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES1,
+					size, offset, 0);
+		break;
+	case 2:
+		size = sas_round_size(mtd, image_size / 2);
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES1,
+					size, offset, 0);
+
+		offset += size;
+		size = mtd->size - offset;
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES2,
+					size, offset, 0);
+		break;
+	case 3:
+		size = sas_round_size(mtd, image_size / 3);
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES1,
+					size, offset, 0);
+
+		offset += size;
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES2,
+					size, offset, 0);
+
+		offset += size;
+		size = mtd->size - offset;
+		sas_flash_partition_add(mtd, SAS_PART_IMAGES3,
+					size, offset, 0);
+		break;
+	}
+
+	sas_flash_layout = layout;
+}
+
+int sas_flash_layout_basic_init(struct mtd_info *mtd)
+{
+	debug("sas_flash_layout: init basic layout on MTD device %s\n",
+		mtd->name);
+
+	sas_flash_layout_default(mtd);
+
+	return sas_flash_partition_mtd_update(mtd);
+}
+
+int sas_flash_layout_full_init(struct mtd_info *mtd,
+				int *save_env)
+{
+	sas_flash_layout_t layout;
+
+	layout = sas_flash_layout_parse(getenv("etl_flash_layout"));
+	if (layout == SAS_LAYOUT_INVALID)
+		return 1;
+
+	debug("sas_flash_layout: init full layout %s on MTD device %s\n",
+		sas_flash_layout_str(layout), mtd->name);
+
+	sas_flash_layout_extended(mtd, layout);
+
+	return sas_flash_partition_mtd_update(mtd);
+}
+
+int sas_flash_layout_device_init(struct mtd_info *mtd)
+{
+	debug("sas_flash_layout: init one partition for whole MTD device %s\n",
+		mtd->name);
+
+	sas_flash_partition_add(mtd, SAS_PART_DEVICE,
+				mtd->size, 0, 0);
+
+	return sas_flash_partition_mtd_update(mtd);
+}
+
+void sas_flash_layout_print(void)
+{
+	sas_banner_header_print("Flash partition info");
+	sas_banner_content_print("%-25s%-s ", "Used layout",
+					sas_flash_layout_str(sas_flash_layout));
+	sas_flash_partition_print();
+	sas_banner_footer_print();
+}
+
+int sas_flash_layout_is_mirrored(sas_flash_layout_t layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_HANOI:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int sas_flash_layout_image_partitions(sas_flash_layout_t layout)
+{
+	switch (layout) {
+	case SAS_LAYOUT_PLATFORM_ONLY_SINGLE:
+	case SAS_LAYOUT_PLATFORM_SERVICE_SINGLE:
+		return 1;
+	case SAS_LAYOUT_PLATFORM_ONLY_MIRRORED:
+	case SAS_LAYOUT_PLATFORM_SERVICE_MIRRORED:
+		return 2;
+	case SAS_LAYOUT_PLATFORM_SERVICE_HANOI:
+		return 3;
+	default:
+		return 0;
+	}
+}
+
+struct sas_flash_partition * sas_flash_layout_image_partition(int index)
+{
+	const sas_flash_partition_t image_parts[] = {
+		SAS_PART_IMAGES1, SAS_PART_IMAGES2, SAS_PART_IMAGES3
+	};
+	const int image_cnt = sas_flash_layout_image_partitions(sas_flash_layout);
+
+	if (index < 0 || index >= image_cnt)
+		return NULL;
+
+	return sas_flash_partition_get(image_parts[index]);
+}
+
+sas_flash_layout_t sas_flash_layout_current(void)
+{
+	return sas_flash_layout;
+}
+
+static const struct sas_layout_map sas_flash_layout_strings[] = {
+	{ "bas", "Basic" },
+	{ "pos", "Platform only - single" },
+	{ "pom", "Platform only - mirrored" },
+	{ "pss", "Platform/Service - single" },
+	{ "psm", "Platform/Service - mirrored" },
+	{ "psh", "Platform/Service - hanoi" },
+	{ "", "invalid" }
+};
+
+const char* sas_flash_layout_name(sas_flash_layout_t layout)
+{
+	assert(layout <= SAS_LAYOUT_INVALID);
+
+	return sas_flash_layout_strings[layout].name;
+}
+
+const char* sas_flash_layout_str(sas_flash_layout_t layout)
+{
+	assert(layout <= SAS_LAYOUT_INVALID);
+
+	return sas_flash_layout_strings[layout].desc;
+}
+
+sas_flash_layout_t sas_flash_layout_parse(const char *str)
+{
+	unsigned int i;
+	const char *name;
+
+	if (!str)
+		return SAS_LAYOUT_INVALID;
+
+	for (i = 0; i < SAS_LAYOUT_INVALID; i++) {
+		name = sas_flash_layout_strings[i].name;
+
+		if (!strncmp(name, str, 3))
+			return i;
+	}
+
+	return SAS_LAYOUT_INVALID;
+}
diff --git a/lib/sphairon/image.c b/lib/sphairon/image.c
new file mode 100644
index 0000000000000000000000000000000000000000..a2e767c7acf2d7ec364b517993075223a126ad7b
--- /dev/null
+++ b/lib/sphairon/image.c
@@ -0,0 +1,143 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#
+#include <sas/image.h>
+
+int sas_image_header_check(const image_header_t *hdr)
+{
+	int format, ret;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		ret = image_check_hcrc(hdr);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+int sas_image_data_check(const image_header_t *hdr)
+{
+	int format, ret;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		ret = image_check_hcrc(hdr);
+		if (ret)
+			ret = image_check_dcrc(hdr);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const char sas_image_strings[][8] = {
+	"fdt",
+	"kernel",
+	"rootfs",
+	"servfs",
+	"defcfg",
+	"unspec",
+	"invalid"
+};
+
+const char* sas_image_type_str(sas_image_type_t type)
+{
+	assert(type <= SAS_IMG_INVALID);
+
+	return sas_image_strings[type];
+}
+
+static sas_image_type_t sas_image_type_legacy(const image_header_t *hdr)
+{
+	char name[IH_NMLEN + 1];
+	int i, ret;
+
+	sprintf(name, "%.*s", IH_NMLEN, image_get_name(hdr));
+	if (name[6] != '#')
+		return SAS_IMG_INVALID;
+
+	name[6] = 0;
+	for (i = 0; i < SAS_IMG_INVALID; i++) {
+		ret = strcmp(sas_image_strings[i], name);
+		if (!ret)
+			return i;
+	}
+
+	return SAS_IMG_INVALID;
+}
+
+sas_image_type_t sas_image_type(const image_header_t *hdr)
+{
+	int format;
+	sas_image_type_t type;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		type = sas_image_type_legacy(hdr);
+		break;
+	default:
+		type = SAS_IMG_INVALID;
+		break;
+	}
+
+	return type;
+}
+
+size_t sas_image_size(const image_header_t *hdr)
+{
+	int format;
+	size_t size;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		size = image_get_size(hdr) + sizeof(image_header_t);
+		break;
+	default:
+		size = 0;
+		break;
+	}
+
+	return size;
+}
+
+void sas_image_name(const image_header_t *hdr, char *buf)
+{
+	int format;
+	char *name;
+
+	format = genimg_get_format((void *) hdr);
+
+	switch (format) {
+	case IMAGE_FORMAT_LEGACY:
+		name = image_get_name(hdr);
+		break;
+	default:
+		name = "";
+		break;
+	}
+
+	sprintf(buf, "%s", name);
+}
diff --git a/lib/sphairon/init.c b/lib/sphairon/init.c
new file mode 100644
index 0000000000000000000000000000000000000000..5dd42a27022adccbf5d13bfaa1339dc521c60390
--- /dev/null
+++ b/lib/sphairon/init.c
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mtd/mtd.h>
+
+#include <sas/init.h>
+#include <sas/util.h>
+#include <sas/flash.h>
+#include <sas/flashlayout.h>
+#include <sas/etl.h>
+#include <sas/boot.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int sas_init_f(void)
+{
+	debug("sas_init_f\n");
+
+	return 0;
+}
+
+static void sas_int_mtd_cb(struct mtd_info *mtd, void *data)
+{
+	struct mtd_info *boot_mtd = (struct mtd_info *) data;
+
+	debug("%s: %s\n", __func__, mtd->name);
+
+	if (mtd != boot_mtd)
+		sas_flash_layout_device_init(mtd);
+}
+
+int sas_init_r(void)
+{
+	int ret;
+	int save_env = 0;
+	struct mtd_info *mtd;
+	const char *boot_dev;
+
+	debug("sas_init_r\n");
+
+	printf("Reloc: offset @ 0x%08lx\n", gd->reloc_off);
+
+	ret = sas_flash_init();
+	if (ret)
+		goto err;
+
+	boot_dev = sas_flash_boot_device();
+	if (!boot_dev)
+		goto err;
+
+	mtd = get_mtd_device_nm(boot_dev);
+	if (IS_ERR(mtd)) {
+		ret = 1;
+		goto err;
+	}
+
+	ret = sas_flash_layout_basic_init(mtd);
+	if (ret)
+		goto err;
+
+	sas_flash_device_foreach(sas_int_mtd_cb, mtd);
+
+	ret = sas_etl_init(&save_env);
+	if (ret)
+		goto err;
+
+	if (sas_etl_version()) {
+		ret = sas_flash_layout_full_init(mtd, &save_env);
+		if (ret)
+			goto err;
+
+		ret = sas_boot_init(mtd, &save_env);
+		if (ret)
+			goto err;
+
+		sas_flash_layout_print();
+		sas_boot_print();
+
+		setenv("bootcmd", "sas_boot");
+		setenv("bootdelay", "3");
+	} else
+		setenv("bootcmd", NULL);
+
+	sas_setenv_num("sas_saveenv", save_env, NULL);
+
+	return 0;
+
+err:
+	puts("Failed to initialize Sphairon lib\n");
+
+	return ret;
+}
diff --git a/lib/sphairon/util.c b/lib/sphairon/util.c
new file mode 100644
index 0000000000000000000000000000000000000000..43c2cde2efc9b28d718dfac4f6e22640d3883436
--- /dev/null
+++ b/lib/sphairon/util.c
@@ -0,0 +1,201 @@
+/*
+ * (C) Copyright 2011 Daniel Schwierzeck, daniel.schwierzeck@sphairon.com
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#define DEBUG
+
+#include <common.h>
+
+#include <sas/util.h>
+
+int sas_setenv(const char *name, const char *value, int *saveenv)
+{
+	const char *s;
+	int modified;
+
+	s = getenv(name);
+
+	modified = 1;
+	if (s && value)
+		modified = strcmp(s, value);
+
+	if (modified && saveenv)
+		*saveenv = 1;
+
+	return setenv(name, value);
+}
+
+int sas_setenv_num(const char *name, int value, int *saveenv)
+{
+	char buf[32];
+
+	sprintf(buf, "%d", value);
+
+	return sas_setenv(name, buf, saveenv);
+}
+
+int sas_setenv_hex(const char *name, int value, int *saveenv)
+{
+	char buf[32];
+
+	sprintf(buf, "0x%x", value);
+
+	return sas_setenv(name, buf, saveenv);
+}
+
+int sas_run_command(const char* fmt, ...)
+{
+	va_list args;
+	char cmd[128];
+	int ret;
+
+	va_start(args, fmt);
+	vsprintf(cmd, fmt, args);
+	va_end(args);
+
+	debug("sas_run_command: %s\n", cmd);
+
+	ret = run_command(cmd, 0);
+
+	/* error is -1, success is 0 or 1 if cmd is repeatable */
+	if (ret < 0)
+		return 1;
+
+	return 0;
+}
+
+size_t sas_run_tftpboot(ulong loadaddr, const char *file)
+{
+	size_t filesize;
+	int ret;
+
+	setenv("filesize", "0");
+	ret = sas_run_command("tftpboot %08lx %s", loadaddr, file);
+	if (ret)
+		return 0;
+
+	filesize = getenv_ulong("filesize", 16, 0);
+
+	return filesize;
+}
+
+int sas_confirm(const char *message)
+{
+	char c;
+	int ret;
+
+	puts(message);
+	for (;;) {
+		puts("\nDo you want to continue (y|n)? :");
+		c = getc();
+
+		if (c == 'y') {
+			ret = 1;
+			goto done;
+		}
+
+		if (c == 'n') {
+			ret = 1;
+			goto done;
+		}
+	}
+
+done:
+	puts("\n");
+	return ret;
+}
+
+static inline void sas_banner_repeat(char *line, unsigned int n,
+					char c, char **pos)
+{
+	char *p = line;
+
+	while (likely(n--))
+		*p++ = c;
+
+	*pos = p;
+}
+
+static void sas_banner_content(const char *fmt, va_list args)
+{
+	int n;
+	char line[80];
+	char *p = line;
+
+	*p++ = '*';
+	*p++ = ' ';
+	n = vsprintf(p, fmt, args);
+	sas_banner_repeat(p + n, 61 - n, ' ', &p);
+
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_header_print(const char *fmt, ...)
+{
+	va_list args;
+	char line[80];
+	char *p = line;
+
+	*p++ = '\n';
+	sas_banner_repeat(p, 64, '*', &p);
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+
+	va_start(args, fmt);
+	sas_banner_content(fmt, args);
+	va_end(args);
+
+	p = line;
+	*p++ = '*';
+	*p++ = ' ';
+	sas_banner_repeat(p, 60, '-', &p);
+
+	*p++ = ' ';
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_content_print(const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sas_banner_content(fmt, args);
+	va_end(args);
+}
+
+void sas_banner_footer_print(void)
+{
+	char line[80];
+	char *p = line;
+
+	sas_banner_repeat(p, 64, '*', &p);
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
+
+void sas_banner_line_print(void)
+{
+	char line[80];
+	char *p = line;
+
+	*p++ = '*';
+	*p++ = ' ';
+	sas_banner_repeat(p, 60, '-', &p);
+
+	*p++ = ' ';
+	*p++ = '*';
+	*p++ = '\n';
+	*p = 0;
+	puts(line);
+}
diff --git a/net/eth.c b/net/eth.c
index 4280d6dbe77eff5f7e19e445f2a32ad75242e734..2afdbf7f2184783240a3e6bf02ef2219fd3bcfdf 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -26,6 +26,7 @@
 #include <net.h>
 #include <miiphy.h>
 #include <phy.h>
+#include <switch.h>
 
 void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
 {
@@ -253,6 +254,8 @@ int eth_initialize(bd_t *bis)
 	phy_init();
 #endif
 
+	switch_init();
+
 	/*
 	 * If board-specific initialization exists, call it.
 	 * If not, call a CPU-specific one
diff --git a/spl/Makefile b/spl/Makefile
index 6ac42a2d6752ce85a21a5814d1ad6eb00b4ab415..999db394cad251ce19eb0560c0294ccf4c9ce53c 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -57,6 +57,8 @@ LIBS-$(CONFIG_SPL_NAND_SUPPORT) += drivers/mtd/nand/libnand.o
 LIBS-$(CONFIG_SPL_ONENAND_SUPPORT) += drivers/mtd/onenand/libonenand.o
 LIBS-$(CONFIG_SPL_DMA_SUPPORT) += drivers/dma/libdma.o
 LIBS-$(CONFIG_SPL_POST_MEM_SUPPORT) += post/drivers/memory.o
+LIBS-$(CONFIG_SPL_LZMA_SUPPORT) += lib/lzma/liblzma.o
+LIBS-$(CONFIG_SPL_LZO_SUPPORT) += lib/lzo/liblzo.o
 
 ifeq ($(SOC),omap3)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
diff --git a/tools/.gitignore b/tools/.gitignore
index e4d2c2f55ec8f767c062b68e01326303debc43d8..f505853ed4d2e88a0dd3e27e22b36933cc3611e9 100644
--- a/tools/.gitignore
+++ b/tools/.gitignore
@@ -2,6 +2,7 @@
 /envcrc
 /gen_eth_addr
 /img2srec
+/ltq-boot-image
 /mkenvimage
 /mkimage
 /mpc86x_clk
@@ -9,7 +10,7 @@
 /ncb
 /ncp
 /ubsha1
-/inca-swap-bytes
+/xway-swap-bytes
 /*.exe
 /easylogo/easylogo
 /env/crc32.c
diff --git a/tools/Makefile b/tools/Makefile
index a5f989a67173446f9af35314e44f360edd4af497..8de3d3617539a5d06c54560d57277870dbaf93cd 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -65,6 +65,7 @@ BIN_FILES-$(CONFIG_VIDEO_LOGO) += bmp_logo$(SFX)
 BIN_FILES-$(CONFIG_BUILD_ENVCRC) += envcrc$(SFX)
 BIN_FILES-$(CONFIG_CMD_NET) += gen_eth_addr$(SFX)
 BIN_FILES-$(CONFIG_CMD_LOADS) += img2srec$(SFX)
+BIN_FILES-$(CONFIG_SOC_LANTIQ) += ltq-boot-image$(SFX)
 BIN_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes$(SFX)
 BIN_FILES-y += mkenvimage$(SFX)
 BIN_FILES-y += mkimage$(SFX)
@@ -87,6 +88,7 @@ OBJ_FILES-$(CONFIG_BUILD_ENVCRC) += envcrc.o
 NOPED_OBJ_FILES-y += fit_image.o
 OBJ_FILES-$(CONFIG_CMD_NET) += gen_eth_addr.o
 OBJ_FILES-$(CONFIG_CMD_LOADS) += img2srec.o
+OBJ_FILES-$(CONFIG_SOC_LANTIQ) += ltq-boot-image.o
 OBJ_FILES-$(CONFIG_XWAY_SWAP_BYTES) += xway-swap-bytes.o
 NOPED_OBJ_FILES-y += aisimage.o
 NOPED_OBJ_FILES-y += kwbimage.o
@@ -188,6 +190,10 @@ $(obj)img2srec$(SFX):	$(obj)img2srec.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
 
+$(obj)ltq-boot-image$(SFX):	$(obj)ltq-boot-image.o
+	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
+	$(HOSTSTRIP) $@
+
 $(obj)xway-swap-bytes$(SFX):	$(obj)xway-swap-bytes.o
 	$(HOSTCC) $(HOSTCFLAGS) $(HOSTLDFLAGS) -o $@ $^
 	$(HOSTSTRIP) $@
diff --git a/tools/ltq-boot-image.c b/tools/ltq-boot-image.c
new file mode 100644
index 0000000000000000000000000000000000000000..74c1dbcb84cb02445b44cbd1bdefae12c4fdb234
--- /dev/null
+++ b/tools/ltq-boot-image.c
@@ -0,0 +1,316 @@
+/*
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ *
+ * Copyright (C) 2011 Daniel Schwierzeck, daniel.schwierzeck@googlemail.com
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <compiler.h>
+#include <sys/stat.h>
+
+enum image_types {
+	IMAGE_NONE,
+	IMAGE_SFSPL
+};
+
+/* Lantiq non-volatile bootstrap command IDs */
+enum nvb_cmd_ids {
+	NVB_CMD_DEBUG	= 0x11,
+	NVB_CMD_REGCFG	= 0x22,
+	NVB_CMD_IDWNLD	= 0x33,
+	NVB_CMD_CDWNLD	= 0x44,
+	NVB_CMD_DWNLD	= 0x55,
+	NVB_CMD_IFCFG	= 0x66,
+	NVB_CMD_START	= 0x77
+};
+
+/* Lantiq non-volatile bootstrap command flags */
+enum nvb_cmd_flags {
+	NVB_FLAG_START	= 1,
+	NVB_FLAG_DEC	= (1 << 1),
+	NVB_FLAG_DBG	= (1 << 2),
+	NVB_FLAG_SDBG	= (1 << 3),
+	NVB_FLAG_CFG0	= (1 << 4),
+	NVB_FLAG_CFG1	= (1 << 5),
+	NVB_FLAG_CFG2	= (1 << 6),
+	NVB_FLAG_RST	= (1 << 7)
+};
+
+struct args {
+	enum image_types type;
+	__u32		entry_addr;
+	const char	*uboot_bin;
+	const char	*spl_bin;
+	const char	*out_bin;
+};
+
+static void usage_msg(const char *name)
+{
+	fprintf(stderr, "%s: [-h] -t type -e entry-addr -u uboot-bin [-s spl-bin] -o out-bin\n",
+		name);
+	fprintf(stderr, " Image types:\n"
+			"  sfspl  - SPL + [compressed] U-Boot for SPI flash\n");
+}
+
+static enum image_types parse_image_type(const char *type)
+{
+	if (!type)
+		return IMAGE_NONE;
+
+	if (!strncmp(type, "sfspl", 6))
+		return IMAGE_SFSPL;
+
+	return IMAGE_NONE;
+}
+
+static int parse_args(int argc, char *argv[], struct args *arg)
+{
+	int opt;
+
+	memset(arg, 0, sizeof(*arg));
+
+	while ((opt = getopt(argc, argv, "ht:e:u:s:o:")) != -1) {
+		switch (opt) {
+		case 'h':
+			usage_msg(argv[0]);
+			return 1;
+		case 't':
+			arg->type = parse_image_type(optarg);
+			break;
+		case 'e':
+			arg->entry_addr = strtoul(optarg, NULL, 16);
+			break;
+		case 'u':
+			arg->uboot_bin = optarg;
+			break;
+		case 's':
+			arg->spl_bin = optarg;
+			break;
+		case 'o':
+			arg->out_bin = optarg;
+			break;
+		default:
+			fprintf(stderr, "Invalid option -%c\n", opt);
+			goto parse_error;
+		}
+	}
+
+	if (arg->type == IMAGE_NONE) {
+		fprintf(stderr, "Invalid image type\n");
+		goto parse_error;
+	}
+
+	if (!arg->uboot_bin) {
+		fprintf(stderr, "Missing U-Boot binary\n");
+		goto parse_error;
+	}
+
+	if (!arg->out_bin) {
+		fprintf(stderr, "Missing output binary\n");
+		goto parse_error;
+	}
+
+	if (arg->type == IMAGE_SFSPL && !arg->spl_bin) {
+		fprintf(stderr, "Missing SPL binary\n");
+		goto parse_error;
+	}
+
+	return 0;
+
+parse_error:
+	usage_msg(argv[0]);
+	return -1;
+}
+
+static __u32 build_nvb_command(unsigned cmdid, unsigned cmdflags)
+{
+	__u32 cmd;
+	__u16 tag;
+
+	tag = (cmdid << 8) | cmdflags;
+	cmd = (tag << 16) | (0xFFFF - tag);
+
+	return cpu_to_be32(cmd);
+}
+
+static int write_header(int fd, const void *hdr, size_t size)
+{
+	ssize_t n;
+
+	n = write(fd, hdr, size);
+	if (n != size) {
+		fprintf(stderr, "Cannot write header: %s\n",
+			strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int write_nvb_dwnld_header(int fd, size_t size, __u32 addr)
+{
+	__u32 hdr[3];
+
+	hdr[0] = build_nvb_command(NVB_CMD_DWNLD, NVB_FLAG_START |
+					NVB_FLAG_SDBG);
+	hdr[1] = cpu_to_be32(size + 4);
+	hdr[2] = cpu_to_be32(addr);
+
+	return write_header(fd, hdr, sizeof(hdr));
+}
+
+static int write_nvb_start_header(int fd, __u32 addr)
+{
+	__u32 hdr[3];
+
+	hdr[0] = build_nvb_command(NVB_CMD_START, NVB_FLAG_SDBG);
+	hdr[1] = cpu_to_be32(4);
+	hdr[2] = cpu_to_be32(addr);
+
+	return write_header(fd, hdr, sizeof(hdr));
+}
+
+static int open_input_bin(const char *name, void **ptr, size_t *size)
+{
+	struct stat sbuf;
+	int ret, fd;
+
+	fd = open(name, O_RDONLY | O_BINARY);
+	if (0 > fd) {
+		fprintf(stderr, "Cannot open %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	ret = fstat(fd, &sbuf);
+	if (0 > ret) {
+		fprintf(stderr, "Cannot fstat %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	*ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0);
+	if (*ptr == MAP_FAILED) {
+		fprintf(stderr, "Cannot mmap %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	*size = sbuf.st_size;
+
+	return fd;
+}
+
+static void close_input_bin(int fd, void *ptr, size_t size)
+{
+	munmap(ptr, size);
+	close(fd);
+}
+
+static int copy_bin(int fd, void *ptr, size_t size)
+{
+	ssize_t n;
+
+	n = write(fd, ptr, size);
+	if (n != size) {
+		fprintf(stderr, "Cannot copy binary: %s\n", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int open_output_bin(const char *name)
+{
+	int fd;
+
+	fd = open(name, O_RDWR | O_CREAT | O_TRUNC | O_SYNC | O_BINARY, 0666);
+	if (0 > fd) {
+		fprintf(stderr, "Cannot open %s: %s\n", name,
+			strerror(errno));
+		return -1;
+	}
+
+	return fd;
+}
+
+static int create_sfspl(const struct args *arg)
+{
+	int out_fd, uboot_fd, spl_fd, ret;
+	void *uboot_ptr, *spl_ptr;
+	size_t uboot_size, spl_size;
+
+	out_fd = open_output_bin(arg->out_bin);
+	if (0 > out_fd)
+		goto err;
+
+	spl_fd = open_input_bin(arg->spl_bin, &spl_ptr, &spl_size);
+	if (0 > spl_fd)
+		goto err_spl;
+
+	uboot_fd = open_input_bin(arg->uboot_bin, &uboot_ptr, &uboot_size);
+	if (0 > uboot_fd)
+		goto err_uboot;
+
+	ret = write_nvb_dwnld_header(out_fd, spl_size, arg->entry_addr);
+	if (ret)
+		goto err_write;
+
+	ret = copy_bin(out_fd, spl_ptr, spl_size);
+	if (ret)
+		goto err_write;
+
+	ret = write_nvb_start_header(out_fd, arg->entry_addr);
+	if (ret)
+		goto err_write;
+
+	ret = copy_bin(out_fd, uboot_ptr, uboot_size);
+	if (ret)
+		goto err_write;
+
+	close_input_bin(uboot_fd, uboot_ptr, uboot_size);
+	close_input_bin(spl_fd, spl_ptr, spl_size);
+	close(out_fd);
+
+	return 0;
+
+err_write:
+	close_input_bin(uboot_fd, uboot_ptr, uboot_size);
+err_uboot:
+	close_input_bin(spl_fd, spl_ptr, spl_size);
+err_spl:
+	close(out_fd);
+err:
+	return -1;
+}
+
+int main(int argc, char *argv[])
+{
+	int ret;
+	struct args arg;
+
+	ret = parse_args(argc, argv, &arg);
+	if (ret)
+		goto done;
+
+	switch (arg.type) {
+	case IMAGE_SFSPL:
+		ret = create_sfspl(&arg);
+		break;
+	default:
+		fprintf(stderr, "Image type not implemented\n");
+		ret = -1;
+		break;
+	}
+
+done:
+	if (ret >= 0)
+		return EXIT_SUCCESS;
+
+	return EXIT_FAILURE;
+}
